<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-tw">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/khunkin.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/khunkin.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/khunkin.github.io/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/khunkin.github.io/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/khunkin.github.io/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/khunkin.github.io/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/khunkin.github.io/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="pattern," />





  <link rel="alternate" href="/khunkin.github.io/atom.xml" title="花與夢境" type="application/atom+xml" />






<meta name="description" content="翻译约定： formalism 形式标准 signalise 信号化通知 timed 时控的，定时的，限时的 untimed 不限时的">
<meta name="keywords" content="pattern">
<meta property="og:type" content="article">
<meta property="og:title" content="Patterns for Timed Property Specifications">
<meta property="og:url" content="http://KunKin.github.io/2018/12/29/Patterns for Timed Property Specifications/index.html">
<meta property="og:site_name" content="花與夢境">
<meta property="og:description" content="翻译约定： formalism 形式标准 signalise 信号化通知 timed 时控的，定时的，限时的 untimed 不限时的">
<meta property="og:locale" content="zh-tw">
<meta property="og:updated_time" content="2018-12-29T07:18:54.561Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Patterns for Timed Property Specifications">
<meta name="twitter:description" content="翻译约定： formalism 形式标准 signalise 信号化通知 timed 时控的，定时的，限时的 untimed 不限时的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/khunkin.github.io/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://KunKin.github.io/2018/12/29/Patterns for Timed Property Specifications/"/>





  <title>Patterns for Timed Property Specifications | 花與夢境</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/khunkin.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">花與夢境</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">記錄與隨想</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/khunkin.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/khunkin.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/khunkin.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/khunkin.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/khunkin.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            關於
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://KunKin.github.io/khunkin.github.io/2018/12/29/Patterns for Timed Property Specifications/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Khunkin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/khunkin.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="花與夢境">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Patterns for Timed Property Specifications</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              
              <time title="創建於" itemprop="dateCreated datePublished" datetime="2018-12-29T11:47:36+08:00">
                2018-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/khunkin.github.io/categories/pattern/" itemprop="url" rel="index">
                    <span itemprop="name">pattern</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>翻译约定：</p>
<p>formalism 形式标准</p>
<p>signalise 信号化通知</p>
<p>timed 时控的，定时的，限时的</p>
<p>untimed 不限时的</p>
<hr>
<a id="more"></a>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>属性规范模式使非专业人员可以编写可用于自动检查模型的正式规范。现有模式可以推断事件的发生和顺序，但不能说明它们的时间。 我们通过与时间相关的模式来扩展这种模式系统。 这使得我们能够指定实时要求。 </p>
<hr>
<h3 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h3><p>实时需求的形式规范是一个容易出错的任务。开发人员认为它难学，但是依赖于 在时态逻辑公式中给出的规范 的模型检查(model checking)在验证系统正确性上又确实很好用。</p>
<p>目前属性规范模式已经成功应用于弥补从业者与模型检查工具之间的距离。只是现有的模式系统没有考虑到关于时间的信息。</p>
<p>对于每个模式，我们构造观察者自动机（称为观察者, 即observers），可以直接应用于定时模型检查工具。这些观察者可以自动构建，模式系统的用户无需亲自动手。这对目前的方法来说是一个利好，因为目前的方法通常来说允许从UML这样的高级语言自动构建模型检查器的输入语言的模型，但不提供工具支持来规范 那些必须经过验证的 需求。</p>
<hr>
<h3 id="2、Untimed-Specification-Patterns-不限时的规范模式"><a href="#2、Untimed-Specification-Patterns-不限时的规范模式" class="headerlink" title="2、Untimed Specification Patterns(不限时的规范模式)"></a>2、Untimed Specification Patterns(不限时的规范模式)</h3><p>Dwyer的《Patterns in property specifications for finite-state verification》中为属性规范开发了一个模式系统。这个模式系统使得不了解时间逻辑的人也能够读写许多不同形式标准的形式规范。这个系统能表达出诸如“一个事件A的发生必须跟随着事件B的发生”。但是这个系统有一些不足之处，它不包含时控属性(timed property)，比如“发生事件A后必须在k个时间单位发生事件B”。</p>
<p>模式的等级制度(hierarchy):</p>
<p>​    <strong>Absence</strong></p>
<p>​    <strong>Universality</strong></p>
<p>​    <strong>Existence</strong></p>
<p>​    <strong>Bounded Existence</strong></p>
<p>​    <strong>Precedence</strong></p>
<p>​     <strong>Chain Precedence/Chain Response</strong></p>
<p>以及范围(scope)：</p>
<p>​    <strong>global</strong></p>
<p>​    <strong>before</strong></p>
<p>​    <strong>after</strong></p>
<p>​    <strong>between</strong></p>
<p>​    <strong>until</strong></p>
<p>以及模式系统的元素：</p>
<p>​    <strong>events</strong></p>
<p>​    <strong>patterns</strong></p>
<p>​    <strong>scopes</strong></p>
<p>这些都在Dwyer的《Patterns in property specifications for finite-state verification》中有详细说明，在此就不赘述了。</p>
<hr>
<h3 id="3、Timed-Observer-Automata（限时观察者自动机）"><a href="#3、Timed-Observer-Automata（限时观察者自动机）" class="headerlink" title="3、Timed Observer Automata（限时观察者自动机）"></a>3、Timed Observer Automata（限时观察者自动机）</h3><p>Dwyer的工作最重要的成果是模式目录(pattern catalogue)。这个目录给出了属性规范到不同形式标准(formalisms)的映射。比如“Globally, S responds P”， 在CTL中可以表达成 AG(P =&gt; AF(S))，在LTL中表达成□(P =&gt; ◇S)。因为很多模型检查工具允许检查按着这些形式标准规范的属性，所以模式目录可以被这些工具直接使用。</p>
<p>所以类似地，我们可以用限时时间逻辑去为限时属性规范建立一个相似的目录。比如可以用TCTL，将属于time-bounded response 属性的“Globally, S responds to P within k time units”， 表达成 AG(P =&gt; AF&lt;k(S))，(其中“&lt;k”是下标)</p>
<p>虽然这样的目录在理论上可能是有趣的，但它实际使用起来将会有许多限制，因为限时模型检查工具不提供对限时时间逻辑的支持，因为无限时模型检查工具使用无限时时间逻辑进行处理。</p>
<p>因此，我们使用（有关时间的）观察者自动机（观察者）去描述所需的系统行为。直观地说，在验证时，观察者与模型并行。当且仅当一些属性在模型中可能被违反，他们才到达一个确定的状态。</p>
<p>时间自动机（Timed automata, TA）。之后会简洁介绍TA。我们还使用 使用了同步标签的不同TA 之间紧急和沟通作为TA原始定义的扩展。</p>
<p>作为一个有限 Buchi(u实际上是u上加两点，即v的拼音式) 自动机，一个TA有一组有限的位置(locations) L和一组T⊆ L×L转换(transitions)。一个位置l0 ∈ L (l是L小写，0是下标)是一个显著的初始位置。这个转换被一个函数标签标记了：L → 2AP（AP是上标），这个函数标签为每个位置(location)分配了一组原子命题。与此同时，有一个有限的关于时钟的集 C 以相同的速度运行着。转换可以与C的子集相关联，这意味着在进行转换时必须重置为零的时钟。</p>
<p>时钟状态的形式为x〜y，其中〜表示来自一个集合{&lt;, &gt;, =, ≤, ≥}的操作符, x∈C, y∈C或者y是一个自然数。时钟状态可以与一个转换相关联，转换可能只有在时钟条件为真时才能进行。</p>
<p>TA可以像接下来这么运行：</p>
<ul>
<li>一开始，自动机在初始位置，所有的时钟被设置为0。</li>
<li>然后，TA可以在两种方式上进行：可以通过转换来改变位置，或者可以在停留在相同位置的同时改变时间。</li>
<li>再之后，将会有多于一种可能的方式来运行：可能位置不变并让时间继续或采取该位置可用的转换之一。这种选择是非确定性的，但是，如果转换被标记为紧急，则这种非确定性会受到限制。如果可以，紧急转换<em>必须</em>立刻被执行。而如果有多个紧急转换，那么将会随机挑选一个。如果能够执行一个紧急转换，那么就不会执行一个非紧急转换。</li>
</ul>
<p>为了给不同TA之间建立交流和同步模型，可以用同步标签<code>X!</code>（发出事件X的信号）和<code>X</code>（事件X的相应反应）去给转换(transition)做标记。如果TA中一个被<code>X!</code>标记了的转换被执行了，那么这意味着在其他自动机中<em>所有</em>被<code>X</code>标记了的转换（这是不被时钟状态或者其他转换的紧急性所禁止的）可以立即执行，而无需考虑任何推迟。一个带着 被<code>X</code>标记的转换 的自动机是处于阻塞(blocked)的，一直到一个被<code>X!</code>标记的相应转换被执行为止。</p>
<p>在另一方面，一个被<code>X!</code>标记的转换是不会被阻塞的，因为没有被<code>X</code>标记的转换可以被执行。（关于这句话，我觉得是不是这个意思：没有被<code>X</code>标记的转换可以被执行时，被<code>X!</code>标记的转换是不会被阻塞的）转换可以拥有最多一个<code>X</code>形式的同步标签，以及最多一个<code>X!</code>形式的同步标签。（在我们基于事件的形式标准中，我们不允许两个事件重合）</p>
<p>同步标签对于 验证模型 与 观察者“查询”系统的行为 的同步非常重要：如果模型中发生了一些“有趣”的事，观察者能即使反应。</p>
<hr>
<h3 id="4、Pattern-Catalogue：Pattern（模式目录：模式）"><a href="#4、Pattern-Catalogue：Pattern（模式目录：模式）" class="headerlink" title="4、Pattern Catalogue：Pattern（模式目录：模式）"></a>4、Pattern Catalogue：Pattern（模式目录：模式）</h3><p>本节将会看到，我们的大多数规范模式如何处理所谓的安全属性。为了证明这个属性是True，有必要去检查观察者是否到达不了某些location。当观察者到达这些location的时候，它能侦测到对于规范的违反。</p>
<p>对于liveness properties（比如，”每一个P的发生都伴随着Q的发生”），考虑infinite runs是必要的。</p>
<p>一般来说，我们为了这样的目标而使用acceptance状态：观察者中的一些location被标记成accepting location（接受位置）。如果一个 non-Zeno的运行经常无限地进入一个接受位置，那么观察者能侦测到一个反例(counterexample)。（在这里我们忽略了non-Zenoness 的形式定义。直观来说，non-Zeno run是一个 在有限次数内，被禁止无限执行许多转换 的状态）</p>
<p>依照惯例，我们用圆圈来描述自动机的位置，用箭头来表示转换。我们将error location定义为：当到达error locations的时候，观察者能侦测到规范被违反。同时我们在相应的圆圈下用<code>ERROR</code>来标记error locations。Accepting location用两个同心圆(a double circle)表示。我们定义显示TA图中最左边的位置总是初始位置。我们称呼那些既不是error 也不是 accepting的locations 为 normal locations。</p>
<p><strong>Absence</strong>：P在一个范围内没有发生</p>
<p><strong>Existence</strong>：P在一个范围内必须有发生</p>
<p><strong>Bounded Existence</strong>：给定的状态/事件在一个范围内必须发生k次。该模式的变体至少指定k次出现，并且至多指定k次出现的状态/事件。</p>
<p><strong>Universality</strong>：给定的状态/事件发生在整个范围内(occurs throughout a scope)，相当于“P 变成 False”这个事件是Absence状态</p>
<p><strong>Precedence</strong>：在一个范围内，P必须总是被Q优先。除非Q进程被“enabled”，否则P不能发生。</p>
<p><strong>Precedence: Q enables P after a delay</strong>：当且仅当Q发生了并且时间&gt;=t(Q)+k，P才是可用的。（当一个P可用后，即使另一个Q发生了，P仍然是可用的）。</p>
<p><strong>Precedence: Q enables P for k time units</strong>：当且仅当Q发生了并且时间&lt;=t(Q)+k，P才是可用的。</p>
<p><strong>Response</strong>：在一个范围内，状态/事件P必须总是被状态/事件Q跟随（或者说，状态/事件P发生之后才能发生状态/事件Q）</p>
<p><strong>Time-Bounded Response: response must occur before t(P)+k</strong>：P必须被Q跟随，但是Q必须在给定的时间区间内发生。</p>
<p><strong>Chain Precedence</strong>：状态/事件队列P1,P2,…,Pn 必须总是被(be preceded by)状态/事件队列Q1,Q2,…,Qn 优先。这个模式是<strong>Precedence</strong>模式的概括(generalization)。</p>
<p><strong>Chain Response</strong>：状态/事件队列P1,P2,…,Pn 发生之后才能发生 (be followedby)状态/事件队列Q1,Q2,…,Qn。这个模式是<strong>Response</strong>模式的概括(generalization)。它可以用来表达有界的FIFO关系</p>
<p>关于Absence、University，Existence，Response，Timed-Bounded Response：response must occur before t(P)+k，Precedence，Precedence： Q enables P after a delay，Precedence： Q enables P for k time units，Bounded Existence，Chain Precedence 以及 Chain Response的图像表示参照文献原文。</p>
<hr>
<h3 id="5、Pattern-Catalogue-Event（模式目录：事件）"><a href="#5、Pattern-Catalogue-Event（模式目录：事件）" class="headerlink" title="5、Pattern Catalogue: Event（模式目录：事件）"></a>5、Pattern Catalogue: Event（模式目录：事件）</h3><p>使用同步标签，TA可以“观察”另一TA中事件的发生，并且如果事件发生并且可以发生同步，则以某种方式作出回应。</p>
<p>但是，我们通常要对与多个事件相关的“观测”或其发生的时间作出反应。我们用到一个术语叫做“关联事件”(combined events)。</p>
<p>reporting TA 被用来处理（handle）这些关联事件。当且仅当关联事件发生时， reporting TA 会作出一定的转换（过渡，transition）。这些转换可以被一个新的同步标记<code>M!</code>所标记。这样子的话，reporting TA 可以像信号化“普通”事件(“simple” events)一样信号化关联事件。</p>
<p>有两种reporting TA：</p>
<ul>
<li><p>一种是每次关联事件发生时，reporting TA总是汇报。</p>
</li>
<li><p>另一种R-TA也会汇报关联事件的发生，但不会每次都汇报。这种R-TA称为 <em>lazy</em>；</p>
</li>
</ul>
<p>以<code>Chain Response</code>模式“一个关于A和B事件的序列 必须总是在 一个关于C和D事件的序列 之前发生” 为例， 假设一个reporting TA  signalise A-B序列的出现(occurance)， 另一个R-TA singalise C-D序列的出现 。当我们用一个模型检查器（model checker）检查这个属性时，系统是否有一钟可能的运行方式违反了这个规范？如果有这么个反例的话，它是能够被模型检查器检查出来的——即使汇报A-B序列的TA是lazy的，因为lazy reporting TA也是能 signalise A-B序列的出现的。在另一方面，signalise C-D序列的出现的R-TA一定不能是lazy的，因为这样做会在A-B发生的地方导致一个错误的反例，随后C-D不会被lazy reporting TA 汇报。</p>
<p>lazy R-TA 的使用可以减少 TA中位置(location)和转换(transition)的数量。除非被明确地表示为lazy的，否则就默认R-TA是 non-lazy 的。</p>
<p><strong>Chains：</strong></p>
<p>​    chain 是指一个时间序列E1…En，这样一个序列是作为关联序列发生的，它是“不重叠”(non-overlapping)的（注：不能并行）， i.e. 只要一个已经开始的chain还没有完成，另一个新的chain就不能开始。</p>
<p>​    论文此处为 一个有着A、B、C三个事件的chain 给出了一个lazy R-TA。(将所有转换标记成<code>urgent</code>就能得到相应的 non-lazy TA）</p>
<p> <strong>Timed-Bounded Chains：</strong></p>
<p>​    timed-bounded chain 是指 事件序列E1…En 在一个给定的时间区间内（ ≤ k个时间单元）的发生。</p>
<p>​    论文此处给出了对于 一个有着A、B、C三个事件的chain 的lazy R-TA和 non-lazy R-TA ，其中non-lazy R-TA更加复杂。</p>
<p><strong>“n times A”：</strong></p>
<p>​    “A occurs n times”是chain的一个特例。每当A发生了n、2n、3n…次的时候， “A occurs n times”会被report。但是A发生了m次时(<code>i*n &lt; m &lt; (i+1)*n</code>)，”A occurs n times”不会被report。将<strong>Chains</strong>中的例子中的A、B、C用urgent action A 替代即可得到<strong>“n times A”</strong>的 reporting TA。</p>
<p><strong>“n times A within k time units”：</strong></p>
<p>​    “within k time units”其实就是“timed-bounded”, 按着字面意思理解就行，指在限定时间区间内A发生n次。</p>
<p>​    要注意时钟状态(clock condition)（比如 x&gt;k）需要在转换被执行前被检查，以及 “重置 时钟x”可以生效。</p>
<p><strong>Collections：</strong></p>
<p>​    上面四种模式的综合。例子看论文，例子中同步和异步的使用构成了一个整体的循环。</p>
<p><strong>Timed-Bounded Collections：</strong></p>
<p>​    Timed-Bounded上面有过说法了，略过。</p>
<p><strong>Non-occurrence in a given time span：</strong></p>
<p>​    如果从 基于事件的视图 切换到 基于状态的视图， 并令事件A表示“一个property变成了true”，事件B表示“一个property 变成了 false”。则“在一个k个时间单元的时间段里， A 不被 B跟随”这个规范意味着“该property保持true的状态至少k个时间单元”。</p>
<p>​    此处论文给出了一个lazy reporting TA的例子</p>
<p>​     当A发生时，一个non-lazy reporting TA将会需要去记住一个次数（它是潜在无限大的(potentially infinite)，即是有可能变成无限大的数），这使我们免于再构造一个R-TA。</p>
<hr>
<h3 id="Pattern-Catalogue-Scopes（模式目录：范围）"><a href="#Pattern-Catalogue-Scopes（模式目录：范围）" class="headerlink" title="Pattern Catalogue: Scopes（模式目录：范围）"></a>Pattern Catalogue: Scopes（模式目录：范围）</h3><p>​    令A是对某些属性(property)的观察者(observer)。A能观察属性是否是<em>globally</em>的， i.e.在模型的整个执行(entire execution)期间。这一章将展示：<em>在给定的范围内（over a given scope）</em>，A是怎么被按顺序改变以检查属性的。遵循Dwyer(上一篇论文的作者)给出的关于untimed scope的定义，这一章将展示A是如何可以被改变去检查一个属性早于、迟于以及直到 t(D)±k （k∈Z，表示时间单元数）时的有效性。</p>
<p>​    将 范围所定义的时间间隔 定义为左开右开（即是” (… , …) “），比如，“before t(D)”不包括时刻t(D)。 </p>
<p>​    D可以是一个关联事件。这使得原始的模式系统更加灵活。</p>
<p>​    处理 scopes 的关键idea在于把A的形式转变为一个 范围依赖(scope-dependent) 的TA——A’。为了在一个给定的范围内检查一个属性，我们可以在 A‘ 它自己中搜索错误运行（error run），也可以构造另一个命名为O的TA，其中O表现得像是一个对于A’的观察者，并且当且仅当 A‘ 中能找到一个错误运行时，O到达一个错误状态(error state)。模型的建立必须满足：reporting TAs 中的转换能够在 A’ 中执行 <code>before</code> 转换， A’ 中的转换能够在 O 中执行 <code>before</code> 转换。</p>
<p>​    这里引用了两个定义：</p>
<ul>
<li><p>如果一个系统的执行中没有出现范围分隔符 (scope delimiter)，那么根据定义，规范将是正确的。比如 <code>P must occur before X</code>，只要系统的整个执行过程中没有X，则这个规范将总是正确的。</p>
</li>
<li><p>在例如<code>Before R, S responds to P</code>的模式中（即 出现了范围分隔符），如果虽然P在Q前面发生，但是回应S发生在R之后，则这个规范被违背了。类似的，<code>After R, P must be preceeded by Q</code>, </p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/khunkin.github.io/tags/pattern/" rel="tag"># pattern</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/khunkin.github.io/2018/12/29/Patterns in property specifications for finite-state verification/" rel="next" title="Patterns in property specifications for finite-state verification">
                <i class="fa fa-chevron-left"></i> Patterns in property specifications for finite-state verification
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/khunkin.github.io/2018/12/29/non-ZenoAndAcceptingLocation/" rel="prev" title="non-Zeno And Accepting Location">
                non-Zeno And Accepting Location <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/khunkin.github.io/images/avatar.gif"
                alt="Khunkin" />
            
              <p class="site-author-name" itemprop="name">Khunkin</p>
              <p class="site-description motion-element" itemprop="description">A personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/khunkin.github.io/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">文章</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/khunkin.github.io/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分類</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/khunkin.github.io/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">標籤</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/khunkin.github.io/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Abstract"><span class="nav-number">1.</span> <span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Introduction"><span class="nav-number">2.</span> <span class="nav-text">1、Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、Untimed-Specification-Patterns-不限时的规范模式"><span class="nav-number">3.</span> <span class="nav-text">2、Untimed Specification Patterns(不限时的规范模式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、Timed-Observer-Automata（限时观察者自动机）"><span class="nav-number">4.</span> <span class="nav-text">3、Timed Observer Automata（限时观察者自动机）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、Pattern-Catalogue：Pattern（模式目录：模式）"><span class="nav-number">5.</span> <span class="nav-text">4、Pattern Catalogue：Pattern（模式目录：模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、Pattern-Catalogue-Event（模式目录：事件）"><span class="nav-number">6.</span> <span class="nav-text">5、Pattern Catalogue: Event（模式目录：事件）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-Catalogue-Scopes（模式目录：范围）"><span class="nav-number">7.</span> <span class="nav-text">Pattern Catalogue: Scopes（模式目录：范围）</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Khunkin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 強力驅動</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主題 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/khunkin.github.io/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/khunkin.github.io/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/khunkin.github.io/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/khunkin.github.io/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/khunkin.github.io/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/khunkin.github.io/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/khunkin.github.io/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
