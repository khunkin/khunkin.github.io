<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-tw">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/khunkin.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/khunkin.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/khunkin.github.io/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/khunkin.github.io/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/khunkin.github.io/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/khunkin.github.io/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/khunkin.github.io/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Python," />





  <link rel="alternate" href="/khunkin.github.io/atom.xml" title="KhunKin書齋" type="application/atom+xml" />






<meta name="description" content="这章讲函数的高级运用. including 设计(design)、递归(recur)、函数对象(function object)、匿名(lambda)">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter19.Advanced Function Topics">
<meta property="og:url" content="http://KunKin.github.io/2018/05/16/Chapter19-Advanced-Function-Topics/index.html">
<meta property="og:site_name" content="KhunKin書齋">
<meta property="og:description" content="这章讲函数的高级运用. including 设计(design)、递归(recur)、函数对象(function object)、匿名(lambda)">
<meta property="og:locale" content="zh-tw">
<meta property="og:updated_time" content="2018-05-16T13:13:48.416Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chapter19.Advanced Function Topics">
<meta name="twitter:description" content="这章讲函数的高级运用. including 设计(design)、递归(recur)、函数对象(function object)、匿名(lambda)">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/khunkin.github.io/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://KunKin.github.io/2018/05/16/Chapter19-Advanced-Function-Topics/"/>





  <title>Chapter19.Advanced Function Topics | KhunKin書齋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/khunkin.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KhunKin書齋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/khunkin.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/khunkin.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/khunkin.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/khunkin.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/khunkin.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            關於
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://KunKin.github.io/khunkin.github.io/2018/05/16/Chapter19-Advanced-Function-Topics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deng Kunquan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/khunkin.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KhunKin書齋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Chapter19.Advanced Function Topics</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">發表於</span>
              
              <time title="創建於" itemprop="dateCreated datePublished" datetime="2018-05-16T11:47:07+08:00">
                2018-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分類於</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/khunkin.github.io/categories/Learning-Python/" itemprop="url" rel="index">
                    <span itemprop="name">Learning Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这章讲函数的高级运用.</p>
<p>including 设计(design)、递归(recur)、函数对象(function object)、匿名(lambda)</p>
<a id="more"></a> 
<hr>
<h5 id="函数的设计层面"><a href="#函数的设计层面" class="headerlink" title="函数的设计层面"></a>函数的设计层面</h5><p>When you start using functions in earnest, you’re faced with choices about how to glue components together—for instance, how to decompose a task into purposeful functions (known as cohesion), how your functions should communicate (called coupling), and so on. You also need to take into account concepts such as the size of your functions, because they directly impact code usability. Some of this falls into the category of structured analysis and design, but it applies to Python code as to any other.</p>
<p>设计函数时面临的问题是把组件粘合在一起：比如，如何将任务分解为有目的的函数（cohesion），以及函数之间应如何交流（coupling）等。</p>
<p>还需要考虑诸如函数大小(size)等概念，因为它们直接影响代码的可用性。 其中一些属于结构化分析和设计类别，但它适用于其他Python代码。</p>
<p>关于函数设计原则：</p>
<table>
<thead>
<tr>
<th>PRINCIPLE</th>
<th>DETIALS</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>coupling</strong></td>
<td>use arguments for inputs and return for outputs.</td>
</tr>
<tr>
<td></td>
<td>use global variables only when truly necessary.</td>
</tr>
<tr>
<td></td>
<td>don’t change mutable arguments unless the caller expects it.</td>
</tr>
<tr>
<td></td>
<td>avoid changing variables in another module file directly.</td>
</tr>
<tr>
<td><strong>cohesion</strong></td>
<td>each function should have a single, unified purpose.</td>
</tr>
<tr>
<td><strong>size</strong></td>
<td>each function should be relatively small</td>
</tr>
</tbody>
</table>
<p>简而言之：降低耦合度(减少内外以及函数之间的相互影响封装性（Encapsulation）)，以及功能的单一性（或者说，专注），还有功能单一性对应的代码长度。</p>
<hr>
<p>#####递归函数（Recursive Functions）</p>
<p>1、可以用 if/else 三元表达式(ternary expression) 来保存一些代码实例(code real estate)：use Python’s if/else ternary expression to save some code real estate.</p>
<p>2、归纳任何可加的类型（当我们假设输入中至少有一个项目(item)时会更加简单）：generalize for any summable type(which is easier if we assume at least one item in the input)</p>
<p>3、使用Python 3.X 的拓展队列赋值来使得下面的 first/rest 更容易地递进：use Python 3.X’s extended sequence assignment to make the first/rest unpacking simpler</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">else</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Use ternary expression</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> L[<span class="number">0</span>] <span class="keyword">if</span> len(L) == <span class="number">1</span> <span class="keyword">else</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Any type, assume one</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line">first, *rest = L</span><br><span class="line"><span class="keyword">return</span> first <span class="keyword">if</span> <span class="keyword">not</span> rest <span class="keyword">else</span> first + mysum(rest) <span class="comment"># Use 3.X ext seq assign</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，后两个在L为 empty list 时会 fail 掉， 但是它们允许任何支持 “+” 操作的类型输入，而不局限于numbers.（然而这样子定义的函数并不具备多态性质，而是先定义的被后定义的覆盖了，于是后两个函数，或者说这三个顺着定义下来，再使用mysum(int)会报错，因为 ‘int’ object is not iterable）</p>
<p>• 单个参数时后两个函数也能工作：The latter two also work on a single string argument (e.g., mysum(‘spam’)), because strings are sequences of one-character strings.（strings 自己就是 一个由许多个单个字符的strings组成的，要记得在Python中，’a’是字符串而非字符）<br>• 第三个函数对于任意的可迭代对象都适用，包括open(filename)，但是不可迭代对象不行 ：The third variant works on arbitrary iterables, including open input files (mysum(open(name))), but the others do not because they index.<br>• 第三个函数不要定义成def mysum(first, *rest), 虽然跟原函数很像，但是却变得没有普适性，因为它期望输入独立的参数，而非一个可迭代对象。</p>
<p>值得注意的是 first, <em>rest = L 这个语句：用\</em>rest创建了一个list类型的rest对象之后，相当于把rest解压开来，然后按照a,b,c,d,… = List 的 形式把L中除了L[0]外的元素依次赋给了rest。这是一种*object的用法，值得学习。</p>
<p><em>双函数递归</em>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> L: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> nonempty(L) <span class="comment"># Call a function that calls me</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">nonempty</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Indirectly recursive</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mysum([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>])</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure>
<hr>
<p>#####递归与循环的比较</p>
<p>Python强调简单的过程，因此用while 循环看起来会更加自然，例如，while通常使事情更加具体一些，并且它不要求函数被定义为允许递归调用。更好的是， for 循环能帮我们自动迭代，这使得递归在大部分情况下变得无关紧要（并且很可能在内存空间和执行时间方面效率较低）。</p>
<p>不过，递归并非一无是处，相反，在遍历任意形状的结构时，我们只能依靠递归（或者等价的基于显式堆栈的算法）。例如计算嵌套子列表结构(树)<code>[1，[2，[3,4]，5]，6，[7,8]]</code>中所有数字之和，由于不是线性迭代，任意嵌套的子列表简单的循环语句在这里不起作用。并且因为子列表可能嵌套到任意深度和任意形状，嵌套的循环语句也无能为力——无法知道有多少层嵌套。这时我们就需要用到递归了。</p>
<p>简而言之，递归在解决非线性迭代的问题时有很好的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> L: <span class="comment"># For each item at this level</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list):</span><br><span class="line">    	tot += x <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	tot += sumtree(x) <span class="comment"># Recur for sublists</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br><span class="line"></span><br><span class="line">L = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]] <span class="comment"># Arbitrary nesting</span></span><br><span class="line">print(sumtree(L)) <span class="comment"># Prints 36</span></span><br><span class="line">print(sumtree(L[<span class="number">1</span>])) <span class="comment"># Prints 14</span></span><br><span class="line">print(sumtree((L[<span class="number">1</span>])[<span class="number">1</span>])) <span class="comment"># Prints 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pathological cases</span></span><br><span class="line">print(sumtree([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>]]]]])) <span class="comment"># Prints 15 (right-heavy)</span></span><br><span class="line">print(sumtree([[[[[<span class="number">1</span>], <span class="number">2</span>], <span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>])) <span class="comment"># Prints 15 (left-heavy)</span></span><br></pre></td></tr></table></figure>
<hr>
<p>#####递归与队列和栈的比较</p>
<p>Python是通过每次递归调用都在调用堆栈(call stack)上push信息来实现递归的，我们也可以通过使用自己的显式堆栈或队列来跟踪剩余的步骤，而不必递归调用来实现递归式过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span> <span class="comment"># Breadth-first, explicit queue</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  items = list(L) <span class="comment"># Start with copy of top level</span></span><br><span class="line">  <span class="keyword">while</span> items:</span><br><span class="line">    front = items.pop(<span class="number">0</span>) <span class="comment"># Fetch/delete front item</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(front, list):</span><br><span class="line">    	tot += front <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	items.extend(front) <span class="comment"># &lt;== Append all in nested list</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure>
<p>从技术上讲，这段代码按照广度优先(breadth-first)的方式遍历列表，因为它将嵌套列表的内容添加到列表的末尾，形成了先进先出队列。 为了更好地模拟递归调用版本的遍历，我们可以将其更改为执行深度优先遍历(depth-first)，只需将嵌套列表的内容添加到列表的前面，形成后进先出堆栈：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#depth-first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span> <span class="comment"># Depth-first, explicit stack</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  items = list(L) <span class="comment"># Start with copy of top level</span></span><br><span class="line">  <span class="keyword">while</span> items:</span><br><span class="line">    front = items.pop(<span class="number">0</span>) <span class="comment"># Fetch/delete front item</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(front, list):</span><br><span class="line">    	tot += front <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    	items[:<span class="number">0</span>] = front <span class="comment"># &lt;== Prepend all in nested list</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure>
<p>这分别是广度优先搜索 和 深度优先搜索的结果(每行最后一个是该行前面的数的总和)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#L = [1, [2, [3, 4], 5], 6, [7, 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">36</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line"><span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">15</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">36</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure>
<hr>
<p>使用递归要避免无限递归循环(cycles)。特别是数据是循环的时候，比如循环图，之前的递归以及显式队列/堆栈都会失败，递归将落入无限递归循环，而其他方法也会落入简单的无限循环。</p>
<p>因此为了防止这种情况的出现，递归调用版本（the recursive call version）可以简单地保留并传递一个关于目前为止的访问状态集合(set)、字典(dictionary) 或者 列表(list):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> state <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">	visited.add(state) <span class="comment"># x.add(state), x[state]=True, or x.append(state)</span></span><br><span class="line">	...proceed...</span><br></pre></td></tr></table></figure>
<p>非递归类替代方案的做法，请注意，检查项目列表中已有的重复项可以避免调度状态(scheduling state)两次，但不会阻止程序重新访问先前遍历的状态,而导致被从列表中删除：</p>
<p>Note that checking for duplicates already on the items list would avoid scheduling a state twice, but would not prevent revisiting a state traversed earlier and hence removed from that list:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visited.add(front)</span><br><span class="line">	...proceed...</span><br><span class="line">	items.extend([x <span class="keyword">for</span> x <span class="keyword">in</span> front <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> visited])</span><br></pre></td></tr></table></figure>
<p>这个模型并不完全适用于本节的用例，它只是在列表中添加数字，但较大的应用程序将能够识别重复的状态 - 例如以前访问过的网页的URL。 </p>
<hr>
<p>某些程序可能还需要记录每个状态的完整路径，以便这些状态完成时报告解决方案。 在这种情况下，非递归方案的堆栈或队列中的每个项目都可能是完整路径列表，这些列表足以记录访问状态的记录，并且包含要在任一端探索的下一个项目。 另外请注意，标准Python限制了其运行时调用堆栈的深度（对递归调用程序至关重要），以捕获无限递归错误。 要扩展它，请使用sys模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrecursionlimit() <span class="comment"># 1000 calls deep default</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.setrecursionlimit(<span class="number">10000</span>) <span class="comment"># Allow deeper nesting</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sys.setrecursionlimit) <span class="comment"># Read more about it</span></span><br></pre></td></tr></table></figure>
<p>允许的最大设置可能因平台而异。 对于通过使用堆栈或队列来避免递归调用、并获得对遍历过程的更多控制的程序而言，这不是必需的。</p>
<hr>
<p>#####函数对象：属性和注释（Function Objects: Attributes and Annotations）</p>
<p>由于Python函数是对象，因此可以编写一般处理它们的程序。 函数对象可以被赋予其他名字，传递给其他函数，嵌入到数据结构中，从一个函数返回到另一个函数，等等，就好像它们是简单的数字或字符串一样。 函数对象也碰巧支持一种特殊的操作：可以通过在函数表达式之后的括号中列出参数来调用它们。 但是，函数与其他对象属于相同的一般类别。这通常被称为第一类对象模型(<em>a first-class object model</em>)，它在Python中无处不在，并且是函数式编程的必要部分。</p>
<p>function object 的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span> <span class="comment"># Name echo assigned to function object</span></span><br><span class="line">		print(message)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(<span class="string">'Direct call'</span>) <span class="comment"># Call object through original name</span></span><br><span class="line">Direct call</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = echo 			<span class="comment"># Now x references the function too</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x(<span class="string">'Indirect call!'</span>) <span class="comment"># Call object through name by adding ()</span></span><br><span class="line">Indirect call!</span><br></pre></td></tr></table></figure>
<p>def实际上是把function对象赋值给了一个name，像其他对象一样，可以通过assign name 的方式(name = name) 来使得另一个name 能够引用这个function对象。</p>
<p>(有点像函数指针)</p>
<p>甚至能当参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">indirect</span><span class="params">(func, arg)</span>:</span></span><br><span class="line">		func(arg) <span class="comment"># Call the passed-in object by adding ()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>indirect(echo, <span class="string">'Argument call!'</span>) <span class="comment"># Pass the function to another function</span></span><br><span class="line">Argument call!</span><br></pre></td></tr></table></figure>
<p>以及放进数据结构里：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>schedule = [ (echo, <span class="string">'Spam!'</span>), (echo, <span class="string">'Ham!'</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (func, arg) <span class="keyword">in</span> schedule:</span><br><span class="line">		func(arg) <span class="comment"># Call functions embedded in containers</span></span><br><span class="line">Spam!</span><br><span class="line">Ham!</span><br></pre></td></tr></table></figure>
<p>functions can also be created and returned for use elsewhere—the closure created in this mode also retains state from the enclosing scope:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(label)</span>:</span> <span class="comment"># Make a function but don't call it</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">        	print(label + <span class="string">':'</span> + message)</span><br><span class="line">        <span class="keyword">return</span> echo		<span class="comment">#Remeber what is returned!</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = make(<span class="string">'Spam'</span>) <span class="comment"># Label in enclosing scope is retained</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'Ham!'</span>) <span class="comment"># Call the function that make returned</span></span><br><span class="line">Spam:Ham!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'Eggs!'</span>)</span><br><span class="line">Spam:Eggs!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make(<span class="string">'Spam'</span>)(<span class="string">'Ham!'</span>)</span><br><span class="line">Spam:Ham!</span><br></pre></td></tr></table></figure>
<p>even:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(label)</span>:</span></span><br><span class="line">        print(<span class="number">1</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">            print(label + <span class="string">':'</span> + message)</span><br><span class="line">        <span class="keyword">return</span> echo</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make(<span class="string">'Spam'</span>)(<span class="string">'Eggs'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">Spam:Eggs</span><br></pre></td></tr></table></figure>
<hr>
<p>function object 的 expression 不止call：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__name__</span><br><span class="line"><span class="string">'func'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure>
<p>自检工具还能探索执行细节：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__</span><br><span class="line">&lt;code object func at <span class="number">0x00000000021A6030</span>, file <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func.__code__)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>,</span><br><span class="line">...more omitted: <span class="number">37</span> total...</span><br><span class="line"><span class="string">'co_argcount'</span>, <span class="string">'co_cellvars'</span>, <span class="string">'co_code'</span>, <span class="string">'co_consts'</span>, <span class="string">'co_filename'</span>,</span><br><span class="line"><span class="string">'co_firstlineno'</span>, <span class="string">'co_flags'</span>, <span class="string">'co_freevars'</span>, <span class="string">'co_kwonlyargcount'</span>, <span class="string">'co_lnotab'</span>,</span><br><span class="line"><span class="string">'co_name'</span>, <span class="string">'co_names'</span>, <span class="string">'co_nlocals'</span>, <span class="string">'co_stacksize'</span>, <span class="string">'co_varnames'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__.co_varnames</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__.co_argcount</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<p>#####函数属性（Function Attributes）</p>
<p>函数属性不局限于前面列出的系统定义的属性，也可以为它们附加任意的用户定义属性(user-defined)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func</span><br><span class="line">&lt;function func at <span class="number">0x000000000296A1E0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.handles = <span class="string">'Button-Press'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.handles</span><br><span class="line"><span class="string">'Button-Press'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>,</span><br><span class="line">...<span class="keyword">and</span> more: <span class="keyword">in</span> <span class="number">3.</span>X all others have double underscores so your names won<span class="string">'t clash...</span></span><br><span class="line"><span class="string">__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'count'</span>, <span class="string">'handles'</span>]</span><br></pre></td></tr></table></figure>
<p>Python自带的属性都带有是”__X__”格式的（Python 3.X）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(f)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dir(f))</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> dir(f) <span class="keyword">if</span> <span class="keyword">not</span> x.startswith(<span class="string">'__'</span>)]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>可以使用这些属性直接将状态信息(<em>state information</em>)附加到函数对象上，而不是使用其他技术，例如全局变量，非局部变量和类。与非局部变量(nonlocal)不同，这些属性可以在函数本身的任何地方访问，即使在代码之外。<br>从某种意义上说，这也是一种在其他语言中模拟“静态局部变量”(static local)的方法 - 变量的名称在函数中是局部的，但在函数退出后其值保留。属性与对象（而不是范围）相关（并且必须通过其代码中的函数名称引用），但实际效果类似。<br>此外，当属性被附加到由其他工厂函数(factory functions)生成的函数时，它们也支持多次复制，每次调用和可写状态保留，就像非局部闭包和类实例属性</p>
<hr>
<p>#####函数注释(Function Annotations)</p>
<p>在Python 3.X（但不是2.X）中，也可以将注释信息（关于函数参数和结果的任意用户定义数据）附加到函数对象。<br>Python为指定注释提供了特殊的语法，但它对它本身不做任何事情; 注释是完全可选的，并且当存在时仅附加到函数对象的__annotations__属性以供其他工具使用。 例如，这样的工具可能会在错误测试的环境中使用注释。 我们在前一章中遇到了Python 3.X的关键字参数， 注释将进一步概括函数头语法。 考虑下面的非注解函数，它用三个参数编码并返回一个结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>在语法上，函数注释在def标题行中编码，作为与参数和返回值关联的任意表达式。</p>
<p> 对于参数，它们出现在紧跟在参数名称后面的冒号后面; </p>
<p>对于返回值，它们是在参数列表之后的 - &gt;之后编写的。 </p>
<p>例如，这段代码注释了前三个函数的参数以及它的返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span>, b: <span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span>, c: float)</span> -&gt; int:</span></span><br><span class="line">		<span class="keyword">return</span> a + b + c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>对func的调用还是照常，只是注释以dictionary的形式存储在了__annotations__属性里。：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; func.__annotations__</span><br><span class="line">&#123;&apos;c&apos;: &lt;class &apos;float&apos;&gt;, &apos;b&apos;: (1, 10), &apos;a&apos;: &apos;spam&apos;, &apos;return&apos;: &lt;class &apos;int&apos;&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>由于这只是一些Python 对象 连接在 一个 Python对象上，因此annotation 也是能够被直接处理(process)的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span>, b, c: <span class="number">99</span>)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> a + b + c</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__annotations__</span><br><span class="line">&#123;<span class="string">'c'</span>: <span class="number">99</span>, <span class="string">'a'</span>: <span class="string">'spam'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> arg <span class="keyword">in</span> func.__annotations__:</span><br><span class="line">		print(arg, <span class="string">'=&gt;'</span>, func.__annotations__[arg])</span><br><span class="line">c =&gt; 99</span><br><span class="line">a =&gt; spam</span><br></pre></td></tr></table></figure>
<p>有两点需要注意：</p>
<p>1、如果代码有annotation， 还是可以照常给参数设定默认值(defaults)</p>
<p>   （形式如 arg : annotation = default）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span> = <span class="number">4</span>, b: <span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span> = <span class="number">5</span>, c: float = <span class="number">6</span>)</span> -&gt; int:</span></span><br><span class="line">		<span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func() <span class="comment"># 4 + 5 + 6 (all defaults)</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, c=<span class="number">10</span>) <span class="comment"># 1 + 5 + 10 (keywords work normally)</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__annotations__</span><br><span class="line">&#123;'c': &lt;class 'float'&gt;, 'b': (1, 10), 'a': 'spam', 'return': &lt;class 'int'&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>2、前面示例中的空格都是可选的 —— 可以在函数头文件中的组件之间使用空格，但忽略空格可能会降低代码可读性。</p>
<p>但是：注释只能在def语句中使用，而不能在lambda表达式(下文对其说明)中使用，因为lambda的语法已经限制了它定义的函数的效用。</p>
<hr>
<p>#####匿名函数 (Anonymous Functions): lambda</p>
<p>lambda表达式创建了一个稍后调用的函数，但它返回的是函数而<em>不是将其分配给名称</em>。 因此lambda有时被称为匿名（即未命名）功能。 在实践中，它们通常用作内联函数定义的方式，或推迟执行一段代码。</p>
<p>lambda 表达式的格式：</p>
<p>​    <code>lambda argument1, argument2,... argumentN : expression using arguments</code></p>
<p>lambda 表达式返回的function object 跟用def 生成并引用的function object 运行起来是一样的。但是有一些差别使得lambda 在特别的方面很有用：</p>
<p>1、lambda 是（仅限于）一个表达式，而非声明：</p>
<p>​    例如，<em>lambda可以出现在Python语法不允许def的地方</em> - 例如列表字面量(list literal)或函数调用的参数(function call’s arguments)。 在def中，函数可以按名称引用，但必须在别处创建。 作为一个表达式，<em>lambda返回一个值（一个新的函数），可以选择分配一个名字</em>。 相比之下，def语句总是将新函数分配给头中的名称，而不是将其作为结果返回。</p>
<p>2、lambda 的主体是一个单一的表达式，而非一个语句块：</p>
<p>​    lambda的主体(body)与def 主体的return语句中放置的内容相似; 只需将结果输入为a naked expression，而非显式返回它， 因为它仅限于一个表达式，所以lambda比def更不常用 —— 你只能将如此多的逻辑压缩到lambda体中而不使用诸如if之类的语句。 <em>这是为了限制程序嵌套而设计的：lambda是为编写简单函数而设计的，def可以处理较大的任务。</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y, z)</span>:</span> <span class="keyword">return</span> x + y + z</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x, y, z: x + y + z</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">#Function objects returned by running lambda expressions work exactly the same as those created and assigned by defs</span></span><br></pre></td></tr></table></figure>
<p>加了默认值(defaults):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Defaults work on lambda arguments, just like in a def:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = (<span class="keyword">lambda</span> a=<span class="string">"fee"</span>, b=<span class="string">"fie"</span>, c=<span class="string">"foe"</span>: a + b + c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x(<span class="string">"wee"</span>)</span><br><span class="line"><span class="string">'weefiefoe'</span></span><br></pre></td></tr></table></figure>
<p>lambda主体(body)中的代码也遵循与def中的代码相同的范围查找规则(scope lookup rules)。 lambda表达式引入了一个本地作用域，就像嵌套的def一样，它可以自动在封装函数、模块和内置作用域中看到名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">knights</span><span class="params">()</span>:</span></span><br><span class="line">        title = <span class="string">'Sir'</span></span><br><span class="line">        action = (<span class="keyword">lambda</span> x: title + <span class="string">' '</span> + x) <span class="comment"># Title in enclosing def scope</span></span><br><span class="line">        <span class="keyword">return</span> action <span class="comment"># Return a function object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act = knights()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg = act(<span class="string">'robin'</span>) <span class="comment"># 'robin' passed to x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">'Sir robin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act <span class="comment"># act: a function, not its result</span></span><br><span class="line">&lt;function knights.&lt;locals&gt;.&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x00000000029CA488</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">()</span>:</span></span><br><span class="line">      	print()</span><br><span class="line">	<span class="keyword">return</span> echo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()			<span class="comment">#same as lambda</span></span><br><span class="line">&lt;function f.&lt;locals&gt;.echo at <span class="number">0x0000024429B60048</span>&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>#####用lambda的原因</p>
<p>一般来说，lambda可以作为一种函数简写方式派上用场，它允许您在使用它的代码中嵌入函数的定义。 它们完全是可选的——你可以总是使用def来代替，尤其是lambda表达式不能轻易满足函数需要时——但在要使用的位置中，lambda往往是简单的编码结构，你只需要嵌入小部分可执行代码内联（small bits of executable code inline）。<br>例如，回调处理程序经常被编码为直接嵌入到注册调用参数列表中的内联lambda表达式，而不是在文件中的其他位置定义def并用名称引用。<br>lambda也常用于编写跳转表(jump tables)，这些跳转表是按需执行的动作列表或字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, <span class="comment"># Inline function definition</span></span><br><span class="line">	<span class="keyword">lambda</span> x: x ** <span class="number">3</span>,</span><br><span class="line">	<span class="keyword">lambda</span> x: x ** <span class="number">4</span>] <span class="comment"># A list of three callable functions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> L:</span><br><span class="line">	print(f(<span class="number">2</span>)) <span class="comment"># Prints 4, 8, 16</span></span><br><span class="line">    </span><br><span class="line">print(L[<span class="number">0</span>](<span class="number">3</span>)) <span class="comment"># Prints 9</span></span><br></pre></td></tr></table></figure>
<p>当需要将小块可执行代码填充到语句在句法上非法的地方时，lambda表达式对def来说是更具有优势的。 例如，前面的代码片段(code snippet,)通过在list literal中嵌入lambda表达式来构建三个函数的list； 在这样的list literal中，def（或者说，语句）不起作用。 等效的def编码需要临时函数名称（可能与其他函数名称冲突）并且函数需要定义在预期使用的上下文之外（可能需要几百行）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">3</span> <span class="comment"># Define named functions</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">4</span></span><br><span class="line"></span><br><span class="line">L = [f1, f2, f3] <span class="comment"># Reference by name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> L:</span><br><span class="line">	print(f(<span class="number">2</span>)) <span class="comment"># Prints 4, 8, 16</span></span><br><span class="line">    </span><br><span class="line">print(L[<span class="number">0</span>](<span class="number">3</span>)) <span class="comment"># Prints 9</span></span><br></pre></td></tr></table></figure>
<hr>
<p>#####多路分支选择(Multiway Branch Switches)</p>
<p>可以用Python中的字典和其他数据结构来做同样的事情来构建更一般的动作表(action table):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key = &apos;got&apos;</span><br><span class="line">&gt;&gt;&gt; &#123;&apos;already&apos;: (lambda: 2 + 2),</span><br><span class="line">&apos;got&apos;: (lambda: 2 * 4),</span><br><span class="line">&apos;one&apos;: (lambda: 2 ** 6)&#125;[key]()</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<p>当Python创建临时字典时，每个嵌套lambda生成并留下稍后调用的函数。 按键索引获取这些函数之一，括号会强制调用获取的函数。 当用这种方式进行编码时，字典变成了一种比通用的多路分支工具。</p>
<p>用def替代的方案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>key = <span class="string">'one'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'already'</span>: f1, <span class="string">'got'</span>: f2, <span class="string">'one'</span>: f3&#125;[key]()</span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>（注意<code>{&#39;already&#39;: f1, &#39;got&#39;: f2, &#39;one&#39;: f3}</code>中用的是函数名<code>f1</code>，而不是<code>f1()</code>,<code>f1()</code>代表的已经是调用函数了。）</p>
<p>替代方案也适用，但是即使只是一小段代码，def 在文件中也可能是任意的。 lambdas提供的代码接近性(code proximity)对于仅在单个上下文中使用的函数特别有用——如果这里的三个函数在别的地方没有用处，则将其定义嵌入dictionary中的lambda expression 是有意义的。 此外，定义形式要求您为这些小函数起名，<em>可能导致与此文件中的其他名称冲突</em>。<br>lambdas在函数调用参数列表中也派上用场，这是一种内联临时函数定义的方法，不会在程序中的任何其他位置使用。在图(map)中lambda函数有别的用途。</p>
<hr>
<p>#####不要混淆代码(Not to Obfuscate Code)</p>
<p>只有明确知道自己在做什么的时候才可以将Python中的大多数语句编写为基于表达式的等价语言。</p>
<p>比如，为了将<strong>选择逻辑</strong>(selection logic)嵌套在一个lambda中，可以用if/else三元表达式， 或者等价却更复杂的 and/or 组合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">	b</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	c</span><br><span class="line"></span><br><span class="line">b <span class="keyword">if</span> a <span class="keyword">else</span> c	<span class="comment">#if/else ternary expression</span></span><br><span class="line"></span><br><span class="line">((a <span class="keyword">and</span> b) <span class="keyword">or</span> c)	<span class="comment">#and/or combination</span></span><br></pre></td></tr></table></figure>
<p>像这样的表达式能够被放进lambda中，因此它们可能被用来执行lambda函数里的选择逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower = (<span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower(<span class="string">'bb'</span>, <span class="string">'aa'</span>)</span><br><span class="line"><span class="string">'aa'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower(<span class="string">'aa'</span>, <span class="string">'bb'</span>)</span><br><span class="line"><span class="string">'aa'</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>此外，如果想在lambda表达式中执行<strong>循环</strong>，还可以嵌入像map calls(图调用)和list comprehension表达式这样的东西 ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: list(map(sys.stdout.write, x)) <span class="comment"># 3.X: must use list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = showall([<span class="string">'spam\n'</span>, <span class="string">'toast\n'</span>, <span class="string">'eggs\n'</span>]) <span class="comment"># 3.X: can use print</span></span><br><span class="line">spam</span><br><span class="line">toast</span><br><span class="line">eggs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: [sys.stdout.write(line) <span class="keyword">for</span> line <span class="keyword">in</span> x]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = showall((<span class="string">'bright\n'</span>, <span class="string">'side\n'</span>, <span class="string">'of\n'</span>, <span class="string">'life\n'</span>))</span><br><span class="line">bright</span><br><span class="line">side</span><br><span class="line">of</span><br><span class="line">life</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: [print(line, end=<span class="string">''</span>) <span class="keyword">for</span> line <span class="keyword">in</span> x] <span class="comment"># Same: 3.X only</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: print(*x, sep=<span class="string">''</span>, end=<span class="string">''</span>) <span class="comment"># Same: 3.X only</span></span><br></pre></td></tr></table></figure>
<p>使用表达式模拟语句是有限制的：例如，工具(tool)比如说：内置setattr、命名空间的__dict__和就地就该可变对象的方法，虽然这些工具有时可以驻留，但是不能直接实现赋值语句的效果 ，函数式编程技术(functional programming techniques)可以让你深入复杂表达的黑暗领域(the dark<br>realm of convoluted expression.)。<br>仅请使用这些技巧作为最后的手段。如果不加以小心，它们可能会导致无法读取(unreadable)（又名混淆(obfuscated))）的Python代码。 一般来说，简单比复杂更好，显式比隐式更好，完整语句比隐晦表达(arcane expressions)更好。 这就是lambda仅限于表达式的原因。<br>如果有更大的代码逻辑，使用def；lambda是用于小块的内联代码的。<br>另一方面，适度使用这些技术是很有帮助的。</p>
<hr>
<p>#####关于and/or</p>
<p>and : 从左到右扫描，返回第一个为假的表达式值，无假值则返回最后一个表达式值。</p>
<p>or    : 从左到右扫描，返回第一个为真的表达式值，无真值则返回最后一个表达式值。</p>
<p>在Python中，and 和 or 执行布尔逻辑演算。但是它们并不返回布尔值，而是返回它们实际进行比较的值之一。（类似C++里面的&amp;&amp;和||的短路求值）</p>
<p>在布尔环境中，0、”、[]、()、{}、None为假；其它任何东西都为真。但是可以在类中定义特定的方法使得类实例的演算值为假。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"betabin"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'betabin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br></pre></td></tr></table></figure>
<p>看起来类似于条件运算符（bool ？a：b），是的，当a为true的时候是一样的。但是，当a为false的时候，就明显不同了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= <span class="string">""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =<span class="string">"python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br></pre></td></tr></table></figure>
<p>可见两种情况都返回了b，与<code>bool ? a : b</code>的效果不同</p>
<p>如果执意用and/or来实现条件运算符，可以用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">""</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"betabin"</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> <span class="keyword">and</span> [a] <span class="keyword">or</span> [b])[<span class="number">0</span>]  </span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>[“”]不为假，从而将a为假的可能性剔除，再通过下标0 (即是[0]) 再获得a。由于获得元素的途经统一，因此b也要套上[]。</p>
<p>and/or 技巧主要在 lambda中使用。</p>
<hr>
<p>#####范围(scope)</p>
<p>lambdas can be nested too</p>
<p>lambdas是嵌套函数范围查找的主要受益者(LEGB中的E)。下面的lambda出现在一个def中——一个典型案例——并且因此可以在调用封闭函数时，访问名称x在封闭函数作用域中的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(x)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">lambda</span> y: x + y) <span class="comment"># Make and return function, remember x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act = action(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act</span><br><span class="line">&lt;function action.&lt;locals&gt;.&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x00000000029CA2F0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act(<span class="number">2</span>) <span class="comment"># Call what action returned</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>((<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> y: x + y))(<span class="number">99</span>))(<span class="number">4</span>)</span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure>
<p>这里，嵌套的lambda结构在调用时会生成一个函数。在这两种情况下，嵌套lambda的代码都可以访问封闭lambda中的变量x。 这确实有用，但它似乎是相当复杂的代码; 为了可读性，通常最好避免嵌套lambda。</p>
<hr>
<p>#####回调函数(callback)</p>
<p>首先明晰一下什么是回调函数(callback)：</p>
<p>​    维基：指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。</p>
<p>​    百度：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回调函数1</span></span><br><span class="line"><span class="comment">#生成一个2k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#回调函数2</span></span><br><span class="line"><span class="comment">#生成一个4k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadruple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">4</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> even <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#中间函数</span></span><br><span class="line"><span class="comment">#接受一个生成偶数的函数作为参数</span></span><br><span class="line"><span class="comment">#返回一个奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddNumber</span><span class="params">(k, getEvenNumber)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getEvenNumber(k)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#起始函数，这里是程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="comment">#当需要生成一个2k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, double)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个4k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, quadruple)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个8k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, <span class="keyword">lambda</span> x: x * <span class="number">8</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">运行`callback_demp.py`，输出如下：</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<hr>
<p>#####lambda 回调函数(callback)</p>
<p>lambda另一个常见的用途是为Python的tkinter GUI API定义内联回调函数(inline callback function)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Button, mainloop <span class="comment"># Tkinter in 2.X</span></span><br><span class="line">x = Button(</span><br><span class="line">        text=<span class="string">'Press me'</span>,</span><br><span class="line">        command=(<span class="keyword">lambda</span>:sys.stdout.write(<span class="string">'Spam\n'</span>))) <span class="comment"># 3.X: print()</span></span><br><span class="line">x.pack()</span><br><span class="line">mainloop() <span class="comment"># This may be optional in console mode</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们将lambda生成的函数传递给command关键字参数以注册(register)回调处理程序。<br>这里的lambda相对于def的优点是处理按钮按下的代码就嵌入在创建按钮(button-creation)的调用中。<br>实际上，lambda延迟处理程序的执行，直到事件发生。如上例中，write在按钮被按下时而非被创建时被调用，并且有效地“知道”在事件发生时应该写入的字符串。<br>因为嵌套的函数作用域规则(the nested function scope rules)也适用于lambda表达式，所以它们也更容易用作回调处理程序（从Python 2.2开始） - 它们自动在它们编码的函数中看到名称，并且在大多数情况下不再需要传入缺省值。<br>这非常便于访问特殊的自我实例参数(special self instance argument)（封装类方法函数中的局部变量）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGui</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">makewidgets</span><span class="params">(self)</span>:</span></span><br><span class="line">		Button(command=(<span class="keyword">lambda</span>: self.onPress(<span class="string">"spam"</span>)))</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">onPress</span><span class="params">(self, message)</span>:</span></span><br><span class="line">		...use message...</span><br></pre></td></tr></table></figure>
<hr>
<p>#####函数编程工具(functional programming tools)</p>
<p>通过大多数定义，Python支持：过程式(procedural)（基本语句basic statements），object-oriented（类）和功能性。对于后者，Python包含一组内置函数，用于函数编程 - 将函数应用于序列和其他迭代器的工具。这个集合包括调用可迭代对象的元素上的函数的工具（map）、根据测试函数过滤元素（filter）、以及，将函数应用于项目对和运行结果（reduce）。<br>虽然边界有时有点模糊，但大多数定义中，Python的函数式编程库也包括前面探讨的一流对象模型(the first-class object model)，嵌套范围闭包(the first-class object model)和匿名函数lambdas.</p>
<p>#####Mapping Functions over Iterables: map</p>
<p>程序对list和其他sequence执行的更常见的操作是对每个元素应用操作，并收集结果——选择数据库表格的列，增加公司中雇员的付费字段，解析电子邮件附件等等：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counters = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>updated = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> counters:</span><br><span class="line">		updated.append(x + <span class="number">10</span>) <span class="comment"># Add 10 to each item</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>updated</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure>
<p>但是由于这是常见操作，Python 也提供了内置函数来实现这种功能。map函数将传入的函数(passed-in function)应用于可迭代对象中的每个元素，并返回一个包含所有函数调用结果的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x + <span class="number">10</span> <span class="comment"># Function to be run</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, counters)) <span class="comment"># Collect results</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure>
<p>通过传递一个<em>user-defined</em>函数来应用于列表中的每个元素的列表——map 调用 inc 中的每个项目，并将所有返回值收集到一个新列表中，我们能更普适地使用它。</p>
<p>因为map需要一个函数的传入和应用，所以它也恰好是lambda常见的地方之一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map((<span class="keyword">lambda</span> x: x + <span class="number">3</span>), counters)) <span class="comment"># Function expression</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>由于这个函数只在这里需要，它被写成了一个用lambda内联的形式(written inline as a lambda)。由于上例中map的使用与for循环是等价的，因此用一小段额外的代码就能够写出一个通用的遍历工具(a general mapping utility)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mymap</span><span class="params">(func, seq)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> seq: res.append(func(x))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>这个自定义的函数对于inc函数的效果是跟之前的map一样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># Built-in is an iterable</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mymap(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># Ours builds a list (see generators)</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure>
<p>但是要注意，map是内置的，这说明它总是可用的、总是以同一种方式运作的，并且有一些性能优势。此外，map 有比上例更加高级的用法，比如给定多个序列参数(sequence arguments)，它将并行序列中的项作为不同的(distinct)参数发送给函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># 3**4</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(pow, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])) <span class="comment"># 1**2, 2**3, 3**4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure>
<p>对于N个序列(N sequences)，映射期望(expect)一个 N-argument 函数。 在这里，pow函数在每次调用上都用到两个参数，每个参数由每个sequence分别传递。 在代码中模拟这种多重序列的通用性(multiple-sequence generality)并没有太多的额外工作，但是需要一些额外的迭代工具。</p>
<p>其实map的调用有点像list comprehension：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[inc(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]] <span class="comment"># Use () parens to generate items instead</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure>
<p>虽然list comprehension 很快，但是在一些情况下，map 可能比list comprehension 更快， 且需要更少的代码。On the other hand，map对每个元素应用一个函数调用(<em>function</em> call)而不是一个任意的表达式，这是一个不太常用的工具，并且通常需要额外的帮助函数或lambda表达式。 此外，用圆括号()而非方括号[]括起comprehension， 能产生一个对象，这个对象能根据请求来生成(<em>generate</em>) value以节省内存并提高响应速度，就像Python 3.X中的map一样。</p>
<p>#####Selecting Items in Iterables: filter</p>
<p>filter:根据测试函数(test function)选择迭代元素</p>
<p>因为过滤器(filter)也返回一个可迭代对象，所以过滤器（比如说，range）需要一个列表调用(list call)来在3.X中显示其所有结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(−<span class="number">5</span>, <span class="number">5</span>)) <span class="comment"># An iterable in 3.X</span></span><br><span class="line">[−<span class="number">5</span>, −<span class="number">4</span>, −<span class="number">3</span>, −<span class="number">2</span>, −<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter((<span class="keyword">lambda</span> x: x &gt; <span class="number">0</span>), range(−<span class="number">5</span>, <span class="number">5</span>))) <span class="comment"># An iterable in 3.X</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>函数返回true的 sequence 或 可迭代对象(iterable)中的 元素将被添加到结果列表中。 像map一样，这个用了filter的函数大致相当于下面的for循环，但它是内置的，简洁的，并且通常很快。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(−<span class="number">5</span>, <span class="number">5</span>): <span class="comment"># The statement equivalent</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        	res.append(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>像 map 一样，用一个更简单的结果（特别是当它可以避免创建一个新函数时），以及在需要延迟生成结果时用一个类似的生成器表达式， filter 能够被 list comprehension 模拟。</p>
<p>Also like map, filter can be emulated by list comprehension syntax with often-simpler results (especially when it can avoid creating a new function), and with a similar generator expression when delayed production of results is desired.</p>
<p>#####Combining Items in Iterables: reduce</p>
<p>reduce 函数更加复杂， 它接受一个可迭代对象(iterable)来运行，但它本身不是一个可迭代的对象——它返回一个单一的结果(single result)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce <span class="comment"># Import in 3.X, not in 2.X</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
<p>在每个步骤中，reduce将当前的总和或总乘积连同list中的下一个元素传递给passed-in lambda函数。 默认情况下，用序列中的第一个元素来初始化起始值。 为了说明，这里是与这些调用中的第一个调用(求总和那个)等价的for循环，并且在循环内部添加硬编码(hardcode)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = L[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">		res = res + x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>以下函数模拟reduce大部分内置行为，并帮助彻底揭开其操作的神秘面纱：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">myreduce</span><span class="params">(function, sequence)</span>:</span></span><br><span class="line">        tally = sequence[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> next <span class="keyword">in</span> sequence[<span class="number">1</span>:]:</span><br><span class="line">        	tally = function(tally, next)</span><br><span class="line">        <span class="keyword">return</span> tally</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myreduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myreduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure>
<p>内置的reduce还允许在list中的item之前放置可选的第三个参数，以便在序列为空时用作默认结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#253&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), [])</span><br><span class="line">TypeError: reduce() of empty sequence <span class="keyword">with</span> no initial value</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), <span class="number">0</span>,[])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#247&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), <span class="number">0</span>,[])</span><br><span class="line">TypeError: reduce() arg <span class="number">2</span> must support iteration</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [],<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [],<span class="number">10</span>)		</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#252&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">TypeError: reduce expected at most <span class="number">3</span> arguments, got <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>standard library 中的 operator module 提供了与内置表达式(build-in expression)相对应的函数，因此可用于某些功能工具的使用:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator, functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(operator.add, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]) <span class="comment"># Function-based +</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>
<hr>
<p>之前提到了硬编码(又叫写死)：</p>
<p><strong>硬编码</strong>（英语：<strong>Hard Code</strong>或<strong>Hard Coding</strong>）是指在软件实现上，将输出或输入的相关参数（例如：路径、输出的形式或格式）直接以常量的方式撰写在源代码中，而非在运行期间由外界指定的设置、资源、数据或格式做出适当回应。一般被认定是种反模式或不完美的实现，因为软件受到输入数据或输出的格式改变就必需修改源代码，对客户而言，改变源代码之外的小设置也许还比较容易。</p>
<p>但硬编码的状况也并非完全只有缺陷，因某些封装需要或软件本身的保护措施，有时是必要的手段。除此之外，有时候因应某些特殊的需求，制作出简单的应用程序，应用程序可能只会运行一次，或者永远只应付一种需求，利用硬编码来缩短开发的时间也是一种不错的决策。</p>
<hr>
<p>本章完毕li</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/khunkin.github.io/tags/Python/" rel="tag"># Python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/khunkin.github.io/2018/05/16/Permutation/" rel="next" title="Permutation">
                <i class="fa fa-chevron-left"></i> Permutation
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/khunkin.github.io/2018/05/16/Chapter28-A-More-Realistic-Example/" rel="prev" title="Chapter28.A More Realistic Example">
                Chapter28.A More Realistic Example <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/khunkin.github.io/images/avatar.gif"
                alt="Deng Kunquan" />
            
              <p class="site-author-name" itemprop="name">Deng Kunquan</p>
              <p class="site-description motion-element" itemprop="description">A personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/khunkin.github.io/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">文章</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/khunkin.github.io/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分類</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/khunkin.github.io/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">標籤</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/khunkin.github.io/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数的设计层面"><span class="nav-number">1.</span> <span class="nav-text">函数的设计层面</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Deng Kunquan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 強力驅動</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主題 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/khunkin.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/khunkin.github.io/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/khunkin.github.io/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/khunkin.github.io/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/khunkin.github.io/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/khunkin.github.io/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/khunkin.github.io/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/khunkin.github.io/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
