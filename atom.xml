<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花與夢境</title>
  
  <subtitle>記錄與隨想</subtitle>
  <link href="/khunkin.github.io/atom.xml" rel="self"/>
  
  <link href="http://KunKin.github.io/"/>
  <updated>2018-12-29T08:06:54.498Z</updated>
  <id>http://KunKin.github.io/</id>
  
  <author>
    <name>Khunkin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Expressing and organizing real-time specification patterns via temporal logics</title>
    <link href="http://KunKin.github.io/2018/12/29/Expressing%20and%20organizing%20real-time%20specification%20patterns%20via%20temporal%20logics/"/>
    <id>http://KunKin.github.io/2018/12/29/Expressing and organizing real-time specification patterns via temporal logics/</id>
    <published>2018-12-29T03:47:42.000Z</published>
    <updated>2018-12-29T08:06:54.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h3><p>The patterns presented in [Dwyer et al, 1999] can be regarded as qualitative patterns with respect to the quantitative patterns proposed in [Konrad and Cheng, 2005].<br><a id="more"></a><br> <strong>Qualitative patterns：</strong>the distance among events is not measured in terms of time units.</p><p><strong>quantitative patterns：</strong>contain specific time bounds that are typically of real time systems. provide a metric of time.    including but not limited to ：TCTL, RTGIL, MTL, TILCO(Temporal Internal Logic with Compositional Operator)；Among them, MTL, TILCO and TRIO are first order temporal logics（一阶时序逻辑）.</p><h4 id="1-1-Paper-organization-contributions-and-related-works"><a href="#1-1-Paper-organization-contributions-and-related-works" class="headerlink" title="1.1 Paper organization, contributions and related works"></a>1.1 Paper organization, contributions and related works</h4><p>impact of the usage of patterns:</p><p>​    1、provide examples of the usage of formal methods (形式方法的使用示例)in many different notations with respect to the same cases， which can shorten the time to understand.</p><p>​    2、shorten the specification time, reuse and compose different patterns for the specification of more complex problems, thus for producing more understandable specifications referring to other users at the commonly known patterns</p><p>Section 3：an overview of qualitative and quantitative specification patterns</p><p>Section 4：the proposed patterns organization is reported together with relationships among patterns &amp;&amp; the arrangement of the new proposed patterns.</p><p>Section 5：qualitative and quantitative patterns expressed in TILCO-X together with their relationships and related demonstrations.</p><p>Section 6：A discussion about patterns’ scope</p><p>Section 7：discussion about the additional scopes and other aspects related to the scopes</p><hr><h3 id="2、-TILCO-X-overview"><a href="#2、-TILCO-X-overview" class="headerlink" title="2、 TILCO-X overview"></a>2、 TILCO-X overview</h3><p><strong>TILCO-X</strong>： a logic language which can be used to specify temporal constraints in either a qualitative or a quantitative way</p><p><strong>instant</strong>：The minimum time interval corresponds to one instant</p><p>The <strong>current, future, past time instant</strong> represented by <strong>0, positive number, negative number</strong> respectively.</p><p><strong>Boundary</strong>: can be included and excluded, represented by  “[“”]” and “(“,”)” respectively </p><p><strong>basic TILCO-X temporal operators</strong>：</p><ul><li>“@”, <strong>universal</strong> quantification over a temporal interval</li><li>“ ? ”, <strong>existential</strong> quantification over a temporal interval</li></ul><p>Interval can be also defined as a single time instant：A@[− 3,−3] ≡ A@− 3.</p><h4 id="2-1-TILCO-X-Dynamic-Intervals"><a href="#2-1-TILCO-X-Dynamic-Intervals" class="headerlink" title="2.1 TILCO-X Dynamic Intervals"></a>2.1 TILCO-X Dynamic Intervals</h4><p>the temporal intervals are not only constant integer sets, but also dynamic interval bound defined as predicates.</p><p>注：$A$@[10,$+B$)states that A is true from 10 time units in the future until <strong>$B$ is true for the first time,</strong>where $+ B$ identifies the first future instant in which $B$ is true.    </p><p>注：同理有 -$B$ identifies the last instant where $B$ was true</p><p>例：$(A \rightarrow B)$@$(-C,+D)$，$A?[+B,+C]$</p><p>注：总结一下就是就近原则。这种以其他event为端点的temporal interval就是Dynamic Interval</p><p>until  $A$ $B$ $≡$ $B$@$(0,+A)$<br>since $A$ $B$ $≡$ $B$@$(− A,0)$</p><h4 id="2-2-TILCO-X-Bounded-Happen"><a href="#2-2-TILCO-X-Bounded-Happen" class="headerlink" title="2.2 TILCO-X Bounded Happen"></a>2.2 TILCO-X Bounded Happen</h4><p><strong>Bounded Happen operator：</strong> used to state that a formula is true in an interval from a minimum to a maximum number of times.</p><p>e.g. $A?^{3}_{2}[1,15)$ indicates $A$ has to be true in the interval from a minimum $(2)$ to a maximum $(3)$ number of times.</p><p>​    可以只有下标(minimum)或者上标(maximum)</p><p><strong>疑$?$：</strong>由Bounded Happen的定义来说，是否只能用 $”?”$？毕竟用@的话，$A$的occurrence 是填满整个interval的，而用$”?”$则$A$可以是离散的</p><hr><h3 id="3、Overview-of-Specification-Patterns"><a href="#3、Overview-of-Specification-Patterns" class="headerlink" title="3、Overview of Specification Patterns"></a>3、Overview of Specification Patterns</h3><p>Patterns are typically formalized considering the:</p><ul><li>Pattern：the pattern itself which is the property, the behavior that has to be specified with the chosen formalism</li><li>Scope</li></ul><h4 id="3-1-Scope"><a href="#3-1-Scope" class="headerlink" title="3.1 Scope"></a>3.1 Scope</h4><ul><li><strong>global，before R，after Q，between Q and R，after Q until R</strong></li><li><strong>in the presence of $F$</strong>：a property has to hold only in an interval where $F$ occurs at least once</li><li><strong>in the absence of $F$</strong>：a property has to hold only in an interval where $F$ never occurs;</li><li><strong>from when $F$ never holds</strong>：a property has to hold only from the state/event where $F$ is going to stay false forever.</li></ul><p><strong>疑？</strong>：if the operators to define the interval are used for modelling the scope, interval logics can be considered an exception. 后半句没看懂..</p><h4 id="3-2-Pattern-models"><a href="#3-2-Pattern-models" class="headerlink" title="3.2 Pattern models"></a>3.2 Pattern models</h4><ul><li><strong>Occurrence Patterns</strong><ul><li>Absence, Universality, Existence, Bounded Existence</li></ul></li><li><strong>Order Patterns</strong><ul><li>Precedence, Response, Chain Precedence, Chain Response</li></ul></li><li><strong>Duration Patterns</strong><ul><li>Minimum Duration, Maximum Duration</li></ul></li><li><strong>Periodic Patterns</strong><ul><li>Bounded Recurrence</li></ul></li><li><strong>Real Time Order Patterns</strong><ul><li>Bounded Response：Limits the maximum time duration from the event/state where a formula is true until another formula becomes true;</li><li>Bounded Invariance：Limits the minimum time duration from the event/state where a formula is true once another formula is true.</li></ul></li></ul><p>bounded：</p><ul><li>In [Konrad and Cheng, 2005], used for describing a bound in time</li><li>In [Dwyer et al, 1999],  refer to a limit in the number of event occurrences</li></ul><p>in order to avoid confusion and provide a unified model, some of the patterns presented in [Konrad and Cheng, 2005] have been renamed in this paper as reported above, mainly by <strong>substituting “Bounded” with “Time-Constrained”</strong>.</p><p>hence：</p><ul><li>Bounded Recurrence $\rightarrow$ Time-Constrained Recurrence</li><li>Bounded Response $\rightarrow$ Time-Constrained Response</li><li>Bounded Invariance $\rightarrow$ Time-Constrained Invariance</li></ul><hr><h3 id="4、Specification-Patterns-Organization"><a href="#4、Specification-Patterns-Organization" class="headerlink" title="4、Specification Patterns Organization"></a>4、Specification Patterns Organization</h3><p>​    The categories distinguish only which kind of constraint the pattern is applying to the predicates:</p><ul><li><strong>Occurrence：</strong>properties which express if a given predicate has to occur, always, never, periodically or for a given amount of times.</li><li><strong>Duration：</strong>properties that, even though not imposing the occurrence, require a predicate to hold for a given duration.</li><li><strong>Order：</strong>properties that put in relationship more predicates, by ordering them.</li></ul><p>3 categories:</p><ul><li><strong>Occurrence：</strong>Absence, Universality, Existence $\rightarrow$ Bounded Existence, Time-Constrained Recurrence</li><li><strong>Duration：</strong>Minimum Duration, Maximum Duration</li><li><strong>Order：</strong>Precedence $\rightarrow$ Time-Constrained Precedence, Response  $\rightarrow$ Time-Constrained Response, Time-Constrained Invariance</li></ul><p>remarks of the categories：</p><ul><li><p>Periodic pattern has not been used, because Time-Constrained Recurrence can be better classified as an occurrence pattern</p></li><li><p>the <strong>Time-Constrained Precedence</strong> is a $new$ $pattern$. </p><ul><li>consists in requiring a cause occurred in the past, in order to accept the present effect, similarly to Precedence pattern.</li><li>in this pattern, time constraints can be specified as lower and upper bounds of the time window, located in the past, where the cause is expected.</li><li><p>dual with respect to the Time-Constrained Response pattern. Hence the needed properties expressing time constraints in the past can be transformed in “<strong>pure future</strong>” form.（由于对偶可以转换成pure future form？<strong>疑：</strong>怎么转换？P Precede Q == Q Respond P然后就能用future了吗？）</p></li><li><p>With some temporal logics, which do not support past operators, a “pure future” transformation could be required when formulating a mapping of this pattern.</p></li></ul></li><li><p><strong>the Time-Constrained Response pattern</strong>：</p><ul><li>​can also produce simpler properties by setting bounds to extreme values，while a single-sided constraint model would require to use two different properties in order to limit the occurrence of the response in a given time window ($i.e.$ $“S$ $responds$ $to$ $P$ $after$ $at$ $most$ $k_{max}$ $time$ $units”,$ and $“if$ $P$ $holds$ $that$ $not$ $S$ $holds$ $for$ $at$ $least$ $k_{min}$ $time$ $units”)$.</li></ul></li></ul><p>$behavioural$ $generalisation：$</p><ul><li>Response pattern can be regarded as a specific case of the Time-Constrained Response（$“S$ $responds$ $to$ $P$ $between$ $k_{min}$ $and$ $k_{max}”$ ,<em>k</em>$_{min}=0$ and <em>k</em>$_{max}=\infin$ ）</li><li>Precedence pattern ~~ Time-Constrained Precedence （<em>k</em>$_{min}=0$ and <em>k</em>$_{max}=-\infin$ , because the time window is located in the past）</li><li>Existence pattern ~~ Bounded Existence pattern：$P?i \equiv P?^{\infin}_{1}i$ （occurrence count is not limited：accepted occurrences of P $\geq$ 1）</li></ul><p>上面的方法把the proposed unified organization of patterns 和 Dwyer et al、Konrad and Cheng的patterns 关联了起来。</p><hr><h3 id="5、Temporal-Logic-Specification-of-Patterns"><a href="#5、Temporal-Logic-Specification-of-Patterns" class="headerlink" title="5、Temporal Logic Specification of Patterns"></a>5、Temporal Logic Specification of Patterns</h3><p><strong>TILCO-X：</strong></p><ul><li>possible to specify formulas in the past and in future in a uniform manner</li><li>specific process <strong>start</strong>：<strong><em>(start : A)</em></strong> $≡$ <strong><em>process_start</em></strong> $→$ <strong><em>A</em></strong>（$process$_$start$ is the given time instant from which any property has to be satisfied）</li><li><strong>rule</strong> imposes the validity of the formula from the process start to the time limit：<strong><em>(rule : A)</em></strong> $≡$ <strong><em>start A</em></strong>@$[0,+∞)$<ul><li>即是<strong><em>(rule : A)</em></strong> $≡$ <strong><em>process_start</em></strong> $→$ <strong><em>A</em></strong>@$[0,+∞)$</li></ul></li></ul><p>$start$：identifies an expression which has to be verified only on the initial time instant</p><p>$rule$：imposes the expression to be verified on the entire time domain.</p><p>$\rightarrow$ patterns are typically presented in the form of $start$ or of $rule$</p><h4 id="5-1-Occurrence-specification-patterns"><a href="#5-1-Occurrence-specification-patterns" class="headerlink" title="5.1 Occurrence specification patterns"></a>5.1 Occurrence specification patterns</h4><p>the scopes modelled through intervals $independently$：</p><table><thead><tr><th style="text-align:right">scope</th><th>interval</th></tr></thead><tbody><tr><td style="text-align:right">Globally</td><td>$[0,+∞)$</td></tr><tr><td style="text-align:right">Before R</td><td>$[0,+$<strong><em>R</em></strong>$)$</td></tr><tr><td style="text-align:right">After Q</td><td>$[+$<strong><em>Q</em></strong>$,+∞)$</td></tr><tr><td style="text-align:right">Between Q and R</td><td>$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</td></tr><tr><td style="text-align:right">After Q until R</td><td>$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</td></tr></tbody></table><p>$example$ $1$：<strong>Absence</strong> pattern Temporal Logic Mappings：</p><table><thead><tr><th style="text-align:right">scope</th><th>TILCO-X Temporal Logic Mappings</th></tr></thead><tbody><tr><td style="text-align:right">Globally</td><td><strong><em>start</em></strong> : $¬$<strong><em>P</em></strong>@$[0,+∞)$</td></tr><tr><td style="text-align:right">Before R</td><td><strong><em>start</em></strong> ：<strong><em>R**</em></strong>?<strong>$(0,+∞)→¬$*</strong>P<strong><em>@$[0,+$</em></strong>R<em>*</em>$)$</td></tr><tr><td style="text-align:right">After Q</td><td><strong><em>start</em></strong> : $¬$<strong><em>P</em></strong>@$[+$<strong><em>Q</em></strong>$,+∞)$</td></tr><tr><td style="text-align:right">Between Q and R</td><td><strong><em>rule</em></strong> ：<strong><em>R**</em></strong>?<strong>$(0,+∞)→¬$*</strong>P<strong><em>@$[+$</em></strong>Q<strong><em>$,+$</em></strong>R<em>*</em>$)$</td></tr><tr><td style="text-align:right">After Q until R</td><td><strong><em>rule</em></strong>：$¬$<strong><em>P</em></strong>@$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</td></tr></tbody></table><p>$example$ $2$：all the occurrence patterns for the “After Q until R” scope：（formulas share the same structure）</p><table><thead><tr><th style="text-align:right">pattern name</th><th>Temporal Logic Mappings</th></tr></thead><tbody><tr><td style="text-align:right">Universality</td><td><strong><em>rule</em></strong> : <strong><em>P</em></strong>@$[+$ <strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</td></tr><tr><td style="text-align:right">Absence</td><td><strong><em>rule</em></strong> : $¬$<strong><em>P</em></strong>@$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</td></tr><tr><td style="text-align:right">Existence</td><td><strong><em>rule</em></strong> : <strong><em>true ?</em></strong>$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)→$<strong><em>P ?</em></strong>$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</td></tr><tr><td style="text-align:right">Bounded Existence</td><td><strong><em>rule</em></strong> : <strong><em>true ?</em></strong>$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)→$<strong><em>P ?</em></strong>$^{max}_{min}[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</td></tr><tr><td style="text-align:right">Time-Constrained Recurrence</td><td><strong><em>rule</em></strong> : $($<strong><em>true ?</em></strong>$[$<strong><em>k</em></strong>$,+$ <strong><em>R</em></strong>$)→$<strong><em>P ?</em></strong>$[$<strong><em>k</em></strong>$,+$<strong><em>R</em></strong>$))$@$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</td></tr></tbody></table><p>注：<strong><em>true</em></strong>?$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$    $\Leftrightarrow$    with respect to the evaluation time instant, a non-empty interval [+Q,+R] will occur in the future (Q and R are predicates).    （注：根据其 Boolean值也可用于判断某个interval是否存在）</p><p><strong>疑：</strong>TILCO-X operators model the occurrence patterns in a quite simple way, while leaving to the intervals the definition of the pattern scope and thus keeping separate the two concepts into the specification. “two concepts”指什么？scope和interval 还是 pattern和interval？</p><p>when the specified time interval is empty， “@” operator is $vacuously$ $true$, while “? ” operator is evaluated as $false$</p><ul><li>$\square (Q $ &amp; $ !R\rightarrow (!R$ $\mathcal{W}$ $(P$ &amp; $!R)))$：The LTL mapping for “$Universality$ $of$ $P$” in “$Between$ $Q$ $and$ $R$” scope</li><li>$\square ((Q $ &amp; $ !R$ &amp; $\lozenge) \rightarrow (P \cup R))$：“$Occurrence$ $of$ $P$” in “$Between$ $Q$ $and$ $R$” scope</li></ul><h4 id="5-2-Duration-Specification-Patterns"><a href="#5-2-Duration-Specification-Patterns" class="headerlink" title="5.2 Duration Specification Patterns"></a>5.2 Duration Specification Patterns</h4><ul><li><p><strong>Minimum duration</strong>  ——  <strong><em>start</em></strong> : $((¬$<strong><em>P</em></strong>@−1$∧$ <strong><em>P</em></strong>$)→$<strong><em>P</em></strong>@$($<strong>0</strong>$,$ <strong><em>k</em></strong>$))$@$[+$<strong><em>Q</em></strong>$,+∞)$</p></li><li><p><strong>Maximum duration</strong> ——  <strong><em>start</em></strong> : $((¬$<strong><em>P</em></strong>@−1$∧$ <strong><em>P</em></strong>$)→ \lnot$<strong><em>P</em></strong>?$($<strong>0</strong>$,$ <strong><em>k</em></strong>$))$@$[+$<strong><em>Q</em></strong>$,+∞)$</p></li><li><p>因为$\lnot($<strong><em>P</em></strong>@$($0$,$ <strong><em>k</em></strong>$))\Leftrightarrow\lnot$<strong><em>P</em></strong>?$($0$,$ <strong><em>k</em></strong>$))$，所以上面两个property 是对偶的（dual）</p><p>   $(¬$<strong><em>P</em></strong>@$−$<strong>1</strong> $∧$ <strong><em>P</em></strong>$)$    $\Leftrightarrow$    the occurrence of a false-true transition of P.     （意思就是P从false transition到了 true）</p></li></ul><h4 id="5-3-Order-Specification-Patterns"><a href="#5-3-Order-Specification-Patterns" class="headerlink" title="5.3 Order Specification Patterns"></a>5.3 Order Specification Patterns</h4><h5 id="5-3-1-Precedence-pattern"><a href="#5-3-1-Precedence-pattern" class="headerlink" title="5.3.1 Precedence pattern"></a>5.3.1 Precedence pattern</h5><p>​    “$S$ $precedes$ $P$” on “$Between$ $Q$ $and$ $R$”：</p><ul><li>with past mapping    <strong><em>rule</em></strong> :<strong><em>R</em></strong>?$($<strong>0</strong>$,+∞)→($<strong><em>P</em></strong> $→$<strong><em>S</em></strong> ?$[−$<strong><em>Q</em></strong>$,$<strong>0</strong>$))$@$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</li><li>pure future mapping   <strong><em>rule</em></strong> :<strong><em>Q</em></strong> $∧$ $¬$<strong><em>R</em></strong> $∧$ <strong><em>R</em></strong>?$($<strong>0</strong>$,+∞)→¬$<strong><em>P</em></strong>@$[$<strong>0</strong>$,+($<strong><em>S</em></strong> $∧$ <strong><em>R</em></strong>$))$</li></ul><p><strong>疑：</strong>pure future到底是怎么个意思，只有future?所以把第一种形式中的负号去掉了？</p><p>​    “$S$ $precedes$ $P$” in “$After$ $Q$” scope：</p><ul><li>in LTL is ：$\square$ $!Q$ | $\lozenge (Q$ &amp; $(!P$ $\mathcal{W}$ $S)$</li><li>but in TILCO-X is <strong><em>P</em></strong>$→$<strong><em>S</em></strong>?$[−$<strong><em>Q</em></strong>$,$<strong>0</strong>$)$</li></ul><h5 id="5-3-2-Response-pattern"><a href="#5-3-2-Response-pattern" class="headerlink" title="5.3.2 Response pattern"></a>5.3.2 Response pattern</h5><p>​    “$S$ $responds$ $to$ $P$” in “$Between$ $Q$ $and$ $R$”：</p><ul><li><p>TILCO-X：<strong><em>rule</em></strong> :<strong><em>R</em></strong>?$($<strong>0</strong>$,+∞)→($<strong><em>P</em></strong> $→$<strong><em>S</em></strong> ?$[$<strong>0</strong>$,+$<strong><em>R</em></strong>$))$@$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</p></li><li><p>LTL：       $\square ((Q$ &amp; $!R$ &amp; $\lozenge R) \rightarrow(P \rightarrow(!R \cup (S$ &amp; $!R)))\cup R)$</p></li></ul><p>  “$S$ $responds$ $to$ $P$” in  “$After$ $Q$”：</p><ul><li><p>LTL：       $\square ($ Q$\rightarrow$ $\square(P \rightarrow \lozenge S))$ </p></li><li><p>TILCO-X：<strong><em>start</em></strong> : $($<strong><em>P</em></strong> $→$<strong><em>S</em></strong>?$[$<strong>0</strong>$,+∞))$@$[+$<strong><em>Q</em></strong>$,+∞)$</p></li></ul><h5 id="5-3-3-Consideration-on-Order-Specification-Patterns"><a href="#5-3-3-Consideration-on-Order-Specification-Patterns" class="headerlink" title="5.3.3 Consideration on Order Specification Patterns"></a>5.3.3 Consideration on Order Specification Patterns</h5><table><thead><tr><th style="text-align:center">Scope</th><th style="text-align:center">Beginning of scope</th><th style="text-align:center">Beginning of scope</th><th style="text-align:center">End of scope</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">w.r.t. process_start</td><td style="text-align:center">w.r.t time instants inside scope</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Parameter predicates</td><td style="text-align:center"><em>scope _ beg</em></td><td style="text-align:center"><em>scope _ beg _ in</em></td><td style="text-align:center"><em>scope _ end</em></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Globally</td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">$-$ <strong><em>process</em></strong> _ <strong><em>start</em></strong></td><td style="text-align:center">$+\infin$</td></tr><tr><td style="text-align:center">Before R</td><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">$-$ <strong><em>process _ start</em></strong></td><td style="text-align:center">$+$<strong><em>R</em></strong></td></tr><tr><td style="text-align:center">After Q</td><td style="text-align:center">$+$<strong><em>Q</em></strong></td><td style="text-align:center">$-$<strong><em>Q</em></strong></td><td style="text-align:center">$+\infin$</td></tr><tr><td style="text-align:center">Between Q and R</td><td style="text-align:center">$+$<strong><em>Q</em></strong></td><td style="text-align:center">$-$<strong><em>Q</em></strong></td><td style="text-align:center">$+$<strong><em>R</em></strong> $(must$ $exist)$</td></tr><tr><td style="text-align:center">After Q until R</td><td style="text-align:center">$+$<strong><em>Q</em></strong></td><td style="text-align:center">$-$<strong><em>Q</em></strong></td><td style="text-align:center">$+$<strong><em>R</em></strong></td></tr></tbody></table><p>The general expression of “$ S $ $precedes$ $P$” for the first three scopes（$Globally$，$Before$ $R$，$After$ $Q$） can be written in terms of parameter predicates (defined as reported in the above table) as</p><p>​        <strong><em>start</em></strong> : $($<strong><em>P</em></strong> $→$<strong><em>S</em></strong> ?$[$<strong><em>scope _ beg _ in</em></strong>$,$<strong>0</strong>$))$@$[$<strong><em>scope _ beg</em></strong>$,$ <strong><em>scope _ end</em></strong> $)$</p><p>“$S$ $precedes$ $P$” in “$After$ $Q$ $until$ $R$” scope：</p><p>​        <strong><em>rule</em></strong> : $($<strong><em>P</em></strong> $→$<strong><em>S</em></strong> ?$[$<strong><em>scope _ beg _ in</em></strong>$,$<strong>0</strong>$))$@$[$<strong><em>scope _ beg</em></strong>$,$ <strong><em>scope _ end</em></strong> $)$</p><p>the expression of “$Between$ $Q$ $and$ $R$” only adds the scope existence (i.e. R must happen)：</p><p>​        <strong><em>rule</em></strong> : $\exist$ <strong><em>scope _ end</em></strong> $\rightarrow$ $($<strong><em>P</em></strong> $→$<strong><em>S</em></strong> ?$[$<strong><em>scope _ beg _ in</em></strong>$,$<strong>0</strong>$))$@$[$<strong><em>scope _ beg</em></strong>$,$ <strong><em>scope _ end</em></strong> $)$</p><p>To let in a clear form the interval “Q-R”      has been considered of great value for the reader.<br>Two versions of TILCO-X mapping for “$S$ $responds$ $to$ $P$” in $After$ $Q$ $until$ $R$ scope are reported :</p><ul><li>rule :  $($<strong><em>P</em></strong> $→$<strong><em>S</em></strong>?$[$<strong>0</strong>$,+$<strong><em>R</em></strong>$))$@$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</li><li>rule :<strong><em>Q</em></strong> $→(($<strong><em>P</em></strong> $→$<strong><em>S</em></strong>?$[$<strong>0</strong>$,+$<strong><em>R</em></strong>$))$@$[+$<strong>0</strong>$,+$<strong><em>R</em></strong>$))$</li></ul><p>（注：这个例子是response的，也就是5.3.2的..不是Precedence，两者不要搞混）</p><h5 id="5-3-4-Time-Constrained-Precedence-Pattern"><a href="#5-3-4-Time-Constrained-Precedence-Pattern" class="headerlink" title="5.3.4 Time-Constrained Precedence Pattern"></a>5.3.4 Time-Constrained Precedence Pattern</h5><h5 id="5-3-5-Time-Constrained-Response-Pattern"><a href="#5-3-5-Time-Constrained-Response-Pattern" class="headerlink" title="5.3.5 Time-Constrained Response Pattern"></a>5.3.5 Time-Constrained Response Pattern</h5><p>​    注：略，appendix里都有了，注意那几个复杂式的化简以及TILCO-X里future和past的使用就好</p><h5 id="5-3-6-Time-Constrained-Invariance-Pattern"><a href="#5-3-6-Time-Constrained-Invariance-Pattern" class="headerlink" title="5.3.6 Time-Constrained Invariance Pattern"></a>5.3.6 Time-Constrained Invariance Pattern</h5><p>​    Invariance Pattern is related to the corresponding real-time version: <strong>Time-Constrained Invariance</strong>.</p><ul><li><p>After Q:                         <strong><em>start</em></strong>: $($<strong><em>P</em></strong> $→$<strong><em>S</em></strong>@$[$<strong>0</strong>$,$<strong><em>k</em></strong>$))$@$[+$<strong><em>Q</em></strong>$,+∞)$</p></li><li><p>Between Q and R rule :   <strong><em>R</em></strong>?$($<strong>0</strong>$,+∞)→($<strong><em>P</em></strong> $→$<strong><em>true</em></strong>$[$<strong><em>k</em></strong>$,+$<strong><em>R</em></strong>$]$ $∧$ <strong><em>S</em></strong>@$[$<strong>0</strong>$,$<strong><em>k</em></strong>$))$@$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$</p><p><strong><em>true</em></strong>$[$<strong><em>k</em></strong>$,+$<strong><em>R</em></strong>$]$ state that “$R$ $occurs$ $after$ $at$ $least$ $k$ $time$ $instants$”.</p></li></ul><p>注意区分：<strong><em>true</em></strong>?$[+$<strong><em>Q</em></strong>$,+$<strong><em>R</em></strong>$)$ 代表的是a non-empty interval [+Q,+R] will occur in the future</p><p>​           而  <strong><em>true</em></strong>$[$<strong><em>k</em></strong>$,+$<strong><em>R</em></strong>$]$  则表示“$R$ $occurs$ $after$ $at$ $least$ $k$ $time$ $instants$”</p><hr><h3 id="6、Discussion-on-Pattern-Scopes"><a href="#6、Discussion-on-Pattern-Scopes" class="headerlink" title="6、Discussion on Pattern Scopes"></a>6、Discussion on Pattern Scopes</h3><p>$in$ $the$ $presence$ $of$ $F$ –– a property has to hold only in an interval where $F$ occurs at least once：</p><p>​                        <strong><em>start</em></strong> : <strong><em>F</em></strong> ?$[$<strong>0</strong>$,+∞)→$<strong><em>P</em></strong>@$[$<strong>0</strong>$,+∞)$ </p><p>$in$ $the$ $absence$ $of$ $F$ –– a property has to hold only in an interval where $F$ never occurs：</p><p>​                        <strong><em>start</em></strong> : $\lnot$<strong><em>F</em></strong> ?$[$<strong>0</strong>$,+∞)→$<strong><em>P</em></strong>@$[$<strong>0</strong>$,+∞)$ </p><p>$from$ $when$ $F$ $never$ $holds$ –– a property has to hold only from the state/event where $F$ is going to stay false for ever：</p><p>​                        <strong><em>start</em></strong> : <strong><em>P</em></strong> @$[+ (¬$<strong><em>F</em></strong> ?$[$<strong>0</strong>$,+∞)),+∞)$</p><hr><h3 id="7、Case-study-Crossroad-Traffic-light-controller"><a href="#7、Case-study-Crossroad-Traffic-light-controller" class="headerlink" title="7、Case study: Crossroad Traffic-light controller"></a>7、Case study: Crossroad Traffic-light controller</h3><p>最后咱们分析出来的结果应该也是像这个case中给出的结果一样，有structured English Grammar、TILCO-X expression、pattern name、scope</p><p>注：这个Section里出现了一个 hybrid interval:   <strong><em>true</em></strong>?$[$<strong><em>BLINK</em></strong>$,+$<strong><em>on</em></strong>$)$,  used with “$?$” and with a “$true$” Boolean expression，means if such interval exists.（用于判断这个interval是否存在）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、Introduction&quot;&gt;&lt;a href=&quot;#1、Introduction&quot; class=&quot;headerlink&quot; title=&quot;1、Introduction&quot;&gt;&lt;/a&gt;1、Introduction&lt;/h3&gt;&lt;p&gt;The patterns presented in [Dwyer et al, 1999] can be regarded as qualitative patterns with respect to the quantitative patterns proposed in [Konrad and Cheng, 2005].&lt;br&gt;
    
    </summary>
    
      <category term="pattern" scheme="http://KunKin.github.io/categories/pattern/"/>
    
    
      <category term="pattern" scheme="http://KunKin.github.io/tags/pattern/"/>
    
  </entry>
  
  <entry>
    <title>TASE2017</title>
    <link href="http://KunKin.github.io/2018/12/29/TASE2017/"/>
    <id>http://KunKin.github.io/2018/12/29/TASE2017/</id>
    <published>2018-12-29T03:47:40.000Z</published>
    <updated>2018-12-29T07:41:41.512Z</updated>
    
    <content type="html"><![CDATA[<h3 id="I-Introduction"><a href="#I-Introduction" class="headerlink" title="I. Introduction"></a>I. Introduction</h3><p>To ease the expression of real-time requirements, Dwyer, and then Konrad, studied a large collection of existing systems in order to identify a set of real-time property patterns covering most of the useful use cases. The goal was to provide a set of <strong>reusable patterns</strong> that system designers can instantiate to express requirements instead of using complex temporal logic formulas.</p><a id="more"></a><p>These works were <strong>mostly oriented</strong> towards providing more expressiveness to users, but did <strong>not really address the verification cost</strong> associated to each new pattern.</p><p>An observer-based approach can help in solving this problem</p><p>Our contributions are twofold: </p><ul><li><p>the definition of a set of <strong>atomic pattern combinators</strong> for the formal expression of real-time requirements;</p></li><li><p>the definition of a set of <strong>elementary observers</strong> in order to check our real-time patterns. </p></li></ul><p><strong>TPN：</strong>：Time <a href="https://zh.wikipedia.org/wiki/Petri%E7%BD%91" target="_blank" rel="noopener">Petri Nets</a></p><p><strong>TTS</strong>：Time Transition System</p><p><strong>TINA</strong>：the time Petri net analyzer, a model-checking toolbox</p><ul><li>a toolbox for the edition and analysis of Petri nets.</li><li>supports nets with inhibitor and read arcs, priorities, stopwatches, and its extension TTS</li></ul><p><strong>TINA toolset：</strong></p><ul><li>tools for the exploration of reachability graphs (<strong>tina</strong> and <strong>sift</strong>) that support<br>a large choice of state abstractions</li><li>model-checkers for LTL (<strong>selt</strong>)</li><li>for CTL and an existential fragment of $\mu$-calculus (<strong>muse</strong>);</li><li>etc.</li></ul><p>(注：reachability 是重点)</p><p>define:</p><ul><li>a set of <strong>event-based</strong> observers at <strong>TPN</strong> level (12 observers)</li><li>a set of <strong>state-based</strong> observers at <strong>TTS</strong> level (4 observers).</li></ul><p>Our observers take advantage of the highest possible level of abstraction provided by TINA (marking abstraction in our case) to reduce the size of the abstract state space that needs to be explored during verification.</p><p>Sect. II：  gives some technical background on model-checking TPN; </p><p>Sect. III： introduces the catalog of real-time property patterns </p><p>Sect. IV： explains the design of observers; </p><p>Sect. V：  illustrates the definition of pattern modifiers and the set of observers; </p><p>Sect. VI： presents the specification and verification on an example of real-time property; </p><p>Sect. VII：gives some concluding remarks.</p><hr><p>###II. TECHNICAL BACKGROUND</p><p><strong>PN（Petri Net）：</strong></p><ul><li>each transition is associated with a local clock that starts once it is enabled; then the transition can fire when the clock value is in the time interval associated with the transition.  $\rightarrow$ 只有在时间区间内transition才能fire</li></ul><p>Petri网的元素：</p><ul><li><strong>库所</strong>（Place）圆形节点</li><li><strong>变迁</strong>（Transition）方形节点</li><li><strong>有向弧</strong>（Arc）是库所和变迁之间的有向弧</li><li><strong>令牌</strong>（Token）是库所中的动态对象，可以从一个库所移动到另一个库所。</li></ul><p><strong>Time Petri nets</strong> can be composed like ordinary Petri net, by combining transitions with a common label. This will be used to add an observer to an existing model. </p><p><strong>TTS</strong>(extension of TINA) extend the semantics of TPN by allowing <em>guards</em> on shared data variables in transitions and <em>expressions</em> that are evaluated when a transition fires.</p><p><strong>core concept</strong>s used in the specification of patterns：</p><ul><li><strong>occurrence</strong>, <strong>predicate</strong>, <strong>scope</strong>, <strong>events</strong>, <strong>states</strong></li></ul><p><strong>pattern：</strong>describes constraints on 3 main kind of (5) elements (below)</p><ul><li>predicate（谓词）: the object of the constraint</li><li>scope: the time interval it should happen</li><li>occurrence: how it compares with the other events<ul><li>The occurrence of a predicate could be specified as existence, absence, always (exist), or exist with a bounded number of occurrences.</li></ul></li></ul><p><strong>event</strong>：an instantaneous and atomic occurrence of an action at a point in time</p><p><strong>state</strong>：identifiers that designate when some given invariant conditions hold</p><hr><h3 id="III-CATALOG-OF-REAL-TIME-PROPERTY-PATTERNS"><a href="#III-CATALOG-OF-REAL-TIME-PROPERTY-PATTERNS" class="headerlink" title="III. CATALOG OF REAL-TIME PROPERTY PATTERNS"></a>III. CATALOG OF REAL-TIME PROPERTY PATTERNS</h3><p><strong>real-time property</strong>： A real-time property = a pattern + a scope</p><p><strong>qualified patterns（8個）：</strong>Absence, Existence, Bounded Existence, Precedence, Response, Chain Precedence, Chain Response</p><p><strong>qualified scope modifiers（5個）：</strong>Global, Before, After, Between, After-Until</p><p><strong>quantitative modifiers（5個）：</strong>Minimum Duration, Maximum Duration, Bounded Recurrence, Bounded Response, Bounded Invariance</p><p><em>**new</em> quantitative scope modifier：</p><ul><li>$Periodically$ （for the specification of periodic events related requirements）</li></ul><p><strong><em>new</em> real-time suffixes（3個）：</strong></p><ul><li>$At$ $least$ &amp; $At$ $most$ —— for the specification of <em>bounded time on state related predicates</em></li><li>$Within$ —— for the specification of <em>time intervals</em>.</li></ul><p>然後作者define a set of elementary constructs for property patterns：（原文此處給出了一個圖示Fig. 2，注意這個圖還說明了各元素之間的層級）</p><ul><li>Basic Predicate = State + Event Modifier            (“=” 表示 “base on”)</li><li>Scope Modifier = Event Modifier</li><li>Atomic Pattern = Occurrence Modifier + Basic Predicate + Scope Modifier</li><li>Composite Pattern = Atomic Pattern    （using binary operators——or, and, imply）</li><li>Real-Time Property Pattern = Atomic Pattern + Composite Pattern</li><li>Real-Time Property = Real-Time Property Pattern</li></ul><p>（為了避免與“Atomic Pattern” 和 “Composite Pattern”混淆，之後文中出現的“pattern”皆指“Property Pattern” ）</p><hr><h3 id="IV-DESIGN-PRINCIPLES-OF-TPN-TTS-OBSERVERS"><a href="#IV-DESIGN-PRINCIPLES-OF-TPN-TTS-OBSERVERS" class="headerlink" title="IV. DESIGN PRINCIPLES OF TPN/TTS OBSERVERS"></a>IV. DESIGN PRINCIPLES OF TPN/TTS OBSERVERS</h3><h4 id="A-Structure-of-Observer"><a href="#A-Structure-of-Observer" class="headerlink" title="$A.$ $Structure$ $of$ $Observer$"></a>$A.$ $Structure$ $of$ $Observer$</h4><p>A <strong>TPN/TTS observer</strong> is a sub-net that will be composed with the net capturing the behavior of the system. </p><p> 简单来说 TPN/TTS observer 是一个子网，这个子网是那些捕获系统行为的网的子网。</p><p>a TTS observer for state-based properties is not composed with the system but simply put in parallel (an operation usually referred to as free product).</p><p>基于状态的属性的TTS observer不是由系统组成，而是简单地并行(<strong>疑：</strong>不是很懂什么意思..)</p><p>$mmc$ == <a href="https://en.wikipedia.org/wiki/Modal_%CE%BC-calculus" target="_blank" rel="noopener">modal $μ$-calculus</a>    (注意是modal)</p><p>$P_{tester}$ (a place) allows properties to be accessed by using accessibility assertions declared within a <strong>modal $μ$-calculus (mmc) formula</strong>.</p><p>$mmc$ <strong>formula</strong> checks the existence of a specific marking and whether a given set of transitions can be fired.</p><p>most basic $mmc$ formulae： $<a href="P_{tester}=1">T</a>$ or $\langle T \rangle (P_{tester}=0)$</p><p>注： $[a]\phi$ == after $a$ necessarily $\phi$ ，其中 $a$ is an action, while $\phi$ is a formula</p><p>注：$\langle a \rangle \phi$ == after $a$ possibly $\phi$  == $\lnot[a]\lnot \phi$</p><p>$<a href="P_{tester}=1">T</a>$ or $\langle T \rangle (P_{tester}=0)$ means that for all (respectively for at least one) successor state, the observer is (respectively is not) in state $P_{tester}$</p><p>All the necessary formulas are checked on-the-fly using the <strong>muse</strong> model checker.</p><p>The abstractions that only preserve state reachability is more effective than the state space abstraction that preserve the set of traces of a language</p><h4 id="B-Soundness-of-Observer"><a href="#B-Soundness-of-Observer" class="headerlink" title="$B.$ $Soundness$ $of$ $Observer$"></a>$B.$ $Soundness$ $of$ $Observer$</h4><p>what Soundness means：</p><ul><li>an observer should not impact the system’s behavior</li><li>an observer should not be able to stop the evolution of time (introducing some kind of time deadlocks)</li></ul><p>soundness == 稳健 == 不影响系统行为 + 不停止时间演变</p><p>observers’ work in a “read-only” mode, guaranteed by the design “linked $from$ TPN transitions”.</p><h4 id="C-Efficiency-of-Observer"><a href="#C-Efficiency-of-Observer" class="headerlink" title="$C.$ $Efficiency$ $of$ $Observer$"></a>$C.$ $Efficiency$ $of$ $Observer$</h4><ul><li>system with integrated(集成的) observers should be able to <strong>generate state class graph</strong>s with a high-level abstraction. This graph should preserve the required semantics of the targeting property（<strong>achieved</strong> by forbidding some elements in TPN during the design, such as the priority arcs. marking graphs and mmc formulae to transform the quantitative verification problems to reachability problems using the <strong>muse</strong> model checker）</li><li>the <strong>generating state</strong> space of a single observer shall be <strong>as small as possible</strong>.(requires us to experiment on different encoding of an observer, in order to select the relatively optimal one)</li><li>the <strong>checking</strong> of each property pattern shall be <strong>independent</strong> to promote parallel computation.</li></ul><hr><h3 id="V-ELEMENTARY-OBSERVERS-FOR-THE-VERIFICATION-OF-PROPERTY-PATTERNS"><a href="#V-ELEMENTARY-OBSERVERS-FOR-THE-VERIFICATION-OF-PROPERTY-PATTERNS" class="headerlink" title="V. ELEMENTARY OBSERVERS FOR THE VERIFICATION OF PROPERTY PATTERNS"></a>V. ELEMENTARY OBSERVERS FOR THE VERIFICATION OF PROPERTY PATTERNS</h3><h4 id="A-Basic-Event-Modifiers"><a href="#A-Basic-Event-Modifiers" class="headerlink" title="$A.$ $Basic$ $Event$ $Modifiers$"></a>$A.$ $Basic$ $Event$ $Modifiers$</h4><p><strong>Predicates</strong> are specified based on <u>events</u> and <u>states</u></p><p>An <strong>event</strong> can be an atomic element $E$, or a composite one, called event modifier</p><p><strong>event modifier</strong> == a composite element $E$ , $e.g.:$</p><ul><li>$E^i$ == the $i^{th}$ occurrence of event $E$</li><li>$t$ $u.t.$ $(unit$ $of$ $time)$ $after$ $event$ $E^{i–k}$.    ——a more complex composite observer</li></ul><p><strong>Observer Structure of Event Modifiers</strong>: $E$ transition $\rightarrow$ Observer，其中Observer = TPN Structure $\rightarrow$ $E’$ transition</p><p><strong>basic event modifiers</strong>（并给出了相应的<strong>event observer</strong>）(注：注意下面的这些event modifier指的是event与$E$之间的时间关系而非event和$E$自身， event可能并不只发生一次)</p><ul><li>$E^{i}$: $the$ $i^{th}$ $occurrence$ $of$ $event$ $E$<ul><li>When $E$ occurred $i$ times, the place $P_{occ}$ has $i$ tokens, and the transition $E^{i}$ is enabled，这确保了 $E^{i}$ 是与the $i^{th}$ occurrence of $E^{i}$ 同时发生的。</li><li>The place $P_{once}$ with one token controls the occurrence times of $E^{i}$. 确保$E^{i}$只occur一次，通过用 其他finite value替换$P_{once}$里的token数量可以enable $E^{i}$ several times. （<strong>疑：</strong>这里不是很理解，为什么第i次能被重复enable？我觉得就算是enable了的话，之后再occur也不是第$i$次了啊？）</li><li>注：$E^{i}$ 的$[0,0]$ 代表 $E^{i}$ should fire immediately (with a delay included in the interval [0, 0]).</li></ul></li><li>$E^{-k}$： $k^{th}$ $delay$ $of$ $E$               <ul><li>$P_{occ}$ stores tokens representing the occurring times of event $E$. Each time $P_{occ}$ has $k$ tokens.</li><li>the read arc enables the transition $E^{–k}$, which consumes one token in $P_{occ}$</li></ul></li><li>$E^{/k}:$ $k$ $times$ $slower$ $sub$-$occurrence$ $of$ $E$<ul><li>When $E$ occurs $k$ times, the place $P_{occ}$ accumulates $k$ tokens $\rightarrow$ the transition $E^{/k}$ is fired $+$ all the $k$ tokens in $P_{occ}$ are consumed.(简单来说就是：token积累到k就fire+释放, 依此循环)</li></ul></li><li>$I+t:$ $time$ $t$ $elapsed$ $since$ $system$ $initialization$                       （$I$ 指代initialize the system，可以看成Event？）<ul><li>used to assess properties, such as worst/best case execution time.</li><li>(place) $P_{Init}$ representing the initialization of the system</li><li>(transition) $E’$ representing $t$ $u.t.$ has elapsed</li></ul></li><li>$E+t:$ $time$ $t$ $elapsed$ $since$ $the$ $occurrence$ $of$ $event$ $E$             （其实把 $I+t$中的$I$看成一个事件那么$I+t$可视为$E+t$的一个特例？）<ul><li>其 event observer 构造类似于$I+t$的 event observer</li></ul></li><li>$S^{S}$ &amp; $S^{E}:$ $entering$ $and$ $exiting$ $events$ $of$ $a$ $State$ $S$<ul><li>the transitions $S^{S}/S^{E}$ represent the entering $/$ exiting events of the state $S$.</li><li>When a system enters the state $S$ $\rightarrow$ (the assertion $S$ in ${P_{RE}}(S)$ is true $\rightarrow$ enable the transition $S_{S}$) $\rightarrow$ transit the token in the place $P_{S}$ to the place $P_{E}$.  (注意与from…to…的区别)</li><li>when the system exits state $S$ $\rightarrow$ the assertion $\lnot S$ in $P_{RE}(\lnot S)$ is true $\rightarrow$ transit the token in the place $P_{E}$ to the place $P_{S}$.</li></ul></li></ul><h4 id="B-Basic-Predicates"><a href="#B-Basic-Predicates" class="headerlink" title="$B. Basic$ $Predicates$"></a>$B. Basic$ $Predicates$</h4><p>generic TPN structure of <strong>predicate observers</strong> 中:</p><ul><li>the <u>transition</u> $E^{M}$ is an event</li><li>the <u>predicate</u> is assessed using the observer and a set of $mmc$ assertions</li></ul><p><strong>basic predicates：</strong></p><ul><li><p>$O(E^{i})​$ $=​$ $true​$ ：$for​$ $the​$ $occurrence​$ $of​$ $event​$ $E^{i}​$</p><ul><li>The <u>place</u> $P_{occ}$ is used to observe the occurrence times of <u>event</u> $E_{M}$</li><li>Once the <u>transition</u> $E_{M}$ has fired $i$ times, the token in $P_{occ}$ is observed, which is assessed using the </li><li><strong>$mmc$ <u>assertion</u></strong> :$P_{occ}$ $\ge$ $i$</li><li>TINA takes $P_{occ}$ as the number of tokens in the place $P_{occ}$</li><li>(<strong>疑：</strong>在这里好像transition == event？表达一致，行为后果也一致)</li></ul></li><li><p>$isFinite(E)$ $=$ $True$：$for$ $the$ $bounded$ $occurrence$ $of$ $E$</p><ul><li>used to assess whether the occurrence of an event is finite.</li><li>$P_{occ}$ accumulates the occurrence times of event $E_{M}$</li><li>The <u>transition</u> $T_{Overflow}$ is not fired $==$ no overflow is detected $==$ $E_{M}$ does not exceed the <u>occurring bound</u> $Occ_{max}$</li><li><strong>$mmc$ assertion</strong>: $\lnot T_{Overflow}$</li></ul></li><li>$Freq(E_{A})$ $\sdot$ $N_{A}$ $=$ $Freq(E_{B})$ $\sdot$ $N_{B}$ ：$for$ $equivalent$ $occurrence$ $of$ $E_{A}$ $and$ $E_{B}$:        （frequency <em> number == frequency </em> number，两个frequency 存在最小公倍数）（<strong>疑：</strong>不是很懂这个equivalent occurrence，是不是跟$E^{i}$之于$E$一样是同一个Event但是在不同时间发生？…直译过来的“等效发生”有点理解不能）<ul><li>used to identify equivalent occurrences between two <u>periodic events</u> with different (or equal) frequencies</li><li>$N_{A}$ and $N_{B}$ is minimal coefficients（$N_{A},N_{B}\in \mathbb{Z}^{+}$）</li><li>$N_{A}$ and $N_{B}$ can be computed using the <u>Least Common Multiple</u> (<strong>lcm</strong>, 最小公倍数) and the <u>Greatest Common Divisor</u> (<strong>gcd</strong>, 最大公因数)<ul><li>$N_{A}= \frac{lcm(F_{A},F_{B})}{gcd(lcm(F_{A},F_{B}), F_{A})}$</li><li>$N_{B}= \frac{lcm(F_{A},F_{B})}{gcd(lcm(F_{A},F_{B}), F_{B})}$</li></ul></li><li>$N_{A}$ and $N_{B}$ should be introduced to identify the corresponding occurrence between $E_{A}$ and $E_{B}$</li><li><u>places</u> $Tester_{A}/Tester_{B}$ counts the occurring times of events $E_{A}/E_{B}$.</li></ul></li><li>$T(E_{A}, E_{B})$ $&gt;$ $t$ ：$for$ $minimal$ $Time$ $Interval$ $between$ $Events$<ul><li>$E_{A}$ and $E_{B}$ can be periodic or aperiodic.</li><li>== $\mathrm{T}$($E_{A}$) $-$ $\mathrm{T}$($E_{B}$) $&gt;$ $t$</li><li>$mmc$ <strong>assertion</strong>：$\lnot(OverflowA\or OverflowB)\and \lnot((Tester_{B} = N_{B}) \and (Tester_{A} &lt; N_{A}) )$   (When $E_{A}$ and $E_{B}$ are aperiodic, $N_{A}$ = $N_{B}$ = 1)</li></ul></li><li>$T(E_{A}, E_{B})$ $&lt;$ $t$： $for$ $maximum$ $Time$ $Interval$ $between$ $Events$<ul><li>== $\mathrm{T}$($E_{A}$) $-$ $\mathrm{T}$($E_{B}$) $&lt;$ $t$</li><li>$mmc$ assertion: $Overflow_{A} \lnot Overflow_{B}$    (<strong>疑：</strong>为什么不是$\lnot(OverflowA\or OverflowB)$？)</li></ul></li><li>$D(S) \ge t$ $\And$ $ D(S) \le t$ ：  $for$ $minimal/maximal$ $time$ $duration$ $of$ $a$ $state$ $S$<ul><li>use the $\mathrm{P_{RE}}$ function of $\mathrm{TTS}$</li><li>transition with constraint [t,t] is enabled when state $S$ holds at least/at most $t$ $u.t.$</li><li>transition with constraint [0,0] will fire when state $S$ does not hold any more.     ——to clear the marking in the place $Tester$(因为系统运行的过程中S可能多次hold)</li><li>$mmc$ assertion:<ul><li>$D(S) \ge t$： $S \and (Tester = 1)$</li><li>$ D(S) \le t$：$S \and (Tester = 0)$</li><li>以$D(S) \ge t$为例说明：  当 time ≥ t 时， [t,t] 的那个transition的time interval已满足，transition fire，于是 $Tester = 1$</li></ul></li></ul></li></ul><h4 id="C-Basic-Scope-Modifiers"><a href="#C-Basic-Scope-Modifiers" class="headerlink" title="$C. Basic$ $Scope$ $Modifiers$"></a>$C. Basic$ $Scope$ $Modifiers$</h4><p><strong>Basic Scope Modifiers</strong></p><ul><li>$\mathit{Globally}$：<ul><li>不需要observer</li><li>requires all states of the system, </li><li>denoted as $\mathcal{A}$</li></ul></li><li>$\mathit{Before}$ $E^{i}$ $\And$ $\mathit{After}$ $E^{i}$<ul><li>$mmc$ assertion:<ul><li>Before:    $Tester &lt;i$</li><li>After:       $Tester\ge i$</li></ul></li></ul></li><li>$\mathit{Between}$ $E_{A}$ $\mathit{and}$ $E_{B}$ <ul><li>means between the equivalent occurrences of $E_{A}$ and $E_{B}$</li><li>IF both $E_{A}$ and $E_{B}$ are periodic events, their occurrence frequencies must be equal</li><li>IF $E_{A}$ and $E_{B}$ occur only once, 则默认 $F_{A}$ = $F_{B}$</li><li>$mmc$ assertion:  $(Tester_{A}=1)\and (Tester_{B}=0)$</li></ul></li><li>$\mathit{After}$ $E_{A}$ $\mathit{until}$ $E_{B}$<ul><li>$E_{B}$ occurs after $E_{A}$：  == $\mathit{Exist}$ $E_{B}$ $\mathit{After}$ $E_{A}$  ==   $\mathit{Between}$ $E_{A}$ $\mathit{and}$ $E_{B}$</li><li>$E_{B}$ does not occur after $E_{A}$：  == $\mathit{Absent}$ $E_{B}$ $\mathit{After}$ $E_{A}$  ==  $\mathit{After}$ $E_{A}$ </li></ul></li></ul><h4 id="D-Occurrence-Modifiers"><a href="#D-Occurrence-Modifiers" class="headerlink" title="$D.$ $Occurrence$ $Modifiers$"></a>$D.$ $Occurrence$ $Modifiers$</h4><p>$N(P)$：<strong>number of states</strong> that match the predicate $P$</p><p>$N(S)$：<strong>number of states</strong> that match the scope $S$</p><p>$N(P\and S)$：<strong>number of states</strong> that match both the predicate and the scope</p><ul><li><p>$Exist$ $P$ $in$ $S$     == $P$ must occur within $S$</p><ul><li>$\begin{cases} {N(P\and S)\ge 1      \mathrm{if} \mathrm{N(S)}&gt;0}\ {True                      \mathrm{if} \mathrm{N(S)}=0} \end{cases}$</li></ul></li><li><p>$Absent$ $P$ $in$ $S$   == $P$ must not occur in $S$</p><ul><li>$N(P\and S) = 0$</li></ul></li><li>$Always$ $P$ $in$ $S$  == $P$ occur through the whole $S$:<ul><li>$N(P\and S) = N(S)$</li></ul></li></ul><p>when $N(S) = 0$, the scope is false, the predicate for any occurrence modifier ($Exist, Absent, Always$) is always true. $Absent$ and $Always$的assertion默认满足此要求，$Exist$中的”True, if N(S)=0”也是为此而定义的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;I-Introduction&quot;&gt;&lt;a href=&quot;#I-Introduction&quot; class=&quot;headerlink&quot; title=&quot;I. Introduction&quot;&gt;&lt;/a&gt;I. Introduction&lt;/h3&gt;&lt;p&gt;To ease the expression of real-time requirements, Dwyer, and then Konrad, studied a large collection of existing systems in order to identify a set of real-time property patterns covering most of the useful use cases. The goal was to provide a set of &lt;strong&gt;reusable patterns&lt;/strong&gt; that system designers can instantiate to express requirements instead of using complex temporal logic formulas.&lt;/p&gt;
    
    </summary>
    
      <category term="pattern" scheme="http://KunKin.github.io/categories/pattern/"/>
    
    
      <category term="pattern" scheme="http://KunKin.github.io/tags/pattern/"/>
    
  </entry>
  
  <entry>
    <title>Real-time specification patterns</title>
    <link href="http://KunKin.github.io/2018/12/29/Real-time%20specification%20patterns/"/>
    <id>http://KunKin.github.io/2018/12/29/Real-time specification patterns/</id>
    <published>2018-12-29T03:47:39.000Z</published>
    <updated>2018-12-29T07:29:00.667Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：</p><p>​    1、基于对 一些工业上的嵌入式系统应用的基于时间的需求， 用三种常用的时序逻辑创造了实时规范模式。</p><p>​    2、为了进一步加强对于一个规范的理解，给出了支持实时属性的结构化英语语法。</p><a id="more"></a><hr><p>翻译约定：</p><p>temporal  时序的</p><hr><h3 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h3><p>常用的正式的规范语言， 如linear-time temporal logic (LTL)，computational tree logic (CTL), graphical interval logic (GIL)，都不能用于规范实时属性，因为他们不支持对时间的定量推理（quantitative reasoning）。</p><p>本文搜集了一些 可以用于规范嵌入式系统的实时属性 的实时性规范模式，这些模式保留了Dwyer的模式风格，但是是与Dwyer的模式互补的。作者提供了到上面三种常用语言的映射。</p><p>别人的工作 ，第一是没有完整的模式系统，二是属性通常仅根据一个实时时间逻辑来规定。对于第二个问题，本文确定了一个common的属性集，这个属性集在三种逻辑中都能够表达。最后，别人的工作也没有提供对 类似于Dwyer用于规范模式的 scope的支持。</p><p>本文给出了一个双管齐下的方法去解决对 规范实时系统的正式属性 的感知困难(the perceived difficulty with specifying formal properties of real-time systems)：实时时间逻辑规范的模版(templates for real-time temporal logic specifications)，以及对属性的自然语言规范。</p><p>本文的实时规范模式包括了 用三种常用的实时时间逻辑规范实时属性 的模版，这三种实时时间逻辑包括：metric temporal logic(MTL), timed computational tree logic(TCTL), real-time graphical interval logic(RTGIL)。</p><p>之所以选择这三种逻辑是因为：</p><p>​    1、便于使用了Dwyer的规范模式的人，这三种逻辑都是与LTL、CTL、GIL直接相关的</p><p>​    2、这三种逻辑都有 有着不同优缺点的工具 的支持，包括模型检查以及定理证明能力——能选择手头上最合适的系统模型</p><p>​    3、MTL 和 TCTL 覆盖了线性时间 和 分支时间，而RTGIL是一个线性时间的时间逻辑——提供了一个易读的对属性的图形化表达。</p><p>此外，本文提出的结构化英文语法可以用来创建一个 关于被一个模式包含的一个规范 的自然语言表述。</p><p>本论文其余部分内容：</p><p>Section 2：回顾模式中使用的规范模式和三种时态逻辑</p><p>Section 3：描述实时指定模式模板和迄今为止未发现的模式。还根据它们所处理的属性类型提供模式的分类</p><p>Section 4：描述论文的方法在电子控制助力转向系统中的应用</p><p>Section 5：相关工作</p><p>Section 6：总结</p><hr><h3 id="2、Background"><a href="#2、Background" class="headerlink" title="2、Background"></a>2、Background</h3><p>在本节中，我们将概述Dwyer等人的规范模式。并简要描述用于我们的模式的实时时间逻辑——MTL、TCTL和RTGIL。实时时间逻辑使用允许定量时间推理的时间运算符来扩展标准时间逻辑。在离散(discrete)时间领域（例如<strong>N</strong>）上解释的实时时间逻辑被称为离散实时时间逻辑(discrete real-time temporal logics)（例如，MTL），而在稠密(dense)时间领域（例如<strong>R</strong>）上解释的实时时间逻辑被称为稠密实时时间逻辑(dense real-time temporal logics)（例如，TCTL和RTGIL）。</p><p>本文使用不带 旧式时间运算符的 时间逻辑，主要是因为很少有分析工具支持老式的时间运算符了。</p><p>分析工具大致可以分成两类：</p><ul><li><p><strong>异构分析工具(Heterogeneous Analysis Tools)</strong>：用多种规范语言对系统建模，并针对系统检查属性。</p></li><li><p><strong>同构分析工具(Homogeneous Analysis Tools)</strong>：使用相同的语言来建模系统和属性。</p></li></ul><h4 id="2-1-Specification-Patterns"><a href="#2-1-Specification-Patterns" class="headerlink" title="2.1 Specification Patterns"></a>2.1 Specification Patterns</h4><p>Dwyer等人描述了适用于以不同形式编写的规范的软件属性的几种模式，例如LTL，CTL，GIL和量化正则表达式（QRE）。</p><p>specification pattern又分为两种：</p><ul><li><p>occurrence pattern</p></li><li><p>order pattern</p></li></ul><p>虽然给定的规范模式可能有适用范围，但是原始规范模式(original specification pattern)不包含定时信息(timing information)。</p><h4 id="2-2-MTL"><a href="#2-2-MTL" class="headerlink" title="2.2 MTL"></a>2.2 MTL</h4><p>MTL (Metric Temporal Logic, 标准时序逻辑) 是LTL（Linear-time temporal logic, 线性时间时序逻辑）的拓展，LTL被翻译成一个离散的时间线。</p><p>MTL假设了一个数字时钟（或者假想时钟，fictitious-clock），这个外部的离散的时钟以一个固定的速度运行(progress)。这个时钟与系统中其他元件是异步的，但是其他元件能随着时钟的每一次滴答同步地提高自己离散的时间变量。可以得知时钟的两次跳动之间的状态顺序，但不能得知其确切的发生时间。MTL包含了 always(□),  eventually(◇), next(○), strong until(U), weak until(W) 等运算符的时间约束版本。</p><p>作为样例的异构分析工具包括了作者最近修订的UML形式化框架，这个框架使用一个 UML类的 Promela 表述和带有时间信息的状态图 ，去建模一个系统，并且使用MTL去规范正确属性(correctness properties)。</p><p>此外，Temporal Rover 支持将 MTL公式生成的代码 包含在程序代码中，以监视运行过程中 MTL规范的满足性。   </p><h4 id="2-3-TCTL"><a href="#2-3-TCTL" class="headerlink" title="2.3 TCTL"></a>2.3 TCTL</h4><p>TCTL (Timed Computational Tree Logic, 定时计算逻辑) 是CTL (Computational Tree Logic) 的拓展。TCTL被解释成一个连续的时间线，包含always(G),  eventually(F), strong until(U), weak until(W) 等运算符， 这些运算符都是被existentially(E) 或者 universally(A) 所量化的。</p><p>存在 支持TCTL(包括 UPPAAL, HyTech, Kronos等)的 异构分析工具。时间自动机被用于建模一个系统，而TCTL被用于规范属性的正确性。Kronos 完全支持TCTL，但UPPAAL和HyTech只在时序公式的开头支持量化，之后则专注于可达性分析(reachability analysis)。</p><h4 id="2-4-RTGIL"><a href="#2-4-RTGIL" class="headerlink" title="2.4 RTGIL"></a>2.4 RTGIL</h4><p>RTGIL(Real-time graphical interval logic, 实时图形区间逻辑)，以及它相应的文字表示RTFIL(Real-time future interval logic, 实时将来区间逻辑)，都是对GIL(graphical interval logic) 和 GIL的文字表示 FIL(future interval logic)，</p><p>RTGIL是一个连续时间(dense time)上解释的命题线性时间时序逻辑(propositional linear-time temporal logic)。</p><p>在RTGIL中，时间线用来显示计算的进展(progression)。间隔(interval) 可以在这个时间线上构造，间隔由两个状态分隔的时间线段表示（左闭右开）。</p><p>Intervals are constructed using search patterns with associated target formulae.</p><p>A search locates the first state in the future from the current position on the time line where the target formula holds (which might be the current state if the formula holds there).</p><p>Initial properties as well as henceforth or eventuality properties can be assigned to an  interval.</p><p>RTGIL 只支持一个实时运算符——谓词<strong>len</strong>( len(d, D] ) ，指代间隔的持续时间（$\gt d  \bigwedge \le D$, D可以是$ \infin $）</p><p>RTGIL 由 RTGIL环境支持， RTGIL environment 包括：graphical editor, automated theorem prover, data base, proof manager component.</p><h4 id="2-5-Discussion"><a href="#2-5-Discussion" class="headerlink" title="2.5 Discussion"></a>2.5 Discussion</h4><p>RTGIL 和 MTL/TCTL的区别：</p><p>​    RTGIL constructs an interval by denoting the states that serve as endpoints to the interval and then places a bound on the duration of this interval.</p><p>​    MTL/TCTL construct an interval with a time-bounded operator and denote the states that can occur in this interval.</p><p>​    简单来说就是：RTGIL——将state表示为端点， MUL/TCTL——表示state所发生的区间</p><p>所以，RTGIL 与 其他linear-time real-time temporal logic 互相是无法表达的。但是，RTGIL是少数decidable的dense real-time temporal logics之一。</p><p>a property expressed in one real-time temporal logic cannot be considered truly equivalent to the same property expressed in a different temporal logic.</p><hr><h3 id="3、Real-time-Patterns"><a href="#3、Real-time-Patterns" class="headerlink" title="3、Real-time Patterns"></a>3、Real-time Patterns</h3><p>Our pattern system is intended to provide strategies for <em>how to specify real-time properties in a formal specification language</em>, where the properties are amenable to automated analysis. </p><p>Due to the selected temporal logics, certain properties are not expressible, for example：</p><ul><li>properties that only apply to one path of execution (MTL and RTGIL formulas are always universally quantified)</li><li>certain properties with strict timing constraints (due to the limited expressiveness of the <strong>len</strong> predicate in RTGIL)</li></ul><p>Selecting a different set of temporal logics leads to a different set of specification patterns.</p><h4 id="3-1-Pattern-Repository-and-Classification"><a href="#3-1-Pattern-Repository-and-Classification" class="headerlink" title="3.1 Pattern Repository and Classification"></a>3.1 Pattern Repository and Classification</h4><p>three <strong>broad categories</strong> of real-time properties：</p><ul><li><strong>duration：</strong>captures properties that can be used to place bounds on the duration of an occurrence.</li><li><strong>periodic：</strong> describes properties that address periodic occurrences.</li><li><strong>real-time order：</strong> captures properties that place time bounds on the order of two occurrences.</li></ul><p><strong>real-time</strong> specification patterns</p><table><thead><tr><th>Category</th><th>Pattern Name</th><th>Description</th></tr></thead><tbody><tr><td><strong>Duration</strong></td><td><strong>Minimum Duration</strong></td><td>Describes the minimum amount of time a state formula has to hold once it becomes true.</td></tr><tr><td></td><td><strong>Maximum Duration</strong></td><td>Captures that a state formula always holds for less than a specified amount of time.</td></tr><tr><td><strong>Periodic</strong></td><td><strong>Bounded Recurrence</strong></td><td>Denotes the amount of time in which a state formula has to hold at least once.</td></tr><tr><td><strong>Real-time Order</strong></td><td><strong>Bounded Response</strong></td><td>Restricts the maximum amount of time that passes after a state formula holds until another state</td></tr><tr><td></td><td><strong>Bounded Invariance</strong></td><td>Specifies the minimum amount of time a state formula must hold once another state formula is</td></tr></tbody></table><h4 id="3-2-Structured-English"><a href="#3-2-Structured-English" class="headerlink" title="3.2 Structured English"></a>3.2 Structured English</h4><p>作者提出的 structured English grammar 支持定性的(qualitative)  也支持实时的 规范模式。</p><p>注：property的意思是scope后面接个$ 逗号, $，再接specification，最后放个$句号.$。 事实上其他的语句也是一样，有点像字符串拼接 xxx+ str + xxx</p><p>注：语法的结构需要结合下面的rules</p><h5 id="structured-English-Grammar’s-structure"><a href="#structured-English-Grammar’s-structure" class="headerlink" title="structured English Grammar’s structure"></a><strong>structured English Grammar’s structure</strong></h5><p>​    <strong>Start</strong>：</p><p>​        1、property：                    scope $,$ specification $.$</p><p>​    <strong>Scope：</strong></p><p>​        2、scope：                        $Globally$ | $Before$ <strong>R</strong> | $After$ <strong>Q</strong> | $Between$ <strong>Q</strong> $and$ <strong>R</strong>| $After$ <strong>Q</strong> $until$ <strong>R</strong></p><p>​    <strong>General：</strong></p><p>​        3、specification：                $qualitative Type$| $realtime Type$</p><p>​    <strong>Qualitative：</strong></p><p>​        4、qualitativeType：                $occurrenceCategory$ | $orderCategory$</p><p>​        5、occurrenceCategory：            $absencePattern$ | $universalityPattern$ | $existencePattern$ | $boundedExistencePattern$</p><p>​        6、absencePattern：                it is never the case that <strong>P</strong> holds</p><p>​        7、universalityPattern：            it is always the case that <strong>P</strong> holds</p><p>​        8、existencePattern：             <strong>P</strong> eventually holds</p><p>​        9、boundedExistencePattern：    transitions to states in which P holds occur at most twice</p><p>​        10、orderCategory：                 it is always the case that if  <strong>P</strong> holds  ($precedencePattern$ | $precedenceChainPattern1$-$2$ | $precedenceChainPattern2$-$1$ | $responsePattern$ | $responseChainPattern1$-$2$ |$responseChainPattern2$-$1$ | $constrainedChainPattern1$-$2$)</p><p>​        11、precedencePattern：            , then  <strong>S</strong> previously held</p><p>​        12、precedenceChainPattern1-2：     and is succeeded by  <strong>S</strong> , then  <strong>T</strong>  previously held</p><p>​        13、precedenceChainPattern2-1：    , then  <strong>S</strong>  previously held and was preceded by  <strong>T</strong></p><p>​        14、responsePattern：            , then  <strong>S</strong>  eventually holds</p><p>​        15、responseChainPattern1-2：    , then  <strong>S</strong>  eventually holds and is succeeded by  <strong>T</strong></p><p>​        16、responseChainPattern2-1：     and is succeeded by  <strong>S</strong> , then  <strong>T</strong>  eventually holds after  <strong>S</strong></p><p>​        17、constrainedChainPattern1-2：    , then  <strong>S</strong>  eventually holds and is succeeded by  <strong>T</strong> , where  <strong>Z</strong>  does not hold between  <strong>S</strong>  and  <strong>T</strong></p><p>​    <strong>Realtime：</strong></p><p>​        18、realtimeType：                it is always the case that  $(durationCategory$ | $periodicCategory$ | $realtimeOrderCategory)$</p><p>​        19、durationCategory：            once  <strong>P</strong>  becomes satisfied, it holds for  $(minDurationPattern$ | $maxDurationPattern)$</p><p>​        20、minDurationPattern：        at least  <strong>c</strong>  time unit(s)</p><p>​        21、maxDurationPattern：        less than  <strong>c</strong>  time unit(s)</p><p>​        22、periodicCategory：            <strong>P</strong>  holds  $boundedRecurrencePattern$</p><p>​        23、boundedRecurrencePattern：    at least every  <strong>c</strong>  time unit(s)</p><p>​        24、realtimeOrderCategory：        if  <strong>P</strong>  holds, then  <strong>S</strong>  holds  $(boundedResponsePattern$ | $boundedInvariancePattern)$</p><p>​        25、boundedResponsePattern：    after at most  <strong>c</strong>  time unit(s)</p><p>​        26、boundedInvariancePattern：    for at least  <strong>c</strong>  time unit(s)</p><h5 id="rules："><a href="#rules：" class="headerlink" title="rules："></a>rules：</h5><ul><li><p>literal terminals are delimited by quotation marks <code></code> </p></li><li><p>non-literal terminals are given in a <strong>san serif</strong> font</p></li><li><p>non-terminals are given in <em>italics</em></p></li><li><p><strong>property</strong> is the start symbol</p></li><li><p>the language L(G) is finite （since the grammar is non-circular and has no repetition）</p></li><li><p>Each sentence (or string) s with s $\in$ L(G) serves as a handle that accompanies a scoped formula of a qualitative or real-time specification pattern.</p></li></ul><p>注：literal terminal 指的是用引号括起来的输出结果，如<code>Globally, it is always the case that if P holds, then S holds after at most c time unit(s).</code></p><p>注：non-literal terminal 指 用the grammar 初步导出的literal terminal ：<code>Globally, it is always the case that if P holds, then S holds after at most c time unit(s).</code>中的<strong>P</strong>、<strong>c</strong>和<strong>S</strong>等未被实例化的”形参”，<strong>P</strong>和<strong>S</strong> 是 Boolean propositional formulae，它们都是需要被实例化的(need to be instantiated)</p><p>注：instantiate 实例化是指用具体的Boolean propositional formula对形参进行代换。如replacing P with (x = 0)。</p><h5 id="supported-specifications："><a href="#supported-specifications：" class="headerlink" title="supported specifications："></a>supported specifications：</h5><ul><li><p>TLT，CTL，CIL —— Dwyer’s specification patterns</p></li><li><p>MTL，TCTL，RTGIL —— our real-time specification patterns</p></li></ul><h5 id="The-process-to-create-a-natural-language-representation："><a href="#The-process-to-create-a-natural-language-representation：" class="headerlink" title="The process to create a natural language representation："></a>The process to create a natural language representation：</h5><ul><li><p>Initially, choose the scope of the specified property($globally / before / after / between / after$-$until$), followed by the type($qualitative / real$-$time$)</p></li><li><p>Then, select the category of the specified property($duration$, $periodic$, or $real$-$time$ $order$ for real-time properties, and $occurrence$ or $order$ for qualitative properties)</p></li><li><p>Finally, construct structed English sentence by choosing the corresponding specification pattern.</p><p>​    ——“precede” denote strict past</p><p>​    ——“succeed” denote strict  future</p><p>​    ——“held previously” denote non-strict past</p><p>​    ——“hold eventually” denote non-strict future</p></li></ul><h4 id="3-3-Pattern-Template"><a href="#3-3-Pattern-Template" class="headerlink" title="3.3 Pattern Template"></a>3.3 Pattern Template</h4><p>Our real-time specification pattern template contains the following <strong>fields</strong>：</p><ul><li><p><strong>Pattern Name ：</strong>serves as a handle for the pattern’s use and describes the nature of the pattern. </p></li><li><p><strong>Classification：</strong>denotes if the pattern belongs to the duration, periodic, or real-time order category</p></li><li><p><strong>Structured English Specification：</strong>The structured English sentence captures the property. The sentence is given in its unscoped version; a scope will be added as a prex to the sentence when the pattern is instantiated.</p></li><li><p><strong>Pattern Intent：</strong>A short description of properties for which the pattern is applicable.</p></li><li><p><strong>Real-time Temporal Logic Mappings：</strong>Contains mappings of the pattern to MTL, TCTL, and RTGIL for each of the 5 possible scopes.</p></li><li><p><strong>Examples and Known Uses：</strong>Gives example instantiations of the pattern and describes common situations where the pattern is useful in real-world scenarios.</p></li><li><p><strong>Relationships：</strong>Describes relations to other qualitative as well as real-time specification patterns. Additionally, this field contains information about other commonly used properties and techniques that are related to this pattern.</p></li></ul><p>[Figure 4] 是一个例子——$Bounded$ $Recurrence$ $Real$-$time$ $Specification$ $Pattern$</p><hr><h3 id="4-Case-Study"><a href="#4-Case-Study" class="headerlink" title="4. Case Study"></a>4. Case Study</h3><p>以 electronically controlled steering (ECS) system 为例，使用 object analysis patterns创建一个UML模型（UML：Unified Modeling Language ，统一建模语言）</p><p>Object analysis patterns contain structural and behavioral information to guide the creation of UML models of the system.</p><p>本例涉及到了时间粒度(time granularity)的概念，有fine-grained(细粒度)和coarse-grained(粗粒度)两种</p><p>We construct two distinct (UML) system models with different timing granularities (fine-grained and coarse-grained), thus offering different views of the system. (Modeling all timed behaviors at one level of timing granularity would require large clock values and make it difficult to understand the analysis results.)</p><p>以其中一个requirement为例：</p><p>​    <strong>Requirement 1(c): Operational checks must be done every 10 milliseconds.</strong></p><p>​    1、This requirement describes a periodic occurrence，and it denotes …(字面意思)</p><p>​    2、assume that an operational check happening more often than every 10 milliseconds is considered correct system behavior.</p><p>​    3、Hence，use the $Bounded$ $Recurrence$ $Pattern$</p><p>​    4、Because one time unit corresponds to 0.5 milliseconds in the fine-grained<br>model, 10 milliseconds are captured as 20 time units.(MTL 的$Eventually​$ 亦即是$\lozenge​$，下标单位为time units。在这个例子中，1 time unit == 0.5ms，所以10ms == 20 time units，故在MTL formula中用20 time units 表达10ms)</p><p>​    5、用MTL formula 表达出来： $\square (\lozenge _{\leq20}$$ (in(OperationalCheck)))$</p><p>​    6、生成structured English grammar：</p><p>​            <strong>“Globally, it is always the case that</strong> (in(OperationalCheck)) <strong>holds at least every 20 time unit(s).”</strong> (Grammar: 1, 2, 3, 18, 22, 23)</p><p>概括一下步骤：</p><p>​    analyze the scope&amp;category of the specified property，根据结果choose the corresponding specification patterns，对每一个pattern分别用temporal logic formula 表达成formula，再用3.2中的grammar表达这个formula（具体过程在3.2）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：&lt;/p&gt;
&lt;p&gt;​    1、基于对 一些工业上的嵌入式系统应用的基于时间的需求， 用三种常用的时序逻辑创造了实时规范模式。&lt;/p&gt;
&lt;p&gt;​    2、为了进一步加强对于一个规范的理解，给出了支持实时属性的结构化英语语法。&lt;/p&gt;
    
    </summary>
    
      <category term="pattern" scheme="http://KunKin.github.io/categories/pattern/"/>
    
    
      <category term="pattern" scheme="http://KunKin.github.io/tags/pattern/"/>
    
  </entry>
  
  <entry>
    <title>non-Zeno And Accepting Location</title>
    <link href="http://KunKin.github.io/2018/12/29/non-ZenoAndAcceptingLocation/"/>
    <id>http://KunKin.github.io/2018/12/29/non-ZenoAndAcceptingLocation/</id>
    <published>2018-12-29T03:47:38.000Z</published>
    <updated>2018-12-29T07:21:41.018Z</updated>
    
    <content type="html"><![CDATA[<p><strong>accepting</strong>：if infinitely often the same state</p><p><strong>non-Zeno</strong>：if time diverges，which means $\sum_{i\geq20}$$\delta_{i}$ $\rightarrow \infin$</p><a id="more"></a><p><strong>Abstract zone graphs again</strong>：</p><p>​                    Extra$^{+}_{LU}$     </p><p>​            $\nearrow$            $\nwarrow$  </p><p>​        Extra$^{+}_{M}$            Extra$_{LU}$</p><p>​               $\nwarrow$                   $\nearrow$</p><p>​                        Extra$_{M}$</p><p> ZG^a^$( \mathcal{A} )$ ：($q_0$$,$ $Z_0$)$\rightarrow$($q_1$$,$ $Z_1$)$\rightarrow$ ($q_2$$,$ $Z_2$)$\rightarrow$$\cdots$</p><p>​        $\mathcal{A}$：($q_0$$,$ $v_0$)$\rightarrow$ ($q_1$$,$ $v_1$)$\rightarrow$  ($q_2$$,$ $v_2$)$\rightarrow$$\cdots$</p><p>（All the above abstractions preserve repeated state reachability）</p><p>其中$\mathcal{A}$中的每一个状态都是ZG^a^$( \mathcal{A} )$ 中相应状态的元素，即   $\forall i\geq0$ 有$v_i$ $\in$ $Z_i$</p><p><strong>Time progress criterion</strong>： $\bigwedge_{x \in X}$unbounded$(x)$$\vee$fluctuating$(x)$</p><p><strong>non-Zenoness</strong>： the time progress criterion is not sound on zones</p><p>note: Adding one clock leads to an exponential blowup in the zone graph!</p><p>​     exponential blowup：指数爆炸</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;accepting&lt;/strong&gt;：if infinitely often the same state&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;non-Zeno&lt;/strong&gt;：if time diverges，which means $\sum_{i\geq20}$$\delta_{i}$ $\rightarrow \infin$&lt;/p&gt;
    
    </summary>
    
      <category term="pattern" scheme="http://KunKin.github.io/categories/pattern/"/>
    
    
      <category term="pattern" scheme="http://KunKin.github.io/tags/pattern/"/>
    
  </entry>
  
  <entry>
    <title>Patterns for Timed Property Specifications</title>
    <link href="http://KunKin.github.io/2018/12/29/Patterns%20for%20Timed%20Property%20Specifications/"/>
    <id>http://KunKin.github.io/2018/12/29/Patterns for Timed Property Specifications/</id>
    <published>2018-12-29T03:47:36.000Z</published>
    <updated>2018-12-29T07:18:54.561Z</updated>
    
    <content type="html"><![CDATA[<p>翻译约定：</p><p>formalism 形式标准</p><p>signalise 信号化通知</p><p>timed 时控的，定时的，限时的</p><p>untimed 不限时的</p><hr><a id="more"></a><p>###Abstract</p><p>属性规范模式使非专业人员可以编写可用于自动检查模型的正式规范。现有模式可以推断事件的发生和顺序，但不能说明它们的时间。 我们通过与时间相关的模式来扩展这种模式系统。 这使得我们能够指定实时要求。 </p><hr><h3 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h3><p>实时需求的形式规范是一个容易出错的任务。开发人员认为它难学，但是依赖于 在时态逻辑公式中给出的规范 的模型检查(model checking)在验证系统正确性上又确实很好用。</p><p>目前属性规范模式已经成功应用于弥补从业者与模型检查工具之间的距离。只是现有的模式系统没有考虑到关于时间的信息。</p><p>对于每个模式，我们构造观察者自动机（称为观察者, 即observers），可以直接应用于定时模型检查工具。这些观察者可以自动构建，模式系统的用户无需亲自动手。这对目前的方法来说是一个利好，因为目前的方法通常来说允许从UML这样的高级语言自动构建模型检查器的输入语言的模型，但不提供工具支持来规范 那些必须经过验证的 需求。</p><hr><h3 id="2、Untimed-Specification-Patterns-不限时的规范模式"><a href="#2、Untimed-Specification-Patterns-不限时的规范模式" class="headerlink" title="2、Untimed Specification Patterns(不限时的规范模式)"></a>2、Untimed Specification Patterns(不限时的规范模式)</h3><p>Dwyer的《Patterns in property specifications for finite-state verification》中为属性规范开发了一个模式系统。这个模式系统使得不了解时间逻辑的人也能够读写许多不同形式标准的形式规范。这个系统能表达出诸如“一个事件A的发生必须跟随着事件B的发生”。但是这个系统有一些不足之处，它不包含时控属性(timed property)，比如“发生事件A后必须在k个时间单位发生事件B”。</p><p>模式的等级制度(hierarchy):</p><p>​    <strong>Absence</strong></p><p>​    <strong>Universality</strong></p><p>​    <strong>Existence</strong></p><p>​    <strong>Bounded Existence</strong></p><p>​    <strong>Precedence</strong></p><p>​     <strong>Chain Precedence/Chain Response</strong></p><p>以及范围(scope)：</p><p>​    <strong>global</strong></p><p>​    <strong>before</strong></p><p>​    <strong>after</strong></p><p>​    <strong>between</strong></p><p>​    <strong>until</strong></p><p>以及模式系统的元素：</p><p>​    <strong>events</strong></p><p>​    <strong>patterns</strong></p><p>​    <strong>scopes</strong></p><p>这些都在Dwyer的《Patterns in property specifications for finite-state verification》中有详细说明，在此就不赘述了。</p><hr><h3 id="3、Timed-Observer-Automata（限时观察者自动机）"><a href="#3、Timed-Observer-Automata（限时观察者自动机）" class="headerlink" title="3、Timed Observer Automata（限时观察者自动机）"></a>3、Timed Observer Automata（限时观察者自动机）</h3><p>Dwyer的工作最重要的成果是模式目录(pattern catalogue)。这个目录给出了属性规范到不同形式标准(formalisms)的映射。比如“Globally, S responds P”， 在CTL中可以表达成 AG(P =&gt; AF(S))，在LTL中表达成□(P =&gt; ◇S)。因为很多模型检查工具允许检查按着这些形式标准规范的属性，所以模式目录可以被这些工具直接使用。</p><p>所以类似地，我们可以用限时时间逻辑去为限时属性规范建立一个相似的目录。比如可以用TCTL，将属于time-bounded response 属性的“Globally, S responds to P within k time units”， 表达成 AG(P =&gt; AF&lt;k(S))，(其中“&lt;k”是下标)</p><p>虽然这样的目录在理论上可能是有趣的，但它实际使用起来将会有许多限制，因为限时模型检查工具不提供对限时时间逻辑的支持，因为无限时模型检查工具使用无限时时间逻辑进行处理。</p><p>因此，我们使用（有关时间的）观察者自动机（观察者）去描述所需的系统行为。直观地说，在验证时，观察者与模型并行。当且仅当一些属性在模型中可能被违反，他们才到达一个确定的状态。</p><p>时间自动机（Timed automata, TA）。之后会简洁介绍TA。我们还使用 使用了同步标签的不同TA 之间紧急和沟通作为TA原始定义的扩展。</p><p>作为一个有限 Buchi(u实际上是u上加两点，即v的拼音式) 自动机，一个TA有一组有限的位置(locations) L和一组T⊆ L×L转换(transitions)。一个位置l0 ∈ L (l是L小写，0是下标)是一个显著的初始位置。这个转换被一个函数标签标记了：L → 2AP（AP是上标），这个函数标签为每个位置(location)分配了一组原子命题。与此同时，有一个有限的关于时钟的集 C 以相同的速度运行着。转换可以与C的子集相关联，这意味着在进行转换时必须重置为零的时钟。</p><p>时钟状态的形式为x〜y，其中〜表示来自一个集合{&lt;, &gt;, =, ≤, ≥}的操作符, x∈C, y∈C或者y是一个自然数。时钟状态可以与一个转换相关联，转换可能只有在时钟条件为真时才能进行。</p><p>TA可以像接下来这么运行：</p><ul><li>一开始，自动机在初始位置，所有的时钟被设置为0。</li><li>然后，TA可以在两种方式上进行：可以通过转换来改变位置，或者可以在停留在相同位置的同时改变时间。</li><li>再之后，将会有多于一种可能的方式来运行：可能位置不变并让时间继续或采取该位置可用的转换之一。这种选择是非确定性的，但是，如果转换被标记为紧急，则这种非确定性会受到限制。如果可以，紧急转换<em>必须</em>立刻被执行。而如果有多个紧急转换，那么将会随机挑选一个。如果能够执行一个紧急转换，那么就不会执行一个非紧急转换。</li></ul><p>为了给不同TA之间建立交流和同步模型，可以用同步标签<code>X!</code>（发出事件X的信号）和<code>X</code>（事件X的相应反应）去给转换(transition)做标记。如果TA中一个被<code>X!</code>标记了的转换被执行了，那么这意味着在其他自动机中<em>所有</em>被<code>X</code>标记了的转换（这是不被时钟状态或者其他转换的紧急性所禁止的）可以立即执行，而无需考虑任何推迟。一个带着 被<code>X</code>标记的转换 的自动机是处于阻塞(blocked)的，一直到一个被<code>X!</code>标记的相应转换被执行为止。</p><p>在另一方面，一个被<code>X!</code>标记的转换是不会被阻塞的，因为没有被<code>X</code>标记的转换可以被执行。（关于这句话，我觉得是不是这个意思：没有被<code>X</code>标记的转换可以被执行时，被<code>X!</code>标记的转换是不会被阻塞的）转换可以拥有最多一个<code>X</code>形式的同步标签，以及最多一个<code>X!</code>形式的同步标签。（在我们基于事件的形式标准中，我们不允许两个事件重合）</p><p>同步标签对于 验证模型 与 观察者“查询”系统的行为 的同步非常重要：如果模型中发生了一些“有趣”的事，观察者能即使反应。</p><hr><h3 id="4、Pattern-Catalogue：Pattern（模式目录：模式）"><a href="#4、Pattern-Catalogue：Pattern（模式目录：模式）" class="headerlink" title="4、Pattern Catalogue：Pattern（模式目录：模式）"></a>4、Pattern Catalogue：Pattern（模式目录：模式）</h3><p>本节将会看到，我们的大多数规范模式如何处理所谓的安全属性。为了证明这个属性是True，有必要去检查观察者是否到达不了某些location。当观察者到达这些location的时候，它能侦测到对于规范的违反。</p><p>对于liveness properties（比如，”每一个P的发生都伴随着Q的发生”），考虑infinite runs是必要的。</p><p>一般来说，我们为了这样的目标而使用acceptance状态：观察者中的一些location被标记成accepting location（接受位置）。如果一个 non-Zeno的运行经常无限地进入一个接受位置，那么观察者能侦测到一个反例(counterexample)。（在这里我们忽略了non-Zenoness 的形式定义。直观来说，non-Zeno run是一个 在有限次数内，被禁止无限执行许多转换 的状态）</p><p>依照惯例，我们用圆圈来描述自动机的位置，用箭头来表示转换。我们将error location定义为：当到达error locations的时候，观察者能侦测到规范被违反。同时我们在相应的圆圈下用<code>ERROR</code>来标记error locations。Accepting location用两个同心圆(a double circle)表示。我们定义显示TA图中最左边的位置总是初始位置。我们称呼那些既不是error 也不是 accepting的locations 为 normal locations。</p><p><strong>Absence</strong>：P在一个范围内没有发生</p><p><strong>Existence</strong>：P在一个范围内必须有发生</p><p><strong>Bounded Existence</strong>：给定的状态/事件在一个范围内必须发生k次。该模式的变体至少指定k次出现，并且至多指定k次出现的状态/事件。</p><p><strong>Universality</strong>：给定的状态/事件发生在整个范围内(occurs throughout a scope)，相当于“P 变成 False”这个事件是Absence状态</p><p><strong>Precedence</strong>：在一个范围内，P必须总是被Q优先。除非Q进程被“enabled”，否则P不能发生。</p><p><strong>Precedence: Q enables P after a delay</strong>：当且仅当Q发生了并且时间&gt;=t(Q)+k，P才是可用的。（当一个P可用后，即使另一个Q发生了，P仍然是可用的）。</p><p><strong>Precedence: Q enables P for k time units</strong>：当且仅当Q发生了并且时间&lt;=t(Q)+k，P才是可用的。</p><p><strong>Response</strong>：在一个范围内，状态/事件P必须总是被状态/事件Q跟随（或者说，状态/事件P发生之后才能发生状态/事件Q）</p><p><strong>Time-Bounded Response: response must occur before t(P)+k</strong>：P必须被Q跟随，但是Q必须在给定的时间区间内发生。</p><p><strong>Chain Precedence</strong>：状态/事件队列P1,P2,…,Pn 必须总是被(be preceded by)状态/事件队列Q1,Q2,…,Qn 优先。这个模式是<strong>Precedence</strong>模式的概括(generalization)。</p><p><strong>Chain Response</strong>：状态/事件队列P1,P2,…,Pn 发生之后才能发生 (be followedby)状态/事件队列Q1,Q2,…,Qn。这个模式是<strong>Response</strong>模式的概括(generalization)。它可以用来表达有界的FIFO关系</p><p>关于Absence、University，Existence，Response，Timed-Bounded Response：response must occur before t(P)+k，Precedence，Precedence： Q enables P after a delay，Precedence： Q enables P for k time units，Bounded Existence，Chain Precedence 以及 Chain Response的图像表示参照文献原文。</p><hr><h3 id="5、Pattern-Catalogue-Event（模式目录：事件）"><a href="#5、Pattern-Catalogue-Event（模式目录：事件）" class="headerlink" title="5、Pattern Catalogue: Event（模式目录：事件）"></a>5、Pattern Catalogue: Event（模式目录：事件）</h3><p>使用同步标签，TA可以“观察”另一TA中事件的发生，并且如果事件发生并且可以发生同步，则以某种方式作出回应。</p><p>但是，我们通常要对与多个事件相关的“观测”或其发生的时间作出反应。我们用到一个术语叫做“关联事件”(combined events)。</p><p>reporting TA 被用来处理（handle）这些关联事件。当且仅当关联事件发生时， reporting TA 会作出一定的转换（过渡，transition）。这些转换可以被一个新的同步标记<code>M!</code>所标记。这样子的话，reporting TA 可以像信号化“普通”事件(“simple” events)一样信号化关联事件。</p><p>有两种reporting TA：</p><ul><li><p>一种是每次关联事件发生时，reporting TA总是汇报。</p></li><li><p>另一种R-TA也会汇报关联事件的发生，但不会每次都汇报。这种R-TA称为 <em>lazy</em>；</p></li></ul><p>以<code>Chain Response</code>模式“一个关于A和B事件的序列 必须总是在 一个关于C和D事件的序列 之前发生” 为例， 假设一个reporting TA  signalise A-B序列的出现(occurance)， 另一个R-TA singalise C-D序列的出现 。当我们用一个模型检查器（model checker）检查这个属性时，系统是否有一钟可能的运行方式违反了这个规范？如果有这么个反例的话，它是能够被模型检查器检查出来的——即使汇报A-B序列的TA是lazy的，因为lazy reporting TA也是能 signalise A-B序列的出现的。在另一方面，signalise C-D序列的出现的R-TA一定不能是lazy的，因为这样做会在A-B发生的地方导致一个错误的反例，随后C-D不会被lazy reporting TA 汇报。</p><p>lazy R-TA 的使用可以减少 TA中位置(location)和转换(transition)的数量。除非被明确地表示为lazy的，否则就默认R-TA是 non-lazy 的。</p><p><strong>Chains：</strong></p><p>​    chain 是指一个时间序列E1…En，这样一个序列是作为关联序列发生的，它是“不重叠”(non-overlapping)的（注：不能并行）， i.e. 只要一个已经开始的chain还没有完成，另一个新的chain就不能开始。</p><p>​    论文此处为 一个有着A、B、C三个事件的chain 给出了一个lazy R-TA。(将所有转换标记成<code>urgent</code>就能得到相应的 non-lazy TA）</p><p> <strong>Timed-Bounded Chains：</strong></p><p>​    timed-bounded chain 是指 事件序列E1…En 在一个给定的时间区间内（ ≤ k个时间单元）的发生。</p><p>​    论文此处给出了对于 一个有着A、B、C三个事件的chain 的lazy R-TA和 non-lazy R-TA ，其中non-lazy R-TA更加复杂。</p><p><strong>“n times A”：</strong></p><p>​    “A occurs n times”是chain的一个特例。每当A发生了n、2n、3n…次的时候， “A occurs n times”会被report。但是A发生了m次时(<code>i*n &lt; m &lt; (i+1)*n</code>)，”A occurs n times”不会被report。将<strong>Chains</strong>中的例子中的A、B、C用urgent action A 替代即可得到<strong>“n times A”</strong>的 reporting TA。</p><p><strong>“n times A within k time units”：</strong></p><p>​    “within k time units”其实就是“timed-bounded”, 按着字面意思理解就行，指在限定时间区间内A发生n次。</p><p>​    要注意时钟状态(clock condition)（比如 x&gt;k）需要在转换被执行前被检查，以及 “重置 时钟x”可以生效。</p><p><strong>Collections：</strong></p><p>​    上面四种模式的综合。例子看论文，例子中同步和异步的使用构成了一个整体的循环。</p><p><strong>Timed-Bounded Collections：</strong></p><p>​    Timed-Bounded上面有过说法了，略过。</p><p><strong>Non-occurrence in a given time span：</strong></p><p>​    如果从 基于事件的视图 切换到 基于状态的视图， 并令事件A表示“一个property变成了true”，事件B表示“一个property 变成了 false”。则“在一个k个时间单元的时间段里， A 不被 B跟随”这个规范意味着“该property保持true的状态至少k个时间单元”。</p><p>​    此处论文给出了一个lazy reporting TA的例子</p><p>​     当A发生时，一个non-lazy reporting TA将会需要去记住一个次数（它是潜在无限大的(potentially infinite)，即是有可能变成无限大的数），这使我们免于再构造一个R-TA。</p><hr><h3 id="Pattern-Catalogue-Scopes（模式目录：范围）"><a href="#Pattern-Catalogue-Scopes（模式目录：范围）" class="headerlink" title="Pattern Catalogue: Scopes（模式目录：范围）"></a>Pattern Catalogue: Scopes（模式目录：范围）</h3><p>​    令A是对某些属性(property)的观察者(observer)。A能观察属性是否是<em>globally</em>的， i.e.在模型的整个执行(entire execution)期间。这一章将展示：<em>在给定的范围内（over a given scope）</em>，A是怎么被按顺序改变以检查属性的。遵循Dwyer(上一篇论文的作者)给出的关于untimed scope的定义，这一章将展示A是如何可以被改变去检查一个属性早于、迟于以及直到 t(D)±k （k∈Z，表示时间单元数）时的有效性。</p><p>​    将 范围所定义的时间间隔 定义为左开右开（即是” (… , …) “），比如，“before t(D)”不包括时刻t(D)。 </p><p>​    D可以是一个关联事件。这使得原始的模式系统更加灵活。</p><p>​    处理 scopes 的关键idea在于把A的形式转变为一个 范围依赖(scope-dependent) 的TA——A’。为了在一个给定的范围内检查一个属性，我们可以在 A‘ 它自己中搜索错误运行（error run），也可以构造另一个命名为O的TA，其中O表现得像是一个对于A’的观察者，并且当且仅当 A‘ 中能找到一个错误运行时，O到达一个错误状态(error state)。模型的建立必须满足：reporting TAs 中的转换能够在 A’ 中执行 <code>before</code> 转换， A’ 中的转换能够在 O 中执行 <code>before</code> 转换。</p><p>​    这里引用了两个定义：</p><ul><li><p>如果一个系统的执行中没有出现范围分隔符 (scope delimiter)，那么根据定义，规范将是正确的。比如 <code>P must occur before X</code>，只要系统的整个执行过程中没有X，则这个规范将总是正确的。</p></li><li><p>在例如<code>Before R, S responds to P</code>的模式中（即 出现了范围分隔符），如果虽然P在Q前面发生，但是回应S发生在R之后，则这个规范被违背了。类似的，<code>After R, P must be preceeded by Q</code>, </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻译约定：&lt;/p&gt;
&lt;p&gt;formalism 形式标准&lt;/p&gt;
&lt;p&gt;signalise 信号化通知&lt;/p&gt;
&lt;p&gt;timed 时控的，定时的，限时的&lt;/p&gt;
&lt;p&gt;untimed 不限时的&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="pattern" scheme="http://KunKin.github.io/categories/pattern/"/>
    
    
      <category term="pattern" scheme="http://KunKin.github.io/tags/pattern/"/>
    
  </entry>
  
  <entry>
    <title>Patterns in property specifications for finite-state verification</title>
    <link href="http://KunKin.github.io/2018/12/29/Patterns%20in%20property%20specifications%20for%20finite-state%20verification/"/>
    <id>http://KunKin.github.io/2018/12/29/Patterns in property specifications for finite-state verification/</id>
    <published>2018-12-29T03:47:35.000Z</published>
    <updated>2018-12-29T07:19:08.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>premise: An LTL formula can be <em>satisfied</em> by an infinite sequence of truth evaluations of variables in <em>AP</em> .</p><a id="more"></a><p><em>w</em> = a0,a1,a2,… be such an ω-word</p><p><em>w</em>(i) = ai </p><p><em>w</em>i = ai,ai+1,…, which is a suffix of <em>w</em></p><p>the satisfaction relation <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> <strong>between a word and an LTL formula</strong> is <strong>defined</strong> as follows: </p><ul><li><em>w</em><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> p if p ∈ <em>w</em>(0)</li><li><em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> ¬ψ if <em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c6898dfb9341f7e25da15ec3118b5472cab83419" alt="\nvDash"> ψ</li><li><em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> φ ∨ ψ if <em>w</em><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> φ or <em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> ψ</li><li><em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> <strong>X</strong> ψ if <em>w</em>1 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> ψ (in the ne<strong>x</strong>t time step ψ must be true)</li><li><em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> φ <strong>U</strong> ψ if there exists i ≥ 0 such that <em>w</em>i <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> ψ and for all 0 ≤ k &lt; i, <em>w</em>k <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> φ (φ must remain true <strong>u</strong>ntil ψ becomes true)</li></ul><p>which can be displayed in another way：</p><p>​    </p><ul><li>​                                                             p ∈ <em>w</em>(0) <strong>→</strong> <em>w</em><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> p</li><li>​                                                              <em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c6898dfb9341f7e25da15ec3118b5472cab83419" alt="\nvDash"> ψ <strong>→</strong> <em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> ¬ψ</li><li>​                                         <em>w</em><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> φ ∨ <em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> ψ → <em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227 ad448b14ee1da16bb0235" alt="\vDash "> φ ∨ ψ </li><li>​                                                          <em>w</em>1 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> ψ  → <em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> <strong>X</strong> ψ    (in the ne<strong>x</strong>t time step ψ must be true)</li><li>∀ i ≥ 0 <strong>s.t.</strong> <em>w</em>i <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> ψ ∧ ∀0 ≤ k &lt; i, <em>w</em>k <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> φ  → <em>w</em> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5e3f06f0c9cc283227ad448b14ee1da16bb0235" alt="\vDash "> φ <strong>U</strong> ψ     (φ must remain true <strong>u</strong>ntil ψ becomes true)</li></ul><hr><h2 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h2><table><thead><tr><th>Textual</th><th>Symbolic</th><th>Explanation</th><th>Diagram</th></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/wiki/Unary_operation" target="_blank" rel="noopener">Unary operators</a>:</td><td></td><td></td><td></td></tr><tr><td><strong>X</strong> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "></td><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7a75ecbe0615649ff2de5050f18d0a4fe8aa59ea" alt="\bigcirc \phi "></td><td>ne<strong>X</strong>t: <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "> has to hold at the next state.</td><td><a href="https://en.wikipedia.org/wiki/File:Ltlnext.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/8/84/Ltlnext.png" alt="LTL next operator"></a></td></tr><tr><td><strong>F</strong> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "></td><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a66fbb65d563e99aa91360d0da21ee6637080ea9" alt="\Diamond \phi "></td><td><strong>F</strong>inally:  eventually has to hold (somewhere on the subsequent path).</td><td><a href="https://en.wikipedia.org/wiki/File:Ltlevently.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/d/d2/Ltlevently.png" alt="LTL eventually operator"></a></td></tr><tr><td><strong>G</strong> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "></td><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bac6d8e20bfba09462096d4f815c14b676e4b2f4" alt="\Box \phi "></td><td><strong>G</strong>lobally: <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "> has to hold on the entire subsequent path.</td><td><a href="https://en.wikipedia.org/wiki/File:Ltlalways.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/f/fb/Ltlalways.png" alt="LTL always operator"></a></td></tr><tr><td><a href="https://en.wikipedia.org/wiki/Binary_operator" target="_blank" rel="noopener">Binary operators</a>:</td><td></td><td></td><td></td></tr><tr><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> <strong>U</strong> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "></td><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2cdd358dee3181d67ccc770eaf4dd4b0f6feac95" alt="\psi \;{\mathcal  {U}}\,\phi "></td><td><strong>U</strong>ntil: <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> has to hold <em>at least</em> until <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "> becomes true, which must hold at the current or a future position.</td><td><a href="https://en.wikipedia.org/wiki/File:Ltluntil.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/9/9a/Ltluntil.png" alt="LTL until operator"></a></td></tr><tr><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> <strong>R</strong><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "></td><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a45433bbb15ac2310a8c1db3162c9253c1b4421b" alt="\psi \;{\mathcal  {R}}\,\phi "></td><td><strong>R</strong>elease: <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "> has to be true until and including the point where  first becomes true; if <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> never becomes true, <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "> must remain true forever.</td><td><a href="https://en.wikipedia.org/wiki/File:Ltlrelease1.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/5/59/Ltlrelease1.png" alt="LTL release operator (which stops)"></a> <a href="https://en.wikipedia.org/wiki/File:Ltlrelease2.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/8/8d/Ltlrelease2.png" alt="LTL release operator (which does not stop)"></a></td></tr><tr><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> <strong>W</strong><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "></td><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f09baeee3c464cd575a24567456e2dfd1bc4f755" alt="{\displaystyle \psi \;{\mathcal {W}}\,\phi }"></td><td><strong>W</strong>eak until: <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> has to hold <em>at least</em> until <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi ">; if  never becomes true, <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> must remain true forever.</td><td><a href="https://en.wikipedia.org/wiki/File:Ltluntil.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/9/9a/Ltluntil.png" alt="LTL weak until operator (which stops)"></a> <a href="https://en.wikipedia.org/wiki/File:Ltlweakuntil2.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/e/ec/Ltlweakuntil2.png" alt="LTL weak until operator (which does not stop)"></a></td></tr><tr><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> <strong>M</strong> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4" alt="\phi "></td><td><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bb9d5b96bc3ce4e84acb26908b7040205fbb362d" alt="{\displaystyle \psi \;{\mathcal {M}}\,\phi }"></td><td>Strong release:  has to be true until and including the point where <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a" alt="\psi "> first becomes true, which must hold at the current or a future position.</td><td><a href="https://en.wikipedia.org/wiki/File:Ltlrelease1.png" target="_blank" rel="noopener"><img src="https://upload.wikimedia.org/wikipedia/commons/5/59/Ltlrelease1.png" alt="LTL strong release operator"></a></td></tr></tbody></table><hr><h2 id="Some-Equivalences"><a href="#Some-Equivalences" class="headerlink" title="Some Equivalences"></a>Some Equivalences</h2><table><thead><tr><th>Distributivity</th><th></th><th></th></tr></thead><tbody><tr><td><strong>X</strong> (Φ ∨ ψ) ≡ (<strong>X</strong> Φ) ∨ (<strong>X</strong> ψ)</td><td><strong>X</strong> (Φ ∧ ψ)≡ (<strong>X</strong> Φ) ∧ (<strong>X</strong> ψ)</td><td><strong>X</strong> (Φ <strong>U</strong> ψ)≡ (<strong>X</strong> Φ) <strong>U</strong> (<strong>X</strong> ψ)</td></tr><tr><td><strong>F</strong> (Φ ∨ ψ) ≡ (<strong>F</strong> Φ) ∨ (<strong>F</strong> ψ)</td><td><strong>G</strong> (Φ ∧ ψ)≡ (<strong>G</strong> Φ) ∧ (<strong>G</strong> ψ)</td><td></td></tr><tr><td>ρ <strong>U</strong> (Φ ∨ ψ) ≡ (ρ <strong>U</strong> Φ) ∨ (ρ <strong>U</strong> ψ)</td><td>(Φ ∧ ψ) <strong>U</strong> ρ ≡ (Φ <strong>U</strong> ρ) ∧ (ψ <strong>U</strong> ρ)</td></tr></tbody></table><table><thead><tr><th>Negation propagation</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><strong>*X</strong> is self-dual*</td><td><strong>*F</strong> and <strong>G</strong> are dual*</td><td><strong>*U</strong> and <strong>R</strong> are dual*</td><td><strong>*W</strong> and <strong>M</strong> are dual*</td></tr><tr><td>¬<strong>X</strong> Φ ≡ <strong>X</strong> ¬Φ</td><td>¬<strong>F</strong> Φ ≡ <strong>G</strong> ¬Φ</td><td>¬ (Φ <strong>U</strong> ψ) ≡ (¬Φ <strong>R</strong> ¬ψ)</td><td>¬ (Φ <strong>W</strong> ψ) ≡ (¬Φ <strong>M</strong> ¬ψ)</td></tr><tr><td></td><td>¬<strong>G</strong> Φ ≡ <strong>F</strong> ¬Φ</td><td>¬ (Φ <strong>R</strong> ψ) ≡ (¬Φ <strong>U</strong> ¬ψ)</td><td>¬ (Φ <strong>M</strong> ψ) ≡ (¬Φ <strong>W</strong> ¬ψ)</td></tr></tbody></table><table><thead><tr><th>Special Temporal properties</th><th></th><th></th></tr></thead><tbody><tr><td><strong>F</strong> Φ ≡ <strong>F</strong> <strong>F</strong> Φ</td><td><strong>G</strong> Φ ≡ <strong>G</strong> <strong>G</strong> Φ</td><td>Φ <strong>U</strong> ψ ≡ Φ <strong>U</strong> (Φ <strong>U</strong> ψ)</td></tr><tr><td>Φ <strong>U</strong> ψ ≡ ψ ∨ ( Φ ∧ <strong>X</strong>(Φ <strong>U</strong> ψ) )</td><td>Φ <strong>W</strong> ψ ≡ ψ ∨ ( Φ ∧ <strong>X</strong>(Φ <strong>W</strong> ψ) )</td><td>Φ <strong>R</strong> ψ ≡ ψ ∧ (Φ ∨ <strong>X</strong>(Φ <strong>R</strong> ψ) )</td></tr><tr><td><strong>G</strong> Φ ≡ Φ ∧ <strong>X</strong>(<strong>G</strong> Φ)</td><td><strong>F</strong> Φ ≡ Φ ∨ <strong>X</strong>(<strong>F</strong> Φ)</td></tr></tbody></table><hr><p>###介绍</p><p>工具支持（tool support）包括：model checking， bisimualtion，language containment， flow analysis， inequality necessary condition</p><p>模型的意义：</p><p>Patterns are successful because practitioners want to solve naturally occurring domain problems.<br>They don’t need the full expressiveness of the languages they use and would often prefer guidance on how best to use language features to solve commonly occuring problems.</p><p>简单来说就是模式能把上面的LTL式封装好，使得使用人员不必耗费精力去学习LTL。</p><hr><p>文章结构：</p><p>Section 2：描述有限状态检验的规范模式系统</p><p>Section 3：介绍调查结果</p><p>Section 4：比对我们的方法与相关工作</p><p>Section 5：总结</p><hr><p>###规范模式系统<em>（本文重点）</em></p><p>结构：背景知识、想法是如何被应用于属性规范的有限状态检验领域、这些pattern集合是如何被组织的以及对模式系统的近况概览</p><p>####属性规范模式</p><p>作为利用专业系统设计师经验的手段，引入了设计模式。 模式旨在不仅捕获对软件设计问题的重复解决方案的描述，而且还捕获解决方案所要求的要求，满足要求的方法以及解决方案的示例。 所有这些信息都应以实践者可以理解的形式进行描述，以便他们能够识别系统中的类似需求，选择满足这些需求的模式，并实例化体现这些模式的解决方案。</p><p> 对于有限状态检验，系统被建模为具有有限数量的状态的过渡系统以及在这些状态之间可能标记有事件的一组过渡。 属性规范模式是对系统的这种有限状态模型中的容许状态/事件序列的通常发生的要求的一般化描述。 属性规范模式描述了系统行为的某些方面的基本结构，并在一系列常见形式中提供了这种行为的表达。</p><p>一个模型包含了一个名称或多个名称，一个对于模型意图的精确声明，对于共同规范形式的映射，关于例子用途的例子，以及与其他模型的联系。</p><p>一些规范形式是基于事件的，而其他的规范形式是基于状态的。</p><p>在我们的模型里，大写字母（<em>P，Q，R，S</em>）代表事件 或者 在基于事件的形式中的事件分离， 还代表在基于状态的规范里的状态公式。</p><p>每一个模型有一个作用范围(scope)，这个作用范围是模式必须执行的执行程序的范围。</p><p>scope有五种：global, before, after, between, after-until。</p><p>scope通过指定 模式(pattern)的状态(state)/事件(event) 来确定。</p><p>在状态间隔范围，这个间隔是左闭右开的。因此范围包括了所有这些状态：从开始状态(starting state)开始(begin)并且持续(up to)，但是不包括结束状态（ending state）。</p><p>不同的形式规范有不同的语义和表现力。一个可以很容易地在一种形式里表达出来的属性，可能不能很自然地、甚至不可能在另一种形式里很精确地描述。</p><p>####规范模式系统</p><p>我们为有限状态检验工具开发了一个关于属性规范的模式系统。模式系统是组织成一个或多个层次结构的一组模式，在相关模式之间建立连接以便于浏览。</p><p>在定义规范形式时，人们试图给出一小组独立的概念，从这一小组独立的概念中可以构建一大类规范。但是对于规范模式的集合而言，我们既不想给出可以生成有用规范的最小集合，也不会提供完整的规范列表。模式仅作为属性规范出现在系统中。</p><p>#####模式</p><p>对于模式的具体说明可以在<a href="http://patterns.projects.cs.ksu.edu/" target="_blank" rel="noopener">这里</a>看到。下面给出一些简短说明：（在描述中，为了简洁起见，我们使用短语“给定的状态/事件发生”来表示“给定的状态公式是true的状态/来自给定的 事件分离(disjunction of events) 的事件发生”。）</p><p><strong>Absence</strong>：给定的状态/事件在一个范围内没有发生</p><p><strong>Existence</strong>：给定的状态/事件在一个范围内有发生</p><p><strong>Bounded Existence</strong>：给定的状态/事件在一个范围内必须发生k次。该模式的变体至少指定k次出现，并且至多指定k次出现的状态/事件。</p><p><strong>Universality</strong>：给定的状态/事件发生在整个范围内(occurs throughout a scope)</p><p><strong>Precedence</strong>：在一个范围内，状态/事件P必须总是在状态/事件Q之前（或者说，状态/事件P必须总是优先于状态/事件Q）</p><p><strong>Response</strong>：在一个范围内，状态/事件P必须总是被状态/事件Q跟随（或者说，状态/事件P发生之后才能发生状态/事件Q）</p><p><strong>Chain Precedence</strong>：状态/事件队列P1,P2,…,Pn 必须总是优先于(be preceded by)状态/事件队列Q1,Q2,…,Qn。这个模式是<strong>Precedence</strong>模式的概括(generalization)。</p><p><strong>Chain Response</strong>：状态/事件队列P1,P2,…,Pn 发生之后才能发生 (be followedby)状态/事件队列Q1,Q2,…,Qn。这个模式是<strong>Response</strong>模式的概括(generalization)。它可以用来表达有界的FIFO关系</p><h5 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h5><p>组织模式最有效的方法是一个基于这些模式语义的等级制度。</p><p>比如说，有些模式要求状态/事件发生或者不发生（比如Absence模式），而另外的模式则约束了状态/事件的顺序（比如Response模式）</p><p>我们提供了一个关于模式注释的集合，解释了如何组合and/or 去改变模式。比如说，模式模板通常由单个事件或状态公式来参数化。但是在一些情况下，我们允许状态/事件模式被替换进模板中。</p><p>属性模式：occurrence，order</p><p>occurrence：<strong>Absence</strong>，<strong>Existence</strong>，<strong>Bounded Existence</strong>，<strong>Universality</strong></p><p>order：<strong>Precedence</strong>，<strong>Response</strong>，<strong>Chain Precedence</strong>，<strong>Chain Response</strong></p><hr><h3 id="属性规范的调查"><a href="#属性规范的调查" class="headerlink" title="属性规范的调查"></a>属性规范的调查</h3><p>####数据收集</p><p>我们收集了500份specification样例，发现大部分都属于少数相似的类别。</p><p>样例来源：</p><ul><li><p>文献中的检验文件</p></li><li><p>别的写了或者收集了规范的文件</p></li><li><p>学生做的项目：来自第一作者的毕业生的有限状态验证课程。</p></li></ul><p>总共从至少35个不同的来源收集了555个规范（specification）。大多数规范，我们都用一种特定的规范模式建立了一个对于需求的表达式。而对于其中许多规范，我们还有一个关于需求的非正式描述。这些规范来自各种各样的应用领域：硬件协议， 通信协议， GUI，控制系统， 抽象数据类型，航空电子设备，操作系统， 分散式对象系统， 以及数据库。这些规范的完整描述可以在<a href="http://patterns.projects.cs.ksu.edu/" target="_blank" rel="noopener">规范模式</a>看到。</p><p>在大多数情况下，正常的规范版本是一个 映射了规范模式/范围的 模板的一个实例(an instantiation of a template mapping for a specific pattern/scope)；而这些规范是哪个领域的并不重要。</p><p>如果找不到哪怕是微小的匹配，我们会更仔细地查看规范，并在以下情况仍视为匹配：</p><ul><li><p>该规范与我们的模板映射之一的实例化在形式上(formally)等价。比如LTL形式的¬◇P等价于□¬P，这是我们对于P的(全局)absence的映射</p></li><li><p>该规范可以从我们的一个模式中使用参数替换获得。对于一些模式/范围而言，将时态公式替换为模板是安全的（何时可以这样操作的指导见于模式注释(pattern note)）。</p></li><li><p>该规范是我们的一个模式的已知变体。比如左闭右开与左开右闭。</p></li><li><p>该规范是我们的一个模式的一种新变体。</p></li><li><p>该规范的形式表达式完全错误，并且正确的规范是我们的一个模式的一个实例</p></li></ul><p>对于每个规范，我们记录了这些信息（如果有的话）：</p><ul><li><strong>需求(requirement)</strong>：一个对于需求的零散(prose)描述。</li><li><strong>模式(pattern)</strong>：我们用于确定这个需求 的模式是一个实例（如果有的话）。</li><li><strong>范围(scope)</strong>：模式的范围。</li><li><strong>参数(parameters)</strong>：提供给模板的参数注释。（比如，命题阵列arrays of propositions，嵌套时间公式nested temporal formulae）</li><li><strong>映射(mapping)</strong>：属性到形式规范语言(LTL, CTL, QREs, GIL, INCA)的映射。大部分样例只有一种映射。</li><li><strong>来源(source)</strong>：样例来源（ 人，引用…）</li><li><strong>领域(domain)</strong>：样例来源的应用领域</li><li><strong>注释(note)</strong>：样例中任何的额外信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一个例子：</span><br><span class="line">REQUIREXNT: When a server requests its registration in the ROT, it will eventually be registered.</span><br><span class="line">PATTERN: Response</span><br><span class="line">SCOPE: Global</span><br><span class="line">PARAMIZTERS:Propositions (boolean vector)</span><br><span class="line">LTL: [](RequestedRegisterImpl[i] -&gt; &lt;&gt;ServerRegistered[i])</span><br><span class="line">NOTE: this is replicated for all modeled servers</span><br><span class="line">SOURCE: Gregory Duval \cite&#123;duval:98&#125;, RI, pp. 46</span><br><span class="line">DOMAIN: Distributed Object System</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>从结果上看，模式出现的频率在排序后下降得很快，这就引出了一个关于size的问题：模式系统里应该有多少模式？系统中的模式越多，一个匹配就越容易找到。在另一方面，系统应该足够小以便于浏览。添加一些只匹配很少规范的模式可能不能抵消模式系统size的轻微增加，即有可能得不偿失。</p><p>在表中，我们能看到，大多数样例(80%)使用了global范围。并且，注意到几乎所有使用了non-global范围的样例都是Absence，University， 或者Existence 的实例。这三个模式是概念上最简单的。对于global范围，它们映射到简单的时间逻辑运算。</p><p>现在看看合作者以及学生(“我们”)写的规范(304个)与”别人”写的规范(251个)的区别：四个最常见的模式(Response, Universality, Absence, UNKNOWN(也就是无法识别的))是一样的。而其余的模式是不一样的，但是由于数据量较小，所以可能是误差。有一个不同的是，“我们”写下更多带有non-global范围的规范，虽然“我们”的绝大部分规范也使用了global范围。有趣的是，“我们”比“别人”写下更多模式系统之外的规范。</p><p>另一个有趣的问题是：模式系统是否会影响人们编写的规范？有限状态验证通常被用于检查重要的需求，但是将要被检查的确切需求选择（exact choice of requirements to be checked），以及这些需求在模型方面被表达的方式，通常是留给分析师的。在给定一个模式系统来协助制定属性映射的情况下，分析师可能更倾向于使用更复杂的模式 and/ or 范围。为了调查这个，我们采用了“我们”的一组规范，并且在我们开发模式系统之前编写的165个规范，以及开发之后编写的139个规范。</p><p>在这次比较中，区别更加明显：一些更复杂的模式（比如chains）只在引入模式系统后才出现。在开发完模式系统之后编写的规范中，更多规范使用了non-global范围(33% vs. 5%)，并且那些后来的规范更均匀（尽管不是统一的）分布在不同的模式上。同时，注意到在开发完模式系统之后编写的所有规范都符合其中一种模式。</p><p>所以，用于有限状态验证的属性规范的模式系统有着很大的潜力，它显示出绝大部分规范都落在少数的分类中。为了表明该系统实际上有用，需要回答几个更难的问题，其中包括：</p><ul><li>模式是否有助于学习规范形式？</li><li>模式是否允许更快地写出规范？</li><li>从模式生成的规范是否更可能是正确的？</li></ul><p>解答这些问题还是需要实验数据。到目前为止，本文作者只有一些证据支持他们的观点，主要来自本文一作在硕士级软件工程课程中教授有限状态验证课程的经验。</p><hr><h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>传统上，规范形式化是以最小的一组操作符集来表示的，这是为了简化它们的语义定义。 然后根据这些操作符来定义其他操作符，比如，□P = ¬◇¬P，所以只有几个基元需要正式定义。这种形式的用户宁愿编写比这更高级别的规范，所以许多形式提供内置的更高级别的操作符或抽象。我们的模式系统支持一套通用的，但固定的形式化规范抽象，不过这个形式缺乏对定义抽象的明确支持。</p><p>关于开发者可能或者确实写的规范类别的研究很少。 Manna和Pnueli [17]从理论角度解决了这个问题，提出了LTL公式的句法分类，它完全描述了人们可能在LTL中编写的可能规范的空间。他们的规范分类包括比我们的模式更广泛的类别。因此，我们的大多数模式很容易按其分类进行分类：具有global范围的precedence，absence和universal模式都是safety属性，具有global范围的existence模式是guarantee属性，global范围的response模式是response属性。我们k-bounded existence模式与它们的k-bounded overtaking性质（这是一种safety属性）非常相似。因为chain模式和complex范围，对语法类别的映射变得更加困难（由于定义类别的规范形式的性质）。与这项工作相反，我们工作的目标是对实践中最频繁出现的规范类别进行建设性描述。</p><p>他们声称，时间逻辑的一般理论很少需要处理并发程序的最重要，最常见，最正确的属性。他们定义了一个处理invariance属性（归入most universal 和absence模式），response属性（归入response模式）和precedence属性（归入precedence和bounded existence并且类似于chain模式）的受限证明系统(restricted proof-system)。它们的precedence属性也包含universal和absence模式的after-until范围版本。我们在我们中提供的数据支持了Manna和Pnueli关于常见属性的直觉，因为我们发现absence，universal和response模式构成了我们调查中的大部分属性。</p><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们认为在编写正式规范时定义和使用高级抽象是使自动化形式化方法（特别是有限状态验证工具）更加可用的重要因素。我们的规范模式系统为形式化提供了一组通用的高级规范抽象，这些抽象不直接支持这些抽象的定义。我们描述了一个更新的模式系统，我们为有限状态验证中的属性规范开发了一个更新的模式系统，并收集了大量规范样本，这些规范说明大多数人编写的属性规范都是该系统中模式的实例。</p><p>目前我们正在探索几个方向来进一步研究规范模式。</p><p>我们正在努力定义模式来简化在CTL中编写一类假设-保证(assume-guarantee)属性。在LTL中编写这样的规范非常简单；但在CTL中，这些属性可能非常难以表达。我们正在研究基于模式为属性规范定义语言的好处，提供自动化支持，将用该语言表达的属性编译为特定的形式，并检查模式替换的合法性。</p><p>我们正在研究检查 以多种形式表达的模式映射的 一致性的方法。例如，虽然CTL和LTL通常不共同表达，但我们所有的CTL和LTL映射都位于CTL *的全路径片段(all-paths fragment)中；因此我们可能能够正式证明这些映射的等价性。</p><p>我们将模式系统视为一个动态实体，它将通过有限状态验证技术的开发人员和用户的社区的对话和批判性评论成长。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;definition&quot;&gt;&lt;a href=&quot;#definition&quot; class=&quot;headerlink&quot; title=&quot;definition&quot;&gt;&lt;/a&gt;definition&lt;/h2&gt;&lt;p&gt;premise: An LTL formula can be &lt;em&gt;satisfied&lt;/em&gt; by an infinite sequence of truth evaluations of variables in &lt;em&gt;AP&lt;/em&gt; .&lt;/p&gt;
    
    </summary>
    
      <category term="pattern" scheme="http://KunKin.github.io/categories/pattern/"/>
    
    
      <category term="pattern" scheme="http://KunKin.github.io/tags/pattern/"/>
    
  </entry>
  
  <entry>
    <title>Chapter14-Iterations-and-Comprehensions</title>
    <link href="http://KunKin.github.io/2018/05/16/Chapter14-Iterations-and-Comprehensions/"/>
    <id>http://KunKin.github.io/2018/05/16/Chapter14-Iterations-and-Comprehensions/</id>
    <published>2018-05-16T07:50:41.000Z</published>
    <updated>2018-05-16T13:19:39.639Z</updated>
    
    <content type="html"><![CDATA[<p>前言：这一章主要是讲迭代（迭代器以及可迭代对象） 和 推导式（comprehension）</p><p>comprehension 就是 类似于list(x for x in object) 这种</p><p>iteration 包括 Iterator  和 Iterable 的对象，以及各种迭代器的使用，其中配合comprehension的话迭代器能发挥更多作用</p><a id="more"></a> <hr><p>关于list comprehension 很重要的一点：</p><p>List comprehensions might run much faster than manual for loop statements (often roughly twice as fast) because their iterations are performed at C language speed inside the interpreter, rather than with manual Python code.</p><p>就是说list comprehension是在Python 解释器里跑的，比手动写的Python编码快</p><p>（迭代器遍历比较快，这点Java中也一样）</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>) <span class="comment"># Read a four-line script file in this directory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline() <span class="comment"># readline loads one line on each call</span></span><br><span class="line"><span class="string">'import sys\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line"><span class="string">'print(sys.path)\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line"><span class="string">'x = 2\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline() <span class="comment"># Last lines may have a \n or not</span></span><br><span class="line"><span class="string">'print(x ** 32)\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline() <span class="comment"># Returns empty string at end-of-file</span></span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>) <span class="comment"># __next__ loads one line on each call too</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() <span class="comment"># But raises an exception at end-of-file</span></span><br><span class="line"><span class="string">'import sys\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() <span class="comment"># Use f.next() in 2.X, or next(f) in 2.X or 3.X</span></span><br><span class="line"><span class="string">'print(sys.path)\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line"><span class="string">'x = 2\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line"><span class="string">'print(x ** 32)\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>用__next__好过用readline： Such object may also be stepped through with a for loop or other iteration tool, because all iteration tools normally work internally by calling __next__ on each iteration and catching the StopIteration exception to determine when to exit.</p><p>大意是说，可以利用for循环或其他迭代器读取__next__，因为一般来说迭代器的每次迭代调用的也是__next__，而且迭代器还能根据“StopIteration”这个异常来终止迭代。</p><p>注意Python中也是有异常的，像Java一样。</p><hr><p>从文本文件中逐行读入所有的文本并打印，下面三种语句都有同样的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>): <span class="comment"># Use file iterators to read by lines</span></span><br><span class="line"><span class="meta">... </span>print(line.upper(), end=<span class="string">''</span>) <span class="comment"># Calls __next__, catches StopIteration</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>).readlines(): <span class="comment">#Notice that "readlines" has a "s"</span></span><br><span class="line"><span class="meta">... </span>print(line.upper(), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>line = f.readline()</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>print(line.upper(), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>①：注意 print 用了一个 <code>end=&#39; &#39;</code>，用来阻止Python在行末加’\n’——因为读入的语句中已经有一个’\n’了。事实上，①的方法是最好的逐行读取文本文的方法：1、编码简单；2、快；3、占用内存空间少</p><p>②中readline不是最好的选择，还占用很多内存空间（because this version really does load the entire file into memory all at once, it will not even work for files too big to fit into the memory space available on your computer.）</p><p>③中的while循环比基于迭代器（iterator-based）的for循环慢，因为在Python中迭代器（iterator）是以C语言的速度运行的，而③中的while循环是在Python虚拟机中以Python字节码运行的</p><p>综上：用①就好了，忘了②③吧</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() <span class="comment"># Call iteration method directly</span></span><br><span class="line"><span class="string">'import sys\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line"><span class="string">'print(sys.path)\n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(f) <span class="comment"># The next(f) built-in calls f.__next__() in 3.X</span></span><br><span class="line"><span class="string">'import sys\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(f) <span class="comment"># next(f) =&gt; [3.X: f.__next__()], [2.X: f.next()]</span></span><br><span class="line"><span class="string">'print(sys.path)\n'</span></span><br></pre></td></tr></table></figure><p>python3中提供了一个内置函数next()（built-in function）（__next__是方法(method)，注意二者区别）</p><p>从技术上讲，前面提到的迭代协议还有一点。 当for循环开始时，它首先通过将它传递给iter内置函数来从可迭代对象中获取一个迭代器; 由iter返回的对象又具有所需的下一个方法。 iter函数内部运行__iter__方法，非常像next和__next__.</p><p><strong>迭代</strong>：用一个循环（比如 for 循环）来遍历容器（比如列表，元组）中的元素。</p><p><strong>可迭代对象</strong>：含有 <code>__iter__()</code> 方法或 <code>__getitem__()</code> 方法的对象。</p><p><strong>迭代器协议（iterator protocol）</strong>是指要实现对象的 <code>__iter()__</code> 和 <code>next()</code> 方法（注意：Python3 要实现 <code>__next__()</code> 方法），其中，<code>__iter()__</code> 方法返回迭代器对象本身，<code>next()</code> 方法返回容器的下一个元素，在没有后续元素时抛出 <code>StopIteration</code> 异常。</p><p><em>（也就是说要同时拥有<code>__iter()__</code> 和 <code>next()</code> 方法才符合iterator protocol）</em></p><p>使用 <code>hasattr()</code> 和 <code>isinstance()</code> 判断是否迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="string">'__iter__'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="string">'next'</span>)  <span class="comment"># 有 __iter__ 方法但是没有 next 方法，不是迭代器</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((), Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>虽然元组、列表和字典等对象是可迭代的，但它们却不是迭代器</strong>，对于这些可迭代对象，可以使用 Python 内置的 <code>iter()</code> 函数获得它们的迭代器对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I = iter(L) <span class="comment"># Obtain an iterator object from an iterable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I.__next__() <span class="comment"># Call iterator's next to advance to next item</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I.__next__() <span class="comment"># Or use I.next() in 2.X, next(I) in either line</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I.__next__()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I.__next__()</span><br><span class="line">...error text omitted...</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I = iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> I: print(i)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> L: print(i)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>其中，iter(L)和L都是可迭代的（iterable），因此能以 “for i in X:”的形式进行迭代</p><hr><p><strong>next()函数和__next__()方法只能用于Iterator</strong>(其实还有__iter()__也只能用于Iterator)（iterator protocol）,所以要用这些函数和方法就要先用iter()取得object的iterator</p><hr><p>事实上，Python 的 <code>for</code> 循环就是先通过内置函数 <code>iter()</code> 获得一个迭代器，然后再不断调用 <code>next()</code> 函数实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得 Iterator 对象</span></span><br><span class="line">it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获得下一个值</span></span><br><span class="line">        x = next(it)</span><br><span class="line">        <span class="keyword">print</span> x</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># 没有后续元素，退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>除了iter()返回的各种iterable object的 Iterator外，以<code>f = open(FILEPATH)</code>获得的file对象和以<code>E = enumerate(&#39;spam&#39;)</code>获得的enumerate对象也是Iterator.</p><hr><p>rstrip() ：the string method to remove whitespace on the right side. （也就是说，使用line.rstrip()的话，如果右边不是空白字符如\n,\t,\r,空格的话就不会被清除，是一种比较安全的去除右端空白字符的方法，而line[:-1]可能丢失有效信息 ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = f.readlines()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">'import sys'</span>, <span class="string">'print(sys.path)'</span>, <span class="string">'x = 2'</span>, <span class="string">'print(x ** 32)'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Optimal solution. It's efficient: </span></span><br><span class="line"><span class="comment">#1: fast(work is done inside the Python interpreter)</span></span><br><span class="line"><span class="comment">#2: list comprehensions' advantages for large files</span></span><br><span class="line"><span class="comment">#3: remarkably expressive</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">'import sys'</span>, <span class="string">'print(sys.path)'</span>, <span class="string">'x = 2'</span>, <span class="string">'print(x ** 32)'</span>]</span><br></pre></td></tr></table></figure><p>rstrip == right strip，同理，还有个lstrip方法（strip：去除）</p><p>另外：从读取到存储过程中的各种字符串操作（upper(), spilt(), replace(), in, slice）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.upper() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[<span class="string">'IMPORT SYS\n'</span>, <span class="string">'PRINT(SYS.PATH)\n'</span>, <span class="string">'X = 2\n'</span>, <span class="string">'PRINT(X ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.rstrip().upper() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[<span class="string">'IMPORT SYS'</span>, <span class="string">'PRINT(SYS.PATH)'</span>, <span class="string">'X = 2'</span>, <span class="string">'PRINT(X ** 32)'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.split() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[[<span class="string">'import'</span>, <span class="string">'sys'</span>], [<span class="string">'print(sys.path)'</span>], [<span class="string">'x'</span>, <span class="string">'='</span>, <span class="string">'2'</span>], [<span class="string">'print(x'</span>, <span class="string">'**'</span>, <span class="string">'32)'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.replace(<span class="string">' '</span>, <span class="string">'!'</span>) <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[<span class="string">'import!sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x!=!2\n'</span>, <span class="string">'print(x!**!32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">'sys'</span> <span class="keyword">in</span> line, line[:<span class="number">5</span>]) <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[(<span class="keyword">True</span>, <span class="string">'impor'</span>), (<span class="keyword">True</span>, <span class="string">'print'</span>), (<span class="keyword">False</span>, <span class="string">'x = 2'</span>), (<span class="keyword">False</span>, <span class="string">'print'</span>)]</span><br></pre></td></tr></table></figure><hr><p><strong>例：斐波那契数列迭代器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回迭代器对象本身</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回容器下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    fib = Fib()    <span class="comment"># fib 是一个迭代器</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'isinstance(fib, Iterator): '</span>, isinstance(fib, Iterator)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fib:</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><hr><p><strong>过滤子句(Filter Clauses):if</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>) <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'p'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">'print(sys.path)'</span>, <span class="string">'print(x ** 32)'</span>]</span><br></pre></td></tr></table></figure><p>当然我们也可以写成下面的语句（就是可能会慢）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#it takes up four lines instead of one and may run slower</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>):</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'p'</span>:</span><br><span class="line"><span class="meta">... </span>res.append(line.rstrip())</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="string">'print(sys.path)'</span>, <span class="string">'print(x ** 32)'</span>]</span><br></pre></td></tr></table></figure><p>for声明占用4行，list comprehension 一次只占一行，因此for声明可能一些。</p><p>我们也可以利用list comprehension加很多过滤条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>) <span class="keyword">if</span> line.rstrip()[<span class="number">-1</span>].isdigit()]</span><br><span class="line">[<span class="string">'x = 2'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fname = <span class="string">r'd:\books\5e\lp5e\draft1typos.txt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(open(fname).readlines()) <span class="comment"># All lines</span></span><br><span class="line"><span class="number">263</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len([line <span class="keyword">for</span> line <span class="keyword">in</span> open(fname) <span class="keyword">if</span> line.strip() != <span class="string">''</span>]) <span class="comment"># Nonblank lines</span></span><br><span class="line"><span class="number">185</span></span><br></pre></td></tr></table></figure><p>​    ——“List comprehensions can become even more complex if we need them to.”</p><hr><p><strong>list comprehension中的嵌套循环</strong></p><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abc'</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'lmn'</span>]</span><br><span class="line">[<span class="string">'al'</span>, <span class="string">'am'</span>, <span class="string">'an'</span>, <span class="string">'bl'</span>, <span class="string">'bm'</span>, <span class="string">'bn'</span>, <span class="string">'cl'</span>, <span class="string">'cm'</span>, <span class="string">'cn'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#means</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abc'</span>:</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'lmn'</span>:</span><br><span class="line"><span class="meta">... </span>res.append(x + y)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="string">'al'</span>, <span class="string">'am'</span>, <span class="string">'an'</span>, <span class="string">'bl'</span>, <span class="string">'bm'</span>, <span class="string">'bn'</span>, <span class="string">'cl'</span>, <span class="string">'cm'</span>, <span class="string">'cn'</span>]</span><br></pre></td></tr></table></figure><p>虽然list comprehension expressions为了性能变得很紧凑，但是对于那些“more involved work”，如果使用list comprehension expression 难以理解的话，最好还是用更简单明了的for语句结构。</p><hr><p>除了for外其他可迭代的“built-ins process”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#map</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(str.upper, open(<span class="string">'script2.py'</span>)) <span class="comment"># map is itself an iterable in 3.X</span></span><br><span class="line">&lt;map object at <span class="number">0x00000000029476D8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str.upper, open(<span class="string">'script2.py'</span>)))</span><br><span class="line">[<span class="string">'IMPORT SYS\n'</span>, <span class="string">'PRINT(SYS.PATH)\n'</span>, <span class="string">'X = 2\n'</span>, <span class="string">'PRINT(X ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#sorted</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(open(<span class="string">'script2.py'</span>))</span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'print(x ** 32)\n'</span>, <span class="string">'x = 2\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#zip</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(open(<span class="string">'script2.py'</span>), open(<span class="string">'script2.py'</span>)))</span><br><span class="line">[(<span class="string">'import sys\n'</span>, <span class="string">'import sys\n'</span>), (<span class="string">'print(sys.path)\n'</span>, <span class="string">'print(sys.path)\n'</span>),</span><br><span class="line">(<span class="string">'x = 2\n'</span>, <span class="string">'x = 2\n'</span>), (<span class="string">'print(x ** 32)\n'</span>, <span class="string">'print(x ** 32)\n'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#enumerate</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(open(<span class="string">'script2.py'</span>)))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'import sys\n'</span>), (<span class="number">1</span>, <span class="string">'print(sys.path)\n'</span>), (<span class="number">2</span>, <span class="string">'x = 2\n'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'print(x ** 32)\n'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#filter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(bool, open(<span class="string">'script2.py'</span>))) <span class="comment"># nonempty=True</span></span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#functools.reduce</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools, operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(operator.add, open(<span class="string">'script2.py'</span>))</span><br><span class="line"><span class="string">'import sys\nprint(sys.path)\nx = 2\nprint(x ** 32)\n'</span></span><br></pre></td></tr></table></figure><p>essentially everything in Python’s built-in toolset that scans an object from left to right is defined to use the iteration protocol on the subject object.</p><p>(从Python的内置工具集中，从左到右扫描对象的所有内容定义为在主体对象上使用迭代协议。)</p><p>这甚至包括了 list, tuple等对象 和  字符串的’join’方法 以及一些其他的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(open(<span class="string">'script2.py'</span>))</span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple(open(<span class="string">'script2.py'</span>))</span><br><span class="line">(<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&amp;&amp;'</span>.join(open(<span class="string">'script2.py'</span>))</span><br><span class="line"><span class="string">'import sys\n&amp;&amp;print(sys.path)\n&amp;&amp;x = 2\n&amp;&amp;print(x ** 32)\n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = open(<span class="string">'script2.py'</span>) <span class="comment"># Sequence assignment</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, d</span><br><span class="line">(<span class="string">'import sys\n'</span>, <span class="string">'print(x ** 32)\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b = open(<span class="string">'script2.py'</span>) <span class="comment"># 3.X extended form</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="string">'import sys\n'</span>, [<span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'y = 2\n'</span> <span class="keyword">in</span> open(<span class="string">'script2.py'</span>) <span class="comment"># Membership test</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'x = 2\n'</span> <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>] <span class="comment"># Slice assignment</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>] = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="comment">#[11, 'import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n', 44]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.extend(open(<span class="string">'script2.py'</span>)) <span class="comment"># list.extend method</span></span><br><span class="line"><span class="comment">#[11, 'import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n']</span></span><br></pre></td></tr></table></figure><p>但在读取文件内容上，append方法不同于extend方法：</p><p>​    extend: 把文件内容逐行append进list里</p><p>​    append:  把文件内容整体装在_io.TextIOWrapper对象里，以一个_io.TextIOWrapper对象的形式（而不是多个字符串对象）置于list尾部。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.append(open(<span class="string">'script2.py'</span>)) <span class="comment"># list.append does not iterate</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">11</span>, &lt;_io.TextIOWrapper name=<span class="string">'script2.py'</span> mode=<span class="string">'r'</span> encoding=<span class="string">'cp1252'</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(L[<span class="number">1</span>])</span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>]</span><br></pre></td></tr></table></figure><hr><p>The built-in dict call accepts an iterable zip result, and so does the set call, as well as the newer set and dictionary comprehension expressions in Python 3.X and 2.7.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(open(<span class="string">'script2.py'</span>))</span><br><span class="line">&#123;<span class="string">'print(x ** 32)\n'</span>, <span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;line <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)&#125;</span><br><span class="line">&#123;<span class="string">'print(x ** 32)\n'</span>, <span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#(ix: line) for (ix, line) in enumerate(open('script2.py'))</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;ix: line <span class="keyword">for</span> ix, line <span class="keyword">in</span> enumerate(open(<span class="string">'script2.py'</span>))&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'import sys\n'</span>, <span class="number">1</span>: <span class="string">'print(sys.path)\n'</span>, <span class="number">2</span>: <span class="string">'x = 2\n'</span>, <span class="number">3</span>: <span class="string">'print(x ** 32)\n'</span>&#125;</span><br></pre></td></tr></table></figure><p>事实上，set 和 dictionary 的comprehension expression 也支持上面我们所见到的拓展语句（extended syntax, 注意这个extended 与extend方法无关…）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;line <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>) <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'p'</span>&#125;</span><br><span class="line">&#123;<span class="string">'print(x ** 32)\n'</span>, <span class="string">'print(sys.path)\n'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;ix: line <span class="keyword">for</span> (ix, line) <span class="keyword">in</span> enumerate(open(<span class="string">'script2.py'</span>)) <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'p'</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'print(sys.path)\n'</span>, <span class="number">3</span>: <span class="string">'print(x ** 32)\n'</span>&#125;</span><br></pre></td></tr></table></figure><p>典型的extended syntax 就是comprehension expression 后面的 if 语句。</p><hr><p>内置函数 sum(), any(), all(), max(), min() 的用法与效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum([<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>]) <span class="comment"># sum expects numbers only</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line">//The any built-ins <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> any items <span class="keyword">in</span> an iterable are <span class="keyword">True</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([<span class="string">'spam'</span>, <span class="string">''</span>, <span class="string">'ni'</span>])</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">//The all built-ins <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> all items <span class="keyword">in</span> an iterable are <span class="keyword">True</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([<span class="string">'spam'</span>, <span class="string">''</span>, <span class="string">'ni'</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max([<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min([<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>这些函数工具都接收到一些可迭代对象作为参数，然后用迭代器协议扫描它们。</p><p>严格来说，max() 和 min() 也可以用在文件里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(open(<span class="string">'script2.py'</span>)) <span class="comment"># Line with max/min string value</span></span><br><span class="line"><span class="string">'x = 2\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(open(<span class="string">'script2.py'</span>))</span><br><span class="line"><span class="string">'import sys\n'</span></span><br></pre></td></tr></table></figure><hr><p>参数以 *arg 的形式传参给函数，那么，这个参数里的数据集将会被解压成单个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c, d)</span>:</span> print(a, b, c, d, sep=<span class="string">'&amp;'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span>&amp;<span class="number">2</span>&amp;<span class="number">3</span>&amp;<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment"># Unpacks into arguments</span></span><br><span class="line"><span class="number">1</span>&amp;<span class="number">2</span>&amp;<span class="number">3</span>&amp;<span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(*open(<span class="string">'script2.py'</span>)) <span class="comment"># Iterates by lines too!</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">&amp;print(sys.path)</span><br><span class="line">&amp;x = <span class="number">2</span></span><br><span class="line">&amp;print(x ** <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>还可以用 zip() 来 unzip 一个 zip tuple:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(X, Y)) <span class="comment"># Zip tuples: returns an iterable</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A, B = zip(*zip(X, Y)) <span class="comment"># Unzip a zip!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#help(zip)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">class zip(object)</span></span><br><span class="line"><span class="string"> |  zip(iter1 [,iter2 [...]]) --&gt; zip object</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  Return a zip object whose .__next__() method returns a tuple where</span></span><br><span class="line"><span class="string"> |  the i-th element comes from the i-th iterable argument.  The .__next__()</span></span><br><span class="line"><span class="string"> |  method continues until the shortest iterable in the argument sequence</span></span><br><span class="line"><span class="string"> |  is exhausted and then it raises StopIteration.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>更多关于zip：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">7</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(i <span class="keyword">for</span> i <span class="keyword">in</span> Z)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*zip((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">7</span>))))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">6</span>, <span class="number">7</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#zip() return a zip object which cannot index but force list of results.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># Unlike 2.X lists, cannot index, etc.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z[<span class="number">0</span>]</span><br><span class="line">TypeError: <span class="string">'zip'</span> object <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br><span class="line"></span><br><span class="line"><span class="comment">#Notice that list(*Z) and list(zip(*Z)) just return [].</span></span><br><span class="line"><span class="comment">##It is because Z is an iterator, so that after iterating(Z has been iterated ), Z is exhausted.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Z, Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Even *Z and list(*zip(arg1,arg2,...)) is a syntax error!</span></span><br><span class="line"><span class="comment">#Renmeber that the *arg is used to unpack a collection of values into individual arguments.</span></span><br><span class="line"><span class="comment">#And *zip(arg1, arg2) is unpacked into two individual arguments, while list() can just takes at most 1 argument, so that list(*zip(arg1,arg2[,...])) is a syntax error, but the syntax like list(*zip((1,),(2,))) is right</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(*zip((<span class="number">1</span>,),(<span class="number">2</span>,)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>zip()会将相同位置的元素装在一个元素个数等于zip()参数个数的tuple中，有的tuple比别的tuple多出一些元素的话，这些元素将会被丢弃。</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">zip()</th></tr></thead><tbody><tr><td style="text-align:left">(1,2,3)<br>(4,5)<br>(6,7)</td><td style="text-align:left">\</td><td>1\</td><td>\</td><td>2\</td><td><br>\</td><td>4\</td><td>\</td><td>5\</td><td><br>\</td><td>6\</td><td>\</td><td>7\</td></tr></tbody></table><p>可以看出来就是一个转置矩阵的效果， 那么 zip(*zip(arg1, arg2,…)) 就是除去不平整的尾数后进行两次转置，也就是相当于：原tuple组去除不平整的尾数。</p><p>zip的迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)) <span class="comment"># zip is the same: a one-pass iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z</span><br><span class="line">&lt;zip object at <span class="number">0x0000000002951108</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Z)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">20</span>), (<span class="number">3</span>, <span class="number">30</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> pair <span class="keyword">in</span> Z: print(pair) <span class="comment"># Exhausted after one pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> pair <span class="keyword">in</span> Z: print(pair) <span class="comment"># Iterator used automatically or manually</span></span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)) <span class="comment"># Manual iteration (iter() not needed)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Z)</span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Z)</span><br><span class="line">(<span class="number">2</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>另注：(1) 是int类型， 要定义只有一个元素的tuple，需要用(1,)的形式，以避免与运算中的括号产生歧义。但是list 和 dictionary 就不用，因为[] 和 {} 没有歧义。</p><hr><p>range() 也是一个 object，属于 <code>&lt;class &#39;range&#39;&gt;</code>，range 是 iterable 的， 因此可以用<code>iter(range(arg))</code>来生成range的迭代器。</p><hr><p>map(映射)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = map(abs, (<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># map returns an iterable, not a list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M</span><br><span class="line">&lt;map object at <span class="number">0x00000000029B75C0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(M) <span class="comment"># Use iterator manually: exhausts results</span></span><br><span class="line"><span class="number">1</span> <span class="comment"># These do not support len() or indexing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(M)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(M)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(M)</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> M: print(x) <span class="comment"># map iterator is now empty: one pass only</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = map(abs, (<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># Make a new iterable/iterator to scan again</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> M: print(x) <span class="comment"># Iteration contexts auto call next()</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(abs, (<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>))) <span class="comment"># Can force a real list if needed</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>mapping class（映射类型）只有dict，但是有一个map()函数，返回的是map类型（注意区分！）</p><table><thead><tr><th>mapping</th><th>map()</th></tr></thead><tbody><tr><td>dict</td><td>map</td></tr></tbody></table><p>关于map()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">map</span><span class="params">(func, *iterables)</span> --&gt; map object</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  Make an iterator that computes the function using arguments from</span></span><br><span class="line"><span class="class"> |  each of the iterables.  Stops when the shortest iterable is exhausted.</span></span><br></pre></td></tr></table></figure><hr><p>filter:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">filter</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">filter</span><span class="params">(function or None, iterable)</span> --&gt; filter object</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  Return an iterator yielding those items of iterable for which function(item)</span></span><br><span class="line"><span class="class"> |  is true. If function is <span class="keyword">None</span>, return the items that are true.</span></span><br></pre></td></tr></table></figure><p>It returns items in an iterable for which a passed-in function returns True.</p><p>(True includes nonempty objects) </p><p>(bool returns an object’s truth value)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(bool, [<span class="string">'spam'</span>, <span class="string">''</span>, <span class="string">'ni'</span>])</span><br><span class="line">&lt;filter object at <span class="number">0x00000000029B7B70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(bool, [<span class="string">'spam'</span>, <span class="string">''</span>, <span class="string">'ni'</span>]))</span><br><span class="line">[<span class="string">'spam'</span>, <span class="string">'ni'</span>]</span><br></pre></td></tr></table></figure><hr><p>iterator 有一个很重要的特性就是被读取之后就不能寻回之前的数据了，简而言之它具有单向性和不可逆性。</p><hr><p>有一点要注意区别：对于不同的类型生成的迭代器，他们的性质有所区别</p><p>对于同一个range对象R，I1和I2是使用R生成的两个迭代器，注意到I1和I2的迭代进程是独立的。</p><p>​    这就是range对象的 multiple pass Iterator 的特性：it supports multiple iterators over its result that remember their positions independently.</p><p>​    （range支持len 和 indexing）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>R = range(<span class="number">3</span>) <span class="comment"># range allows multiple iterators</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(R)</span><br><span class="line">TypeError: range object <span class="keyword">is</span> <span class="keyword">not</span> an iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1 = iter(R)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I2 = iter(R) <span class="comment"># Two iterators on one range</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1) <span class="comment"># I1 is at a different spot than I2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>而map, zip, filter 不是这样，这些类型的某个对象生成的不同的迭代器的迭代进程是共享的，因为：the iter call is optional for stepping through such objects’results—their iter is themselves。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1 = iter(Z)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I2 = iter(Z) <span class="comment"># Two iterators on one zip</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line">(<span class="number">2</span>, <span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2) <span class="comment"># (3.X) I2 is at same spot as I1!</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = map(abs, (<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># Ditto for map (and filter)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1 = iter(M); I2 = iter(M)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(I1), next(I1), next(I1))</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2) <span class="comment"># (3.X) Single scan is exhausted!</span></span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>R = range(<span class="number">3</span>) <span class="comment"># But range allows many iterators</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1, I2 = iter(R), iter(R)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[next(I1), next(I1), next(I1)]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2) <span class="comment"># Multiple active scans, like 2.X lists</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>简而言之就是，对于自身就是迭代器的对象来说，迭代进程是共享的，自身不是迭代器的对象迭代进程不是共享的。</p><p>因为对于range这些<code>isinstance(object, Iterator)</code>返回<code>False</code>的类型来说，iter(range(arg))实际上是创建了一个新的Iterator，因此创建的Iterator是独立的。</p><p>而zip, map, filter 这些对象都是<code>isinstance(object, Iterator)</code>返回<code>True</code>的，他们自己就是迭代器，iter()实际上就是引用了自身，所以无论用iter()创建多少个Iterator对象实际上都只有原对象自己一个，对每一个Iterator对象操作实际上都是操作原对象，因此进程就共享了。</p><hr><p>Dictionary View Iterables：</p><p>the dictionary keys, values, and items methods return iterable view objects that generate result items one at a time, instead of producing result lists all at once in memory</p><p>dict对象的 key, values 和 items 方法能返回 iterable 的 “view 对象”(view object)（但不是Iterator，所以要用next()的话得手动 iter() 生成相应的Iterator。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>D = dict(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>K = D.keys() <span class="comment"># A view object in 3.X, not a list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>K</span><br><span class="line">dict_keys([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(K) <span class="comment"># Views are not iterators themselves</span></span><br><span class="line">TypeError: dict_keys object <span class="keyword">is</span> <span class="keyword">not</span> an iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> D.keys(): print(k, end=<span class="string">' '</span>) <span class="comment"># All iteration contexts use auto</span></span><br><span class="line">...</span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>V = D.values() <span class="comment"># Ditto for values() and items() views</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>V</span><br><span class="line">dict_values([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(V) <span class="comment"># Need list() to display or index as list</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>V[<span class="number">0</span>]</span><br><span class="line">TypeError: <span class="string">'dict_values'</span> object does <span class="keyword">not</span> support indexing</span><br><span class="line"><span class="comment">#The views (view object, incluing dict_values, dict_keys, dict_items) does not support len(), index</span></span><br></pre></td></tr></table></figure><p>Finally, remember again that because keys no longer returns a list, the traditional coding pattern for scanning a dictionary by sorted keys won’t work in 3.X. Instead, convert keys views first with a list call, or use the sorted call on either a keys view or the dictionary itself, as follows.</p><p>keys不返回list，因此不能通过排列好的keys来扫描一个字典。</p><p>对每一个keys view 或者 dictionary 它自己使用排序调用（sorted call）。</p><p>或者把keys view 转换成一个列表调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(D.items())</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (k, v) <span class="keyword">in</span> D.items(): print(k, v, end=<span class="string">' '</span>)</span><br><span class="line">...</span><br><span class="line">a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> sorted(D.keys()): print(k, D[k], end=<span class="string">' '</span>)</span><br><span class="line">...</span><br><span class="line">a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> sorted(D): print(k, D[k], end=<span class="string">' '</span>) <span class="comment"># "Best practice" key sorting</span></span><br><span class="line">...</span><br><span class="line">a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p>本章完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：这一章主要是讲迭代（迭代器以及可迭代对象） 和 推导式（comprehension）&lt;/p&gt;
&lt;p&gt;comprehension 就是 类似于list(x for x in object) 这种&lt;/p&gt;
&lt;p&gt;iteration 包括 Iterator  和 Iterable 的对象，以及各种迭代器的使用，其中配合comprehension的话迭代器能发挥更多作用&lt;/p&gt;
    
    </summary>
    
      <category term="Learning Python" scheme="http://KunKin.github.io/categories/Learning-Python/"/>
    
    
      <category term="Python" scheme="http://KunKin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Learning MySQL</title>
    <link href="http://KunKin.github.io/2018/05/16/Learning-MySQL/"/>
    <id>http://KunKin.github.io/2018/05/16/Learning-MySQL/</id>
    <published>2018-05-16T03:49:02.000Z</published>
    <updated>2018-05-16T07:52:39.635Z</updated>
    
    <content type="html"><![CDATA[<p>显示MySql数据库物理文件存放位置：</p><p>cmd :   show global variables like “%datadir”;</p><p>使用命令行连接MySQL：</p><p>mysql -u root -p</p><a id="more"></a> <hr><p>我们知道，在ms sql server中或access中，<br>若要查询前10条记录，使用top 10即可，<br>但在mysql中不支持这个写法。</p><p>LIMIT可以实现top N查询，也可以实现M至N（某一段）的记录查询，具体语法如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM MYTABLE</span><br><span class="line"></span><br><span class="line">ORDER BY AFIELD </span><br><span class="line"></span><br><span class="line">LIMIT offset, recnum</span><br></pre></td></tr></table></figure><p>其中OFFSET为从第几条（M+1）记录开始，recnum为返回的记录条数。例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from mytable</span><br><span class="line"></span><br><span class="line">ORDER BY afield </span><br><span class="line"></span><br><span class="line">LIMIT 2, 5</span><br></pre></td></tr></table></figure><p>即意为从第3条记录开始的5条记录。</p><p>那么《SQL必知必会》中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT TOP 5 prod_name</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure><p>在MySQL中的等价语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">LIMIT 0,5;</span><br></pre></td></tr></table></figure><hr><p>降序是用DESC关键字：</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; ORDER BY prod_price DESC;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BR03    |      11.99 | 18 inch teddy bear  |</span><br><span class="line">| RYL01   |       9.49 | King doll           |</span><br><span class="line">| RYL02   |       9.49 | Queen doll          |</span><br><span class="line">| BR02    |       8.99 | 12 inch teddy bear  |</span><br><span class="line">| BR01    |       5.99 | 8 inch teddy bear   |</span><br><span class="line">| RGAN01  |       4.99 | Raggedy Ann         |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>DESC是接在要降序的列名后面，而不是所有列名后面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; ORDER BY prod_price, prod_name DESC;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">| RGAN01  |       4.99 | Raggedy Ann         |</span><br><span class="line">| BR01    |       5.99 | 8 inch teddy bear   |</span><br><span class="line">| BR02    |       8.99 | 12 inch teddy bear  |</span><br><span class="line">| RYL02   |       9.49 | Queen doll          |</span><br><span class="line">| RYL01   |       9.49 | King doll           |</span><br><span class="line">| BR03    |      11.99 | 18 inch teddy bear  |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; ORDER BY prod_price DESC, prod_name DESC;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BR03    |      11.99 | 18 inch teddy bear  |</span><br><span class="line">| RYL02   |       9.49 | Queen doll          |</span><br><span class="line">| RYL01   |       9.49 | King doll           |</span><br><span class="line">| BR02    |       8.99 | 12 inch teddy bear  |</span><br><span class="line">| BR01    |       5.99 | 8 inch teddy bear   |</span><br><span class="line">| RGAN01  |       4.99 | Raggedy Ann         |</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; from Products</span><br><span class="line">    -&gt; order by prod_price DESC, prod_name;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BR03    |      11.99 | 18 inch teddy bear  |</span><br><span class="line">| RYL01   |       9.49 | King doll           |</span><br><span class="line">| RYL02   |       9.49 | Queen doll          |</span><br><span class="line">| BR02    |       8.99 | 12 inch teddy bear  |</span><br><span class="line">| BR01    |       5.99 | 8 inch teddy bear   |</span><br><span class="line">| RGAN01  |       4.99 | Raggedy Ann         |</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">+---------+------------+---------------------+</span><br></pre></td></tr></table></figure><p>DESC也可以写成DESCENGING。</p><p>（另外还有升序  ASC和 ASCENDING ，但是由于升序是默认的，所以ASC没什么用）</p><hr><p><strong>过滤</strong></p><p>用WHERE子句</p><p>但是ORDER BY 子句与WHERE子句同用时，ORDER BY 子句需要放在WHERE 子句后，不然会出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; order by prod_price DESC, prod_name</span><br><span class="line">    -&gt; where prod_price = &apos;3.49&apos;;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;where prod_price = &apos;3.49&apos;&apos; at line 4</span><br><span class="line"></span><br><span class="line">mysql&gt; select prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; from Products</span><br><span class="line">    -&gt; where prod_price = &apos;3.49&apos;</span><br><span class="line">    -&gt; order by prod_price DESC, prod_name</span><br><span class="line">    -&gt; ;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">+---------+------------+---------------------+</span><br></pre></td></tr></table></figure><p>WHERE 子句操作符：</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;&gt;</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">!&lt;</td><td style="text-align:center">不小于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">!&gt;</td><td style="text-align:center">不大于</td></tr><tr><td style="text-align:center">BETWEEN</td><td style="text-align:center">在指定的两个值之间</td></tr><tr><td style="text-align:center">IS NULL</td><td style="text-align:center">为NULL值</td></tr></tbody></table><hr><p><strong>NULL 和 非匹配</strong></p><p>空值检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_email IS NULL;</span><br><span class="line"></span><br><span class="line">cust_name</span><br><span class="line">----------</span><br><span class="line">Kids Place</span><br><span class="line">The Toy Store</span><br></pre></td></tr></table></figure><p>通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果。</p><p>过滤数据时，一定要验证被过滤列中含NULL的行确实出现在返回的数据中。</p><hr><p><strong>通配符%可以匹配0、1、多个字符，但不匹配NULL</strong></p><hr><p><strong>通配符%请注意空格：</strong></p><p>包括Access在内的许多DBMS都用空格来填补字段的内容，例如，某列有50个字符，而存储的文本为<code>Fish bean bag toy</code>（17个字符），则为了填满该列需要在文本后附加33个空格。这样做一般对数据及其使用没有影响，但是可能对<code>WHERE prod_name LIKE &#39;F%y&#39;</code>这样的语句有负面影响。子句<code>WHERE prod_name LIKE &#39;F%y&#39;</code>只匹配以F开头、以y结尾的prod_name。如果值后面跟空格，则不是以y结尾，所以<code>Fish bean bag toy</code>就不会被检索出来。简单的解决办法是用<code>F%y%</code>，但是更好的解决方法是用函数去掉空格。</p><hr><p>通配符<code>%</code>匹配任意个字符，<code>_</code>匹配一个字符。</p><p>DB2不支持<code>_</code></p><p>Microsoft Access用的是<code>?</code>而非<code>_</code></p><hr><p>SELECT子句顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;显示MySql数据库物理文件存放位置：&lt;/p&gt;
&lt;p&gt;cmd :   show global variables like “%datadir”;&lt;/p&gt;
&lt;p&gt;使用命令行连接MySQL：&lt;/p&gt;
&lt;p&gt;mysql -u root -p&lt;/p&gt;
    
    </summary>
    
      <category term="Learning MySQL" scheme="http://KunKin.github.io/categories/Learning-MySQL/"/>
    
    
      <category term="MySQL" scheme="http://KunKin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Chapter28.A More Realistic Example</title>
    <link href="http://KunKin.github.io/2018/05/16/Chapter28-A-More-Realistic-Example/"/>
    <id>http://KunKin.github.io/2018/05/16/Chapter28-A-More-Realistic-Example/</id>
    <published>2018-05-16T03:47:35.000Z</published>
    <updated>2018-05-16T13:18:11.531Z</updated>
    
    <content type="html"><![CDATA[<p>前言：正如章题所言，本章中我们将建立一个类集(set of classes)，以实现一些具体的东西——记录和处理有关人的信息。在后面我们将会看到，我们所说的实例(instance)和类(class) 能够起到与传统术语中的记录(record)和规划(program)一样的作用。</p><p>Python的类系统实际上主要只是在对象树中搜索属性，伴随着一个特别的 函数的第一个参数。(Despite its syntax details, Python’s class system really is largely just a matter of searching for an attribute in a tree of objects, along with a special first argument for functions.)</p><a id="more"></a> <hr><h3 id="第一步：制作实例-Making-Instance"><a href="#第一步：制作实例-Making-Instance" class="headerlink" title="第一步：制作实例(Making Instance)"></a>第一步：制作实例(Making Instance)</h3><h4 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person.py (start)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span> <span class="comment"># Start a class</span></span><br></pre></td></tr></table></figure><h4 id="构造方法（constructor-method）"><a href="#构造方法（constructor-method）" class="headerlink" title="构造方法（constructor method）"></a>构造方法（constructor method）</h4><p>​    实例对象属性通常是这么创建的：赋值给类的方法函数(method function)中的self属性。 为实例属性赋初始值的常规方式是在__init__构造方法中将它们分配给self，__init__构造方法中包含了每次创建实例时Python都会自动运行的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add record field initialization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job, pay)</span>:</span> <span class="comment"># Constructor takes three arguments</span></span><br><span class="line">        self.name = name <span class="comment"># Fill out fields when created</span></span><br><span class="line">        self.job = job <span class="comment"># self is the new instance object</span></span><br><span class="line">        self.pay = pay</span><br></pre></td></tr></table></figure><p>这是一种非常常见的编码模式：我们将要附加到instance的数据作为参数传递给构造函数方法，并将它们分配给自身以永久保留它们。<br>从面向对象的角度来说，self是新创建的实例对象，name，job和pay成为保存在对象上的状态信息——供以后使用的描述性数据。 尽管其他技术（例如封闭作用域引用闭包）也可以节省细节，但实例属性使其非常明确且易于理解。</p><p>注意，self.job 是类的属性，而job是__init__函数范围内的变量，两者同名而异出。通过把局部变量job的值赋给self.job 属性，可以把传参存在对象里以供之后使用。</p><p>一般来说，在Python里一定要明了：一个name在哪里被分配，或者这个name被赋值给了什么对象。</p><p>事实上，__init__函数虽然名字奇怪(wired)，但是它只是一个普通的函数，正如同一般的函数一样，我们能够给它的参数们提供的默认值(default)，这样就可以防止它们的值不可用(unavailable)或者没用(unuseful)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span> <span class="comment"># Normal function args</span></span><br><span class="line">self.name = name</span><br><span class="line">  self.job = job</span><br><span class="line">self.pay = pay</span><br></pre></td></tr></table></figure><h4 id="一边写一边测试"><a href="#一边写一边测试" class="headerlink" title="一边写一边测试"></a>一边写一边测试</h4><blockquote><p>增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件。运用增量模型的软件开发过程是递增式的过程。相对于瀑布模型而言，采用增量模型进行开发，开发人员不需要一次性地把整个软件产品提交给用户，而是可以分批次进行提交。</p></blockquote><p>编程最好以增量模型的形式编程，进行单元测试。</p><p>Python虽然有交互式的测试，但是它是很乏味的：每次都要重新导入模块并且重新输入测试样例。所以Python的交互式提示一般都是用来进行简单的一次性测试的。</p><p>更加实质性的测试：在包含了要测试的对象的文件底部编写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add incremental self-test code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">        </span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>) <span class="comment"># Test the class</span></span><br><span class="line">sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>) <span class="comment"># Runs __init__ automatically</span></span><br><span class="line">print(bob.name, bob.pay) <span class="comment"># Fetch attached attributes</span></span><br><span class="line">print(sue.name, sue.pay) <span class="comment"># sue's and bob's attrs differ</span></span><br></pre></td></tr></table></figure><p>注意到bob用了默认值；而sue在创建对象的时候用到了关键字参数(keyword argument)，当然也可以依靠位置来代替，不过用关键字有两个两个好处：1、关键字能提醒我们这个数据是什么；2、用关键字允许我们不按顺序地输入参数。</p><p>上面那个例子的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; person.py</span><br><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br></pre></td></tr></table></figure><p>从技术上讲，Bob和Sue都是命名空间对象(namespace objects)，就像所有的类实例一样，它们都有自己独立的由类创建的状态信息副本。 因为类的每个实例都有自己的一组self属性，所以类以这种方式自然地记录多个对象的信息; 就像内置类型（如列表和字典）一样，类可以作为一种对象工厂(object factory)。</p><p>上面的测试方法有个很大的缺陷：每次文件作为脚本运行并作为模块导入时，它的top-level print语句都会运行，因此如果我们在导入了这个文件中的这个类，那么每次导入文件时print语句也会跟着文件导入，于是每次导入文件时都会看到测试代码的输出。</p><p>为了克服这个缺陷，我们使用__name__模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: <span class="comment"># When run for testing only</span></span><br><span class="line">    <span class="comment"># self-test code</span></span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob.name, bob.pay)</span><br><span class="line">    print(sue.name, sue.pay)</span><br></pre></td></tr></table></figure><p>上面这个文件作为top-level 脚本运行时，将运行测试语句，因为这时文件的__name__是__main__；</p><p>而当文件作为一个类库(library of classes)被导入到其他文件时，测试语句将不会被运行，因为上面这个文件的__name__并不是__main__：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; person.py</span><br><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">C:\code&gt; python</span><br><span class="line">Python <span class="number">3.3</span><span class="number">.0</span> (v3<span class="number">.3</span><span class="number">.0</span>:bd8afb90ebf2, Sep <span class="number">29</span> <span class="number">2012</span>, <span class="number">10</span>:<span class="number">57</span>:<span class="number">17</span>) ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> person</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="第二步：添加行为方法（Adding-Behavior-Methods）"><a href="#第二步：添加行为方法（Adding-Behavior-Methods）" class="headerlink" title="第二步：添加行为方法（Adding Behavior Methods）"></a>第二步：添加行为方法（Adding Behavior Methods）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Process embedded built-in types: strings, mutability</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob.name, bob.pay)</span><br><span class="line">    print(sue.name, sue.pay)</span><br><span class="line">    print(bob.name.split()[<span class="number">-1</span>]) <span class="comment"># Extract object's last name</span></span><br><span class="line">    sue.pay *= <span class="number">1.10</span> <span class="comment"># Give this object a raise</span></span><br><span class="line">    print(<span class="string">'%.2f'</span> % sue.pay)</span><br></pre></td></tr></table></figure><p>后三行是新加的，当它们运行的时候，我们将bob的姓(last name)提取了出来并通过基本数字操作修改她的薪资属性来支付薪水。某种意义上来说，sue也是一个可变对象，她的状态就像list一样在调用append后一样就地改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line">Smith</span><br><span class="line"><span class="number">110000.00</span></span><br></pre></td></tr></table></figure><p>但是这样子的代码并不是好主意，像这些类以外的（outside of the class）硬编码操作很可能会导致维护问题：当需要改变工作方式或薪酬时，需要搜索并更新每一个事件、修改多个副本等，而这些代码通常是分散的，频繁的变动几乎是必然的。所以我们需要写<strong>方法函数（coding method）</strong></p><hr><p>####编写方法（Coding Methods）</p><p>——<strong>encapsulation(封装)</strong></p><p>​     在接口后面封装操作逻辑，使得每个操作在我们的程序中只编码一次。好处是：分解代码以消除冗余，从而优化可维护性；将operation转换为method可以将它们应用于类的任何实例，而不仅仅是那些被硬编码处理的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add methods to encapsulate operations for maintainability</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.job = job</span><br><span class="line">self.pay = pay</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span> <span class="comment"># Behavior methods</span></span><br><span class="line"><span class="keyword">return</span> self.name.split()[<span class="number">-1</span>] <span class="comment"># self is implied subject</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">self.pay = int(self.pay * (<span class="number">1</span> + percent)) <span class="comment"># Must change here only</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob.name, bob.pay)</span><br><span class="line">    print(sue.name, sue.pay)</span><br><span class="line">    print(bob.lastName(), sue.lastName()) <span class="comment"># Use the new methods</span></span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>) <span class="comment"># instead of hardcoding</span></span><br><span class="line">    print(sue.pay)</span><br></pre></td></tr></table></figure><p>method只是普通的函数，它们附属于类并且被设计用来处理这些类的实例。</p><p>这个instance是调用method的主体(subject)，并被自动传递给method的self参数。</p><p>现在运行时，我们的文件输出与之前类似 - 我们大多只是重构了代码，以允许在未来更轻松地进行更改，而不会改变其行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line">Smith Jones</span><br><span class="line"><span class="number">110000</span></span><br></pre></td></tr></table></figure><p>上例中有些问题：在加薪之后，现在的薪水仍然是一个整数 - 我们通过调用方法内置的int来将数学结果转换为整数，整数和浮点对象具有相同的接口并可在表达式中混合使用。我们可以用<code>round(N,2)</code>来四舍五入并保留cent、使用decimal类型确定精度、或将货币值存储为完整的浮点数并用<code>%.2f</code>或<code>{0:.2f}</code>格式化字符串来表现它们以显示cent。</p><p>formats.py模块中的money函数可以显示逗号，美分和货币符号。</p><p>Python通过自动将实例传递给方法的第一个参数（通常称为self）来告诉方法要处理哪个实例。</p><p>• bob.lastName()，bob是传递给self的隐含主体(implied subject)。<br>• sue.lastName()，sue替换了self。</p><p>最终效果是每一次调用，方法都获取了隐含主体(implied subject)的名(name).（The net effect is that the method fetches the name of the implied subject each time）</p><p>此外，例中的<code>giveRaisse</code>方法假定了<code>percent</code>是以0到1之间的浮点数的形式传进来的，这个假设健壮性太差(1000%的加薪也不是没可能，但是1000%是10，输进去就是BUG了)。因此要注意考虑函数参数实际可能的范围。在后面的章节中会用到函数装饰器(function decorator)和断言(assert)语句，它们能够在开发过程中自动进行有效性测试。(顺带一提，单元测试也用到了assert)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@rangetest(percent=(0.0, 1.0)) # Use decorator to validate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br></pre></td></tr></table></figure><hr><h3 id="第三步：操作器重载"><a href="#第三步：操作器重载" class="headerlink" title="第三步：操作器重载"></a>第三步：操作器重载</h3><p>现在，我们有一个相当全面的类来生成和初始化实例，以及以method形式处理instance的两个新behavior。</p><p>尽管如此，测试仍然不方便：为了跟踪我们的对象，我们必须手动获取并打印各个属性(individual attributes)。不幸的是，实例对象的默认显示格式不是很好——它显示对象的类名和内存地址（除了作为唯一标识符外，它在Python中基本上是无用的）。</p><p>把脚本的最后一行改成<code>print(sue)</code>以便将对象表现为一个整体，于是我们将看到：<code>sue</code>是3.X中的“对象(object)”，是2.X中的“实例(instance)”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line">Smith Jones</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x00000000029A0668</span>&gt;</span><br></pre></td></tr></table></figure><p>####提供打印显示</p><p>使用操作器重载能做得更好——在一个类里编写方法，这些方法能够在运行类的实例时，截取(intercept)和处理(process)内置操作。</p><p>具体而言，我们可以利用Python中仅次于__init__的第二个最常用的运算符重载方法：__repr__方法和__str__方法。</p><p>每当一个实例被转换成它的打印字符串（就是<code>&lt;__main__.Person object at 0x00000000029A0668&gt;</code>这种形式的）时，__repr__方法和__str__方法会被自动运行。</p><p>因为这就是打印一个对象所做的事情，所以，如果该对象定义了一个对象自身(defines one itself)，或者继承了一个超类的话，那么净传递效果(the net transitive effect)是打印这个对象，这个对象会显示这个对象的__str__或__repr__方法返回的内容（无论返回了什么）。此外，双下划线名称将如同任何其他名称一样被继承。</p><p>（Because that’s what printing an object does, the net transitive effect is that printing an object displays whatever is returned by the object’s __str__ or __repr__ method, if the object either defines one itself or inherits one from a superclass. Double-underscored names are inherited just like any other.）</p><p>从技术上说，<code>__str__</code>优于<code>print</code>和<code>str</code>，并且<code>__repr__</code>被用作这些函数(<code>__str__</code>、<code>print</code>、<code>str</code>)以及所有其他上下文(context，译成”运行环境”会好点？)的备用(fallback)。虽然<code>__str__</code>和<code>__repr__</code>二者都可以用于在不同的context中实现不同的显示，但仅编写<code>__repr__</code>就足以在所有情况下给出单独的显示——打印、嵌套外观和交互式反馈(interactive echoes)。而<code>__str__</code>只有在有限的文章里才可以被用来作为替代显示（an alternative display）。</p><p>我们已经编写的<code>__init__</code>构造函数方法严格来说也是操作符重载 - 它在构造时自动运行以初始化新创建的实例。 然而，构造函数非常普遍，这使得构造函数看起来几乎像一个特例。 像<code>__repr__</code>这样目标更明确(focused)的方法允许我们利用特定的操作并在我们的对象用于这些context时提供专门的行为(specialized behavior)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add __repr__ overload method for printing objects</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">    self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span> <span class="comment"># Added method</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)  <span class="comment"># String to print</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob)</span><br><span class="line">    print(sue)</span><br><span class="line">    print(bob.lastName(), sue.lastName())</span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(sue)</span><br></pre></td></tr></table></figure><p>注意，这里用了字符串的<code>%</code>格式化去构建在<code>__repr__</code>中的显示字符串。在底层，类会使用类似的build-in type objects and operations 去完成任务。在很大程度上，类只是添加了一个将功能和数据打包在一起并支持扩展的额外结构层(an additional layer of <em>structure</em>)。  </p><p>本例还改变了我们的自测代码(self-test code)去直接输出整个对象，而不是打印个别属性。 运行时，输出(output)现在变得更加的连贯以及有意义; “[…]”行由我们的新<code>__repr__</code>返回，由<code>print</code>操作自动运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: Sue Jones, <span class="number">110000</span>]</span><br></pre></td></tr></table></figure><p><strong>这样，利用对<code>__repr__</code>方法的重载，我们在别的文件中就能直接通过<code>print(ObjectName)</code>来获得对象的attribute。</strong></p><p>设计注意事项：<code>__repr__</code>方法经常用于在提供一个代码的低级别对象显示，而<code>__str__</code>则用于更多user-friendly的信息显示。 有时类用<code>__str__</code>为用户友好的显示提供，用<code>__repr__</code>为开发人员提供额外的详细信息。 因为<code>print</code> 调用<code>__str__</code>，而交互式提示与<code>__repr__</code>相呼应，所以这可以为目标受众(target audiences)提供适当的显示。<br>由于<code>__repr__</code>适用于更多的展示案例，包括嵌套外表，并且由于我们对显示两种不同格式不感兴趣，因此全面的<code>__repr__</code>足以满足我们的课程。</p><hr><h3 id="第四步：用子类自定义行为-Customizing-Behavior-by-Subclassing"><a href="#第四步：用子类自定义行为-Customizing-Behavior-by-Subclassing" class="headerlink" title="第四步：用子类自定义行为(Customizing Behavior by Subclassing)"></a>第四步：用子类自定义行为(Customizing Behavior by Subclassing)</h3><p>现在这个类尚未用到的唯一一个OOP的主要概念是使用继承的自定义(customization by inheritance)。</p><p>我们将定义一个父类/子类(superclass/subclass)关系，它允许扩展这个软件并将一些行为替换为继承行为。</p><p>####编写子类</p><p>定义一个<code>Person</code>的子类:<code>Manager</code>，<code>Manager</code>用一个更有针对性的版本来替换被继承的<code>giveRaise</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span> <span class="comment"># Define a subclass of Person</span></span><br></pre></td></tr></table></figure><p>格式为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subclass</span><span class="params">(superclass)</span>:</span> <span class="comment"># Define a subclass of Person</span></span><br></pre></td></tr></table></figure><p>According to the inheritance search rules, the lowest version of the name wins：采用最低级别（父子关系中最低级别）的函数(跟Java一样)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span> <span class="comment"># Inherit Person attrs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span> <span class="comment"># Redefine to customize</span></span><br></pre></td></tr></table></figure><p>下面是一个糟糕的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">self.pay = int(self.pay * (<span class="number">1</span> + percent + bonus)) <span class="comment"># Bad: cut and paste</span></span><br></pre></td></tr></table></figure><p>这个例子中的函数内容仅仅是从父类中复制粘贴而来的。这与原来的运行结果一模一样，但是维护难度却加倍了了——比如要针对所有人员都修改提薪的方式(算法)，我们不仅需要修改父类，还要修改子类，这使得维护的工作量加倍了。</p><p>好的例子应当是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">Person.giveRaise(self, percent + bonus) <span class="comment"># Good: augment original</span></span><br></pre></td></tr></table></figure><p>直接调用父类中的函数，那么要针对所有人员都修改提薪的方式(算法)时，直接修改父类中的函数就可以了。</p><p>一个类的方法总是可以被实例调用（常见，Python通常会自动将实例发送到<code>self</code>变量）或者被类调用（不常见，必须手动传递该实例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.method(args...)</span><br></pre></td></tr></table></figure><p>会被Python自动转换成等价的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>.<span class="title">method</span><span class="params">(instance, args...)</span></span></span><br></pre></td></tr></table></figure><p>通过类直接调用会严重地破坏继承，并且将调用级别在类树(class tree)提高了——为了运行一个特别的版本。在我们的例子中，我们可以使用这种技术在Person中调用默认的<code>GiveRaise</code>，尽管它已经在 Manager 级别上重新定义了。</p><p>在某种意义上，我们必须通过Person调用，因为Manager的 <code>giveRaise</code> 代码中的<code>self.giveRaise()</code>会循环——因为 self 已经是 Manager，<code>self.giveRaise()</code>会再次解析为<code>Manager.giveRaise</code>，等等如此递归直到可用内存耗尽。</p><p>（如果<code>Person.giveRaise</code>改成<code>self.giveRaise</code>那么就会出现： self.giveRaise(args…)  –&gt; Manager.giveRaise(self,args…) –&gt; self.giveRaise(self,args…) –&gt; ……）</p><p>这种写法保证了我们想要能够执行标准的GiveRaise操作，只是做了一些额外的添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add customization of one behavior in a subclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">    self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span> <span class="comment"># Redefine at this level</span></span><br><span class="line">Person.giveRaise(self, percent + bonus) <span class="comment"># Call Person's version</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob)</span><br><span class="line">    print(sue)</span><br><span class="line">    print(bob.lastName(), sue.lastName())</span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(sue)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="string">'mgr'</span>, <span class="number">50000</span>) <span class="comment"># Make a Manager: __init__</span></span><br><span class="line">    tom.giveRaise(<span class="number">.10</span>) <span class="comment"># Runs custom version</span></span><br><span class="line">    print(tom.lastName()) <span class="comment"># Runs inherited method</span></span><br><span class="line">    print(tom) <span class="comment"># Runs inherited __repr__</span></span><br></pre></td></tr></table></figure><p>说白了跟Java里的继承一样。</p><p>Java程序员可能特别感兴趣的是知道Python也有一个super内置函数，允许更一般地回调父类的方法 。但是继承父类有很多缺点，因此使用要谨慎：一旦你继续进行多重继承，它不是你想象的那样，甚至超出了你所认为的范围。它所调用的类可能根本不是父类，甚至可能根据context而不同。或者改述一句电影台词：Python的父类就像一盒巧克力——你永远不知道你会得到什么！</p><p>####行为的多态性</p><p>为了使这种对继承行为的捕获(acquisition of inherited behavior)更加清晰，我们可以在我们的文件末尾添加以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ...</span><br><span class="line">    print(<span class="string">'--All three--'</span>)</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> (bob, sue, tom):<span class="comment"># Process objects generically</span></span><br><span class="line">        obj.giveRaise(<span class="number">.10</span>)    <span class="comment"># Run this object's giveRaise</span></span><br><span class="line">        print(obj)   <span class="comment"># Run the common __repr__</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: Sue Jones, <span class="number">110000</span>]</span><br><span class="line">Jones</span><br><span class="line">[Person: Tom Jones, <span class="number">60000</span>]</span><br><span class="line">--All three--</span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">121000</span>]</span><br><span class="line">[Person: Tom Jones, <span class="number">72000</span>]</span><br></pre></td></tr></table></figure><p>在添加的代码中，object是一个Person或者一个Manager，Python自动运行相应的<code>giveRaise</code>，<code>giveRaise</code>是根据对象的类型分派的。正如我们所知，多态性是Python灵活性的核心。</p><p>另一方面，打印针对所有三个对象运行相同的<code>__repr__</code>，因为它只在Person中编码一次（Person）,而Manager负责的是特化和应用(specialize and apply)我们原先写在Person上的代码。虽然这个例子很小，但它已经利用OOP的定制和重用代码的天赋;有了类，这几乎像是自动的。</p><p>####继承，定制以及拓展(Inherit, Customize, and Extend)</p><p>事实上，类可能比我们的例子更灵活。 通常，类可以inherit，customize或extend超类中的现有代码。 例如，尽管我们专注于customize，但如果Manager需要完全不同的东西（Python同名引用，Python namesake reference intended），我们还可以向Manager中添加不存在于Person中的特有(unique)方法。 在下例中，<code>giveRaise</code>重新定义了一个超类的方法来定制它，但是<code>someThingElse</code>定义了一些新的扩展方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span>    <span class="comment"># Inherit</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, ...)</span>:</span> ... <span class="comment"># Customize</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">someThingElse</span><span class="params">(self, ...)</span>:</span> ... <span class="comment"># Extend</span></span><br><span class="line">        </span><br><span class="line">tom = Manager()</span><br><span class="line">tom.lastName() <span class="comment"># Inherited verbatim</span></span><br><span class="line">tom.giveRaise() <span class="comment"># Customized version</span></span><br><span class="line">tom.someThingElse() <span class="comment"># Extension here</span></span><br><span class="line">print(tom) <span class="comment"># Inherited overload method</span></span><br></pre></td></tr></table></figure><p><code>someThingElse</code>中定制的方法只能用被Manager类的对象使用，而对于非Manager的Person类对象来说是不能使用<code>someThingElse</code>的。</p><p>####面向对象编程的主要观念(OOP: The Big Idea)</p><p>我们通过自定义已完成的内容进行编程，而不是复制或更改现有代码。总的来说，与其他方法相比，类所隐含的编程风格可以从根本上缩短开发时间。</p><p>例如，在上面的例子中，理论上可以不需要子类化就实现一个自定义的<code>giveRaise</code>操作，但是其他选项产生的代码都不够优化：<br>​    •虽然我们可以简单地将Manager从头开始编码为新的独立代码，但我们必须重新实现Person中与Managers相同的所有行为。<br>​    •虽然我们可以简单地改变现有的Person 类，以满足Manager给予的要求，但这样做可能会破坏我们仍然需要原始Person behavior的地方。<br>​    •尽管我们可以简单地复制Person类的全部内容，将副本更名为Manager，并更改了<code>GiveRaise</code>，但这样做会导致代码冗余，从而加倍我们未来的工作量——将来对Person所做的更改不会被Manager自动pick up，而是必须手动传递(propagated)到Manager的代码里。复制粘贴方法现在看起来可能很快，但它将来会使您的工作翻倍。</p><p>用类构建的可定制层次结构(customizable hierarchies)为随着时间推移而发展的软件提供了更好的解决方案。 Python中没有其他工具支持这种开发模式。因为我们可以通过编写新的子类来定制和扩展(tailor and extend)我们之前的工作，所以我们可以利用我们已经完成的工作，而不是每次从头开始，打破已有的工作，或者引入多个在将来可能需要更新的代码副本。如果用得好，OOP是程序员的一个强大盟友。</p><hr><h3 id="第五步：自定义构造函数-Customizing-Constructors-Too"><a href="#第五步：自定义构造函数-Customizing-Constructors-Too" class="headerlink" title="第五步：自定义构造函数(Customizing Constructors, Too)"></a>第五步：自定义构造函数(Customizing Constructors, Too)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person.py</span></span><br><span class="line"><span class="comment"># Add customization of constructor in a subclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.job = job</span><br><span class="line">self.pay = pay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">    self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span> <span class="comment"># Redefine constructor</span></span><br><span class="line">Person.__init__(self, name, <span class="string">'mgr'</span>, pay)  <span class="comment"># Run original with 'mgr'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">Person.giveRaise(self, percent + bonus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob)</span><br><span class="line">    print(sue)</span><br><span class="line">    print(bob.lastName(), sue.lastName())</span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(sue)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)  <span class="comment"># Job name not needed:</span></span><br><span class="line">    tom.giveRaise(<span class="number">.10</span>)     <span class="comment"># Implied/set by class</span></span><br><span class="line">    print(tom.lastName())</span><br><span class="line">    print(tom)</span><br></pre></td></tr></table></figure><p>子类中定制构造函数</p><p>虽然构造函数有一个奇怪的名字，但效果是一样的。因为我们也需要Person的构建逻辑来运行（初始化实例属性），所以我们必须这样调用它;否则，实例不会附加任何属性。</p><p>从重定义(redefine)中调用超类的构造函数，这种方式证明是Python中常见的编码模式。Python使用继承来查找并在构造时只调用类树中最底层的那个<code>__init__</code>方法。如果你需要更高级的<code>__init__</code>方法在构造时运行（通常你会这样做），你必须手动调用它们，一般是通过超类的名字来调用它们。这样做的好处是可以清楚地知道将哪个参数传递给超类的构造函数，并且可以选择根本不调用它：不调用超类构造函数可以让你完全替代它的逻辑，而不是增强它。<br>这个文件的自测代码的输出和以前一样 - 我们没有改变它的功能，我们只是简单地重组来消除一些逻辑冗余：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: Sue Jones, <span class="number">110000</span>]</span><br><span class="line">Jones</span><br><span class="line">[Person: Tom Jones, <span class="number">60000</span>]</span><br></pre></td></tr></table></figure><p>####面向对象编程比你想象的更加简单(OOP Is Simpler Than You May Think)</p><p>本章到这里已经介绍了Python 中OOP机制(machinery)的所有重要概念:</p><p>·创建实例——填写实例属性</p><p>·行为方法——将逻辑封装在类的方法中</p><p>·操作重载——为内置操作（如print）提供行为</p><p>·定制行为——在子类中重新定义方法以对它们进行专门化</p><p>·定制构造器—为超类步骤添加初始化逻辑</p><p><em>**</em>注意：重载和定制看着很像（都是改变既定方法），但是在概念上有所区别</p><p>这些概念大多基于三个简单的观点：对象树中属性的继承搜索(the inheritance search<br>for attributes in object trees)；方法中特别的self变量；操作重载对方法的自动调度(dispatch)。</p><p>我们还通过利用(harnessing)类的分解代码倾向(propensity for factoring code)来减少冗余(redundancy)，使我们的代码在将来更易于更改。例如，我们在方法中封装了逻辑，并从扩展中调用回超类方法，以避免具有相同代码的多个副本。这些步骤中的大部分都是阶级结构化力量的自然结果。<br>总的来说，这就是Python中的OOP。类肯定会变得比这更大，并且还有一些更高级的类概念，比如装饰器(decorators)和元类(metaclasses)，我们将在后面的章节中讨论这些概念。然而，就基础知识而言，我们的课程已经完成了这一切。事实上，如果你已经掌握了我们编写的类的工作方式，那么大多数OOP Python代码现在应该在你的范围之内。</p><p>####组合类的其他方式(Other Ways to Combine Classes)</p><p>虽然OOP的基本机制在Python中很简单，但在较大程序中，将类放在一起的方式也是一种艺术。此前我们关注继承，是因为它是Python提供的机制，但是也有其他方式来组合class。</p><p>例如，有一种常见的编码模式，就涉及到将对象嵌套在一起以构建组合(composite)。这更多是与设计有关而非与Python。作为一个简单的例子，我们可以通过嵌入一个Person(而非继承)来使用这个组合思想，从而拓展Manager。</p><p>下面的代码在文件person-composite.py中编码，通过使用<code>__getattr__</code>操作的重载方法来拦截未定义的属性提取(attribute fetches)，并用内置的getattr将它们交给嵌入对象。 通过getattr调用获取属性与通过  “X.Y” 形式(如 Tom.job)获取属性相同，并且因此表现出继承，区别在于属性名称Y是一个运行时字符串(runtime string)。<br>通过结合这些工具，这里的giveRaise方法仍然通过改变传递给嵌入对象的参数来实现定制。实际上，Manager成为一个控制层，将调用传递给(down to)嵌入对象，而不是超类方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person-composite.py</span></span><br><span class="line"><span class="comment"># Embedding-based Manager alternative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">...same...</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span></span><br><span class="line">    self.person = Person(name, <span class="string">'mgr'</span>, pay) <span class="comment"># Embed a Person object</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">    self.person.giveRaise(percent + bonus) <span class="comment"># Intercept and delegate</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> getattr(self.person, attr)    <span class="comment"># Delegate all other attrs</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(self.person)   <span class="comment"># Must overload again (in 3.X)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">...same...</span><br></pre></td></tr></table></figure><p>这个Manager替代方案代表了一种通常称为<strong>委托(delegation)</strong>的通用编码模式——一种基于组合的结构，用于管理被包装的对象(wrapped object)并向其发送(propagate)方法调用。</p><p>这个模式适用于我们的例子，但它需要大约两倍的代码，并且对于我们想要直接表达的直接自定义类型而言，不如继承合适(is less well suited than inheritance to the kinds of direct customizations we meant to express)。</p><p>在这里，Manager并不是真正的Person，所以我们需要用额外的代码来手动将方法调用分发给嵌入对象；运算符重载方法（如<code>__repr__</code>）必须重新定义；并且添加新的管理器行为并不那么直接，因为状态信息被删除了一个级别。</p><p>尽管如此，当嵌入对象需要与容器进行比direct customization所表明的交互更有限的交互时，对象嵌入(object embedding)和基于对象嵌入的设计模式(design patterns)能够很好地吻合。</p><p> 例如，如果我们想要将类适应到它不支持的预期接口，或者跟踪或验证对另一个对象方法的调用，那么像这样的控制器层或代理(controller layer or proxy)可能会派上用场。</p><p>此外，假设的Department类可以聚合(aggregate)其他对象，以便将它们作为一组来处理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person-department.py</span></span><br><span class="line"><span class="comment"># Aggregate embedded objects into a composite</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">...same...</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">...same...</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">    self.members = list(args)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addMember</span><span class="params">(self, person)</span>:</span></span><br><span class="line">    self.members.append(person)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaises</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> person <span class="keyword">in</span> self.members:</span><br><span class="line">    person.giveRaise(percent)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showAll</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> person <span class="keyword">in</span> self.members:</span><br><span class="line">print(person)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line">    </span><br><span class="line">    development = Department(bob, sue) <span class="comment"># Embed objects in a composite</span></span><br><span class="line">    development.addMember(tom)</span><br><span class="line">    development.giveRaises(<span class="number">.10</span>) <span class="comment"># Runs embedded objects' giveRaise</span></span><br><span class="line">    development.showAll() <span class="comment"># Runs embedded objects' __repr__</span></span><br></pre></td></tr></table></figure><p>运行时，Department的<code>showAll</code>方法能够列出当前状态下部门中所有人的信息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">110000</span>]</span><br><span class="line">[Person: Tom Jones, <span class="number">60000</span>]</span><br></pre></td></tr></table></figure><p>在Python 3.X中，以及在启用3.X的“new style”类的2.X中时，我们在本章编写的文件person-composite.py的另一个基于委托(delegation-based)的Manager类，如果不重新定义运算符的重载方法属性，将不能够 拦截并委托(intercept and delegate) 运算符的重载方法属性(operator<br>overloading method attributes)（如<code>__repr__</code>）。虽然我们知道<code>__repr__</code>是我们具体示例中唯一使用的名称，但这对于基于委托的类来说是一个普遍问题。</p><p>回想一下，诸如打印和添加等内置操作隐式地调用操作符重载方法，如<code>__repr__</code>和<code>__add__</code>。在3.X的新样式类(new-style classes)中，像这样的内置操作不会通过通用属性管理器(generic attribute manager)来路由(route)它们的隐式属性提取：既不调用<code>__getattr__</code>（运行未定义的属性）也不调用<code>__getattribute__</code>（针对所有属性运行）。这就是为什么我们必须在替代管理器中重新定义<code>__repr__</code>以确保将打印路由到3.X中的嵌入式Person对象。</p><p>在上上个例子中注释掉<code>__repr__</code>方法，输出变成了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c:\code&gt; py −<span class="number">3</span> person-composite.py</span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">...etc...</span><br><span class="line">&lt;__main__.Manager object at <span class="number">0x00000000029AA8D0</span>&gt;</span><br><span class="line"></span><br><span class="line">c:\code&gt; py −<span class="number">2</span> person-composite.py</span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">...etc...</span><br><span class="line">[Person: Tom Jones, <span class="number">60000</span>]</span><br></pre></td></tr></table></figure><p>从技术上讲，这是因为内置操作在2.X的默认经典类中开始隐式搜索实例中的方法名称，但从3.X强制的new-style classes开始，完全跳过实例。相比之下，显式的名称属性提取总是首先在两个模型中路由到实例。在2.X经典类中，内置路由属性也是这种方式——打印，例如，路由<code>__repr__</code>到<code>__getattr__</code>。这就是为什么对Manager作注释的<code>__repr__</code>在2.X中没有效果：该调用委托给了Person。new-style classes也从它们的自动对象(automatic object)的超类中继承了<code>__repr__</code>的默认值，这会阻止<code>__getattr__</code>，但new-style的<code>__getattribute__</code>不会拦截该名称。</p><hr><h3 id="第六步：使用自检工具-Using-Introspection-Tools"><a href="#第六步：使用自检工具-Using-Introspection-Tools" class="headerlink" title="第六步：使用自检工具(Using Introspection Tools)"></a>第六步：使用自检工具(Using Introspection Tools)</h3><p>现在我们完成并演示了Python OOP的大部分基础。但是还有一点小问题：</p><p>·第一，print(Tom)出来的是Person而非更具体的Manager，从技术上来说这是不对的：不够精确。</p><p>·第二，也是更重要的：当前的显示格式只显示了我们在<code>__repr__</code>中包含的属性，这对拓展是不利的，或许解释不了未来的目标。例如，我们还不能验证tom的job名称是否已由Manager的构造函数正确设置为mgr，因为我们为Person编码的<code>__repr__</code>不打印此字段。 更糟糕的是，如果我们在<code>__init__</code>中扩展或以其他方式更改分配给我们对象的一组属性，我们必须记住还要更新<code>__repr__</code>以显示新名称，否则随着时间的推移它会变得不同步。</p><p>最后一点意味着，我们再次通过在代码中引入冗余来为自己做出潜在的额外工作。 因为<code>__repr__</code>中的任何差异都会反映在程序的输出中，所以这种冗余可能比我们之前提到的其他形式更明显; 仍然，避免未来额外的工作通常是一件好事。</p><p>####特殊的类属性</p><p>这些问题我们可以用Python的内检工具来解决，这些工具有特殊的属性和函数，可以访问对象实现(objects’ implementations)的内部。这些工具有些高级，通常用于编写其他程序员使用的工具，而不是用作程序员开发应用程序时使用的工具。</p><p>·内置的 <code>instance.__class__</code>属性提供了从instance到创建这个实例的class的链接。类像模块一样有一个<code>__name__</code>，以及一个用于提供超类访问的<code>__bases__</code>队列，我们可以在这里使用它们（而不是我们自己硬编码出来的代码）来打印创建实例的类的名称。</p><p>·内置的<code>object.__dict__</code>属性为附加到名称空间对象的每个属性提供一个包含一个键/值对的字典（包括模块，类和实例）。 因为它是一个字典，所以我们可以获取它的键列表(fetch its key list)，按键索引(index by key)，遍历键(iterate over its keys)等等，来通用地处理所有属性。 我们可以在这里使用它来打印任何实例中的所有属性，而不仅仅是我们在自定义显示中进行硬编码的属性。</p><p>对上面二者的快速回顾（注意：如何在交互式提示符下使用from语句加载Person——类名称存在并从模块中导入，与函数名称和其他变量完全相同）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> person <span class="keyword">import</span> Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob <span class="comment"># Show bob's __repr__ (not __str__)</span></span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(bob)  <span class="comment"># Ditto: print =&gt; __str__ or __repr__</span></span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob.__class__   <span class="comment"># Show bob's class and its name</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">person</span>.<span class="title">Person</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">bob</span>.<span class="title">__class__</span>.<span class="title">__name__</span></span></span><br><span class="line"><span class="class">'<span class="title">Person</span>'</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">list</span><span class="params">(bob.__dict__.keys<span class="params">()</span>)</span>   # <span class="title">Attributes</span> <span class="title">are</span> <span class="title">really</span> <span class="title">dict</span> <span class="title">keys</span></span></span><br><span class="line">['pay', 'job', 'name']   # Use list to force list in 3.X</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line">print(key, <span class="string">'=&gt;'</span>, bob.__dict__[key]) <span class="comment"># Index manually</span></span><br><span class="line">pay =&gt; 0</span><br><span class="line">job =&gt; None</span><br><span class="line">name =&gt; Bob Smith</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line">print(key, <span class="string">'=&gt;'</span>, getattr(bob, key)) <span class="comment"># == obj.attr  (but attr is a var)</span></span><br><span class="line">pay =&gt; 0</span><br><span class="line">job =&gt; None</span><br><span class="line">name =&gt; Bob Smith</span><br></pre></td></tr></table></figure><p>如果实例的类定义了<code>__slots__</code>，那么可以从实例访问的某些属性可能不会存储在<code>__dict__</code>字典中：比如说，new-style classes的可选且相对模糊的特征（因此包括了Python 3.X中的所有类）在实例中有序地存储了属性;可能完全排除实例<code>__dict__</code>。由于<strong>插槽(slot)</strong>实际上属于类而不是实例，并且由于它们在任何情况下都很少使用，所以我们可以在这里合理地忽略它们，并将注意力集中在正常的<code>__dict__</code>上。</p><p>但是，正如我们所做的那样，请记住，某些程序可能需要为缺少的<code>__dict__</code>捕获异常，或者如果用户可能会部署插槽，则使用<code>hasattr</code>来测试或<code>getattr</code>以及默认值。下一节的代码如果被带有插槽的类使用（如果它缺乏插槽，那么<code>__dict__</code>的存在是可以保证的），它不会fail，但插槽和其他“虚拟”属性不会作为实例数据报告。</p><p>####一个通用显示工具</p><p>我们可以将这些接口(interface)用在显示准确类名的超类中，并格式化任何类(any class)的实例的所有属性。下面的例子中，因为<code>__repr__</code>的显示重载使用了通用自检工具，所以它将在任何实例上工作，而不管实例的属性如何设置。</p><p>因为这是一个类，它会自动成为一个通用的格式化工具：由于继承，它可以加入到任何希望使用其显示格式的类中。 还有一个额外的好处，如果我们想要改变实例的显示方式，我们只需要改变这个类，因为继承它的<code>__repr__</code>的每个类在下次运行时都会自动选择新的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File classtools.py (new)</span></span><br><span class="line"><span class="string">"Assorted class utilities and tools"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrDisplay</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Provides an inheritable display overload method that shows</span></span><br><span class="line"><span class="string">    instances with their class names and a name=value pair for</span></span><br><span class="line"><span class="string">    each attribute stored on the instance itself (but not attrs</span></span><br><span class="line"><span class="string">    inherited from its classes). Can be mixed into any class,</span></span><br><span class="line"><span class="string">    and will work on any instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gatherAttrs</span><span class="params">(self)</span>:</span></span><br><span class="line">        attrs = []</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> sorted(self.__dict__):</span><br><span class="line">        attrs.append(<span class="string">'%s=%s'</span> % (key, getattr(self, key)))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">', '</span>.join(attrs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[%s: %s]'</span> % (self.__class__.__name__, self.gatherAttrs())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TopTest</span><span class="params">(AttrDisplay)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">            self.attr1 = TopTest.count</span><br><span class="line">            self.attr2 = TopTest.count+<span class="number">1</span></span><br><span class="line">            TopTest.count += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SubTest</span><span class="params">(TopTest)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    X, Y = TopTest(), SubTest()<span class="comment"># Make two instances</span></span><br><span class="line">    print(X)    <span class="comment"># Show all instance attrs</span></span><br><span class="line">    print(Y)   <span class="comment"># Show lowest class name</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[TopTest: attr1=<span class="number">0</span>, attr2=<span class="number">1</span>]</span><br><span class="line">[SubTest: attr1=<span class="number">2</span>, attr2=<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>把<code>X, Y = TopTest(), SubTest()</code>换成<code>X, Y = SubTest(), TopTest()</code>输出变成了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SubTest: attr1=<span class="number">0</span>, attr2=<span class="number">1</span>]</span><br><span class="line">[TopTest: attr1=<span class="number">2</span>, attr2=<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>(类型自身的属性被改变：每次创建一个新的<code>TopTest</code>类或者其子类实例，<code>TopTest</code>这个类自身的属性都被改变(count += 2)，并且这个改变是保留效果的，这是因为<code>TopTest</code>作为类本身也是一个对象，利用<code>TopTest</code>生成实例对象，其实也是调用了<code>TopTest</code>这个类的对象来生成新的实例的，调用过程中<code>TopTest</code>这个类的属性被改变了，而作为一个既有对象，在作用域内它的属性改变效果是保留的。)</p><p>↑类属性</p><p>####实例与类属性的比较(Instance Versus Class Attributes)</p><p>由于类被附加到继承树底部的self对象上，因此类只显示实例属性—— self 的 <code>__dict__</code>属性所包含的东西，而没有实例从类树中较上层的类继承的属性（例如，计算此文件的自检代码——用作实例计数器的类属性）。继承的类属性仅附加到类，不会复制到实例。</p><p>如果您希望也包含继承属性，您可以爬上(climb)实例类的<code>__class__</code>链接，使用<code>__dict__</code>获取类属性，然后遍历(iterate through)该类的<code>__bases__</code>属性以爬到更高的超类，并根据需要重复。如果你喜欢简单代码，在实例上运行一个内置的<code>dir</code>调用(而非<code>__dict__</code>)会产生和climb相同的效果，因为<code>dir</code>结果在排序结果列表中包含了继承名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> person <span class="keyword">import</span> Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(bob.__dict__.keys()) <span class="comment"># 3.X keys is a view, not a list</span></span><br><span class="line">[<span class="string">'name'</span>, <span class="string">'job'</span>, <span class="string">'pay'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(bob) <span class="comment"># 3.X includes class type methods</span></span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>,</span><br><span class="line"><span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>,</span><br><span class="line">...more omitted: <span class="number">31</span> attrs...</span><br><span class="line"><span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>,</span><br><span class="line"><span class="string">'giveRaise'</span>, <span class="string">'job'</span>, <span class="string">'lastName'</span>, <span class="string">'name'</span>, <span class="string">'pay'</span>]</span><br></pre></td></tr></table></figure><p>(回顾： 过滤掉带有双下划线的元素：)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dir(bob))</span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(name <span class="keyword">for</span> name <span class="keyword">in</span> dir(bob) <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>))</span><br><span class="line">[<span class="string">'giveRaise'</span>, <span class="string">'job'</span>, <span class="string">'lastName'</span>, <span class="string">'name'</span>, <span class="string">'pay'</span>]</span><br></pre></td></tr></table></figure><p>####工具类中的名称注意事项</p><p>最后一个细节,因为<code>classtools</code>模块中的<code>AttrDisplay</code>类是一个通用工具，可以混合到其他任意类中，所以我们必须意识到与客户端类发生意外名称冲突的可能性。 假设客户端子类可能要同时使用它的<code>__repr__</code>和<code>gatherAttrs</code>，但后者可能不仅仅是子类所期望的 - 如果子类无意中定义了它自己的收集<code>Attrs</code>名称，它可能会中断我们的类，因为在子类中的较低版本将被使用，而不是我们的.</p><p>在文件的自测代码中向<code>TopTest</code>添加<code>gatherAttrs</code>; 除非新方法是相同的，或者有意定制原始方法，否则我们的工具类将不再按计划工作——<code>AttrDisplay</code>中的<code>self.gatherAttrs</code>会从<code>TopTest</code>实例重新搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopTest</span><span class="params">(AttrDisplay)</span>:</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gatherAttrs</span><span class="params">(self)</span>:</span> <span class="comment"># Replaces method in AttrDisplay!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Spam'</span></span><br></pre></td></tr></table></figure><p>这不一定是坏的 - 有时我们希望其他方法可用于子类，无论是直接调用还是用这种方式定制。 但是，如果我们真的只想提供一个<code>__repr__</code>，这并不理想。</p><p>为了尽量减少这种名称冲突的可能性，Python程序员通常在名称外部使用添加一个前缀下划线的方法：<code>_gatherAttrs</code>。这不是万无一失的（如果另一个类也定义了<code>_gatherAttrs</code>），但它通常是足够的，并且它是Python类的内部方法常见的命名约定。</p><p>一个更好的但不常用的解决方案是在方法名前面使用两个下划线：<code>__gatherAttrs</code>给我们。</p><p>Python自动扩展这些名称来包含封闭类的名称，这使得它们在通过继承搜索查找时真正具有唯一性， 这是一个通常称为伪类属性的功能。</p><p>####类的最终形式(Our Classes’ Final Form)</p><p>现在，为了在我们的类中使用这个通用工具，我们需要做的就是从它的模块中导入它，并通过在我们的顶级类中继承来mix它，并且摆脱我们之前编码得更具体的<code>__repr__</code>。 新的重载显示方法将由Person和Manager的实例来继承; Manager从Person中获取<code>__repr__</code>，它现在从另一个模块中编码的<code>AttrDisplay</code>中获取它。 以下是应用这些更改的我们的person.py文件的最终版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File classtools.py (new)</span></span><br><span class="line">...<span class="keyword">as</span> listed earlier...</span><br><span class="line"></span><br><span class="line"><span class="comment"># File person.py (final)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Record and process information about people.</span></span><br><span class="line"><span class="string">Run this file directly to test its classes.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> classtools <span class="keyword">import</span> AttrDisplay <span class="comment"># Use generic display tool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(AttrDisplay)</span>:</span> <span class="comment"># Mix in a repr at this level</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create and process person records</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span>   <span class="comment"># Assumes last is last</span></span><br><span class="line">    <span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span>    <span class="comment"># Percent must be 0..1</span></span><br><span class="line">    self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A customized Person with special requirements</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span></span><br><span class="line">    Person.__init__(self, name, <span class="string">'mgr'</span>, pay) <span class="comment"># Job name is implied</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">    Person.giveRaise(self, percent + bonus)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob)</span><br><span class="line">    print(sue)</span><br><span class="line">    print(bob.lastName(), sue.lastName())</span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(sue)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line">    tom.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(tom.lastName())</span><br><span class="line">    print(tom)</span><br></pre></td></tr></table></figure><p>由于是最终版，我们添加了一些注释——用于功能性描述的docstrings(“””… …”””)，用于小笔记的#，方法之间的空行——以在类或者方法变得large时增加可读性。</p><p>当我们现在运行这个代码时，我们看到了对象的所有属性，而不仅仅是我们在原始<code>__repr__</code>中硬编码的那些属性。 我们的最终问题得到了解决：因为<code>AttrDisplay</code>直接从自身实例中取出类名，所以每个对象都显示为最接近（最低）的类的名称，现在显示为Manager，而不是Person，最后我们可以验证他的job名称已由Manager构造函数正确填写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; person.py</span><br><span class="line">[Person: job=<span class="keyword">None</span>, name=Bob Smith, pay=<span class="number">0</span>]</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">110000</span>]</span><br><span class="line">Jones</span><br><span class="line">[Manager: job=mgr, name=Tom Jones, pay=<span class="number">60000</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="最终步：在数据库中存储对象-Step-7-Final-Storing-Objects-in-a-Database"><a href="#最终步：在数据库中存储对象-Step-7-Final-Storing-Objects-in-a-Database" class="headerlink" title="最终步：在数据库中存储对象(Step 7 (Final): Storing Objects in a Database)"></a>最终步：在数据库中存储对象(Step 7 (Final): Storing Objects in a Database)</h3><p>现在，我们的工作几乎完成。我们现在有一个双模块系统，它不仅实现了我们的原始设计目标来代表人，还提供了一个通用的属性显示工具，我们可以在将来的其他程序中使用它。通过编写模块文件中的函数和类，我们确保它们自然支持重用。通过将我们的软件编码为类，我们确保它自然支持扩展。<br>尽管我们的类按计划运行，但他们创建的对象并不是真正的数据库记录。也就是说，如果我们关闭Python，我们的实例将会消失——它们是内存中的瞬态对象，不会像文件一样存储在更永久的介质中，所以它们在未来的程序运行中将不可用。事实证明，使实例对象更加永久是件容易的事情，它具有称为对象持久性的Python特性——在创建它们的程序退出后，使对象继续存在。作为本教程的最后一步，让我们使对象成为永久的。</p><p>名词解释：</p><p>储存器pickle : 将任意Python对象序列化为一串字节</p><p>dbm(Database management module) ：实现用于存储字符串的按键存取文件系统</p><p>shelve ：使用其他两个模块通过密钥将Python对象存储在文件上</p><p>####存储器模块(The pickle module)</p><p>pickle模块是一种超常的对象格式化和解格式化工具：在内存中给出了一个几乎任意的Python对象，它都能将对象转换为一串字节，之后这串字节可以用来重建内存中的原始对象。 pickle模块几乎可以处理任何你可以创建的对象——list，dictionary以及它们的嵌套组合和类实例。 后者是特别有用的东西，因为它们提供了数据（属性）和行为（方法）; 实际上，这个组合大致相当于“记录”和“程序”。因为pickle是如此普遍，所以它可以将额外的代码替换掉，或者您可能会编写它来创建和解析对象的自定义文本文件表示(custom text file representations)。 通过将一个对象的pickle字符串存储在一个文件中，可以使其永久持久：只需稍后加载并取消它即可重新创建原始对象。</p><p>####书架模块(The shelve module)</p><p>尽管使用pickle本身很容易将对象存储在简单的平面文件中，并在稍后将其加载，但shelve模块提供了一个额外的结构层，允许您通过键存储pickle的对象。 shelve使用pickle将对象转换为它的pickled字符串，并将该字符串存储在dbm文件中的键下;当稍后加载时，shelve通过键提取pickled字符串，并用pickle在内存中重新创建原始对象。这完全是一个窍门，但是对于你的脚本来说，一个搁置对象的东西看起来就像dictionary——你可以通过索引来获取索引，分配给键来存储，并使用诸如<code>len</code>，<code>in</code>和<code>dict.keys</code>之类的字典工具来获取信息。书架自动将字典操作映射到存储在文件中的对象。<br>实际上，对于您的脚本，shelve和普通dictionary之间唯一的编码区别在于，您必须首先打开shelve，并且在更改后必须关闭它们。<br>最终结果是，shelve提供了一个简单的数据库，用于通过键存储和获取本地Python对象，从而使它们在程序运行期间保持持久性。它不支持诸如SQL之类的查询工具，并且它缺少在企业级数据库中找到的一些高级功能（例如真正的事务处理），但是存储在shelve上的本地Python对象一旦被键取回，可能会被使用Python语言的全部功能进行处理(be processed with the full power of the Python language)。</p><p>####在书架数据库里存储对象(Storing Objects on a Shelve Database)</p><p>现在我们编写一个命名为makedb.py的文件来将类的对象放到shelve里，由于这是一个新文件，因此我们需要导入我们的类以创建一些存储实例。 我们之前使用它来在交互提示中加载一个类，但实际上，与函数和其他变量一样，有两种方法可以从文件加载类（类名与变量类似于any other，并且在这个运行环境中根本不奇怪）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> person  <span class="comment"># Load class with import</span></span><br><span class="line">bob = person.Person(...)  <span class="comment"># Go through module name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person <span class="comment"># Load class with from</span></span><br><span class="line">bob = Person(...)   <span class="comment"># Use name directly</span></span><br></pre></td></tr></table></figure><p>使用<code>from</code>来加载脚本能使得输入变少一点。</p><p>一定有了实例，放在shelve上是很容易的，只需导入shelve模块，使用外部文件名打开一个新shelve，将对象分配给shelve中的键，并在完成后关闭shelve。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File makedb.py: store Person objects on a shelve database</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person, Manager <span class="comment"># Load our classes</span></span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>)    <span class="comment"># Re-create objects to be stored</span></span><br><span class="line">sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.open(<span class="string">'persondb'</span>)  <span class="comment"># Filename where objects are stored</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> (bob, sue, tom):   <span class="comment"># Use object's name attr as key</span></span><br><span class="line">db[obj.name] = obj  <span class="comment"># Store object on shelve by key</span></span><br><span class="line">db.close() <span class="comment"># Close after making changes</span></span><br></pre></td></tr></table></figure><p>将名称作为关键字分配给shelve是要为了方便，事实上，密钥可以是任何字符串，包括我们可能使用工具ID和时间戳（可在OS和时间标准库模块中获得）等工具创建的唯一字符串。唯一的规则是键必须是字符串，并且应该是唯一的，因为我们可以为每个键只存储一个对象，尽管该对象可以是列表字典或其他包含许多对象本身的对象。</p><p>事实上，我们存储在键下的值可以是几乎任何类型的Python对象，如字符串，列表和字典的内置类型，以及用户定义的类实例，以及所有这些和更多的嵌套组合。</p><p>####以交互方式探索书架(Exploring Shelves Interactively)</p><p>此时，当前目录中有一个或多个真实文件，其名称全部以“persondb”开头。创建的实际文件可能因平台而异，与内置的打开函数一样，除非它包含目录路径，否则shelve.open()中的文件名与当前工作目录相关。这些文件无论存储在哪里，都会实现一个包含我们三个Python对象的pickled表示的键控访问文件。不要删除这些文件 - 它们是您的数据库，并且是备份或移动存储时需要复制或传输的文件。</p><p>我们可以从Windows资源管理器或Python shell中查看shelve文件，但它们是二进制散列文件(binary hash files)，并且它们的大部分内容在shelve模块的运行环境之外没有多大意义。</p><p>使用Python 3.X并没有安装额外的软件，我们的数据库存储在三个文件中（在2.X中，它只是一个文件，persondb，因为bsddb扩展模块预装了Python for shelf;在3.X中，bsddb是一个可选的第三方开源插件）。例如，Python的标准库glob模块允许我们在Python代码中获取目录列表来验证这些文件，并且我们可以用文本或二进制模式打开这些文件来探索字符串和字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'person*'</span>)</span><br><span class="line">[<span class="string">'person-composite.py'</span>, <span class="string">'person-department.py'</span>, <span class="string">'person.py'</span>, <span class="string">'person.pyc'</span>,</span><br><span class="line"><span class="string">'persondb.bak'</span>, <span class="string">'persondb.dat'</span>, <span class="string">'persondb.dir'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'persondb.dir'</span>).read())</span><br><span class="line"><span class="string">'Sue Jones'</span>, (<span class="number">512</span>, <span class="number">92</span>)</span><br><span class="line"><span class="string">'Tom Jones'</span>, (<span class="number">1024</span>, <span class="number">91</span>)</span><br><span class="line"><span class="string">'Bob Smith'</span>, (<span class="number">0</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'persondb.dat'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line"><span class="string">b'\x80\x03cperson\nPerson\nq\x00)\x81q\x01&#125;q\x02(X\x03\x00\x00\x00jobq\x03NX\x03\x00</span></span><br><span class="line"><span class="string">...more omitted...</span></span><br></pre></td></tr></table></figure><p>这个内容不是不可能破译，但它在不同的平台上可能有所不同，并且它不是一个易于使用的数据库接口！ 为了更好地验证我们的工作，我们可以编写另一个脚本，或者在交互式提示符下翻找我们的shelve。 因为shelve是包含了Python对象的Python对象，所以我们可以用普通的Python语法和开发模式来处理它们。 在这里，交互式提示有效地成为数据库客户端(database client)：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(<span class="string">'persondb'</span>) <span class="comment"># Reopen the shelve</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(db) <span class="comment"># Three 'records' stored</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(db.keys()) <span class="comment"># keys is the index</span></span><br><span class="line">[<span class="string">'Sue Jones'</span>, <span class="string">'Tom Jones'</span>, <span class="string">'Bob Smith'</span>] <span class="comment"># list() to make a list in 3.X</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = db[<span class="string">'Bob Smith'</span>] <span class="comment"># Fetch bob by key</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob <span class="comment"># Runs __repr__ from AttrDisplay</span></span><br><span class="line">[Person: job=<span class="keyword">None</span>, name=Bob Smith, pay=<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob.lastName() <span class="comment"># Runs lastName from Person</span></span><br><span class="line"><span class="string">'Smith'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> db: <span class="comment"># Iterate, fetch, print</span></span><br><span class="line">print(key, <span class="string">'=&gt;'</span>, db[key])</span><br><span class="line"></span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=100000]</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> sorted(db):</span><br><span class="line">print(key, <span class="string">'=&gt;'</span>, db[key]) <span class="comment"># Iterate by sorted keys</span></span><br><span class="line"></span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=100000]</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br></pre></td></tr></table></figure><p>请注意，我们无需在此处导入我们的Person或Manager类，以加载或使用我们的存储对象。例如，我们可以自由地调用bob的<code>lastName</code>方法，并自动获得自定义的打印显示格式，即使我们在这里没有他的Person类。这是有效的，因为当Python pickle一个类实例时，它会记录它的自身实例属性，以及它所创建的类的名称和类所在的模块。当bob稍后从shelve中取出并取出时，Python会自动重新导入该类并链接到它。这个方案的结果是，类实例在将来被加载时自动获得他们所有的类行为。我们必须导入我们的类才能创建新的实例，而不是处理现有的实例。虽然这是一个故意的特征，但这个方案的后果有点混杂：</p><p>· 缺点是：当实例稍后加载时，类和它们的模块文件必须是可导入的(importable)。更正式地说，pickleable类必须在sys.path模块搜索路径中列出的目录中可访问的模块文件的顶层编码（并且不应该存在于最顶层的脚本文件的模块<code>__main__</code>中，除非它们在使用时始终处于模块中）。由于这种外部模块文件的要求，有些应用程序会选择更简单的对象，例如字典或列表，特别是要通过Internet传输时。</p><p>· 优点是：类的源代码文件中的更改会在类的实例再次加载时自动更新(picked up);通常不需要自己更新存储对象，因为更新其类的代码会改变它们的行为。</p><p>shelve也有众所周知的局限性（本章最后的数据库建议提到了其中的一些）。对于简单的对象存储，shelve和pickle是非常易于使用的工具。</p><p>####更新shelve上的对象</p><p>现在让我们编写一个程序，每次运行它时都会更新一个实例（记录），以证明我们的对象确实是持久的——即每次运行Python程序时它们的当前值都可用。 以下文件updatedb.py打印数据库，并每次都对我们的存储对象进行加注。 如果你追踪这里发生的事情，你会注意到我们获得了很多“免费”的工具——打印对象时会自动使用通用的<code>__repr__</code>重载方法，并且通过调用我们之前编写的giveRaise方法来提薪。 对于基于OOP继承模型的对象，这一切“正常运作”，即使它们在同一个文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File updatedb.py: update Person object on database</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.open(<span class="string">'persondb'</span>) <span class="comment"># Reopen shelve with same filename</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> sorted(db):   <span class="comment"># Iterate to display database objects</span></span><br><span class="line">print(key, <span class="string">'\t=&gt;'</span>, db[key]) <span class="comment"># Prints with custom format</span></span><br><span class="line"></span><br><span class="line">sue = db[<span class="string">'Sue Jones'</span>]  <span class="comment"># Index by key to fetch</span></span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)   <span class="comment"># Update in memory using class's method</span></span><br><span class="line">db[<span class="string">'Sue Jones'</span>] = sue  <span class="comment"># Assign to key to update in shelve</span></span><br><span class="line">db.close() <span class="comment"># Close after making changes</span></span><br></pre></td></tr></table></figure><p>由于此脚本在启动时打印数据库，因此我们必须至少运行两次以查看我们的对象更改：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; updatedb.py</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=100000]#</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">C:\code&gt; updatedb.py</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=110000]#</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">C:\code&gt; updatedb.py</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=121000]#</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">C:\code&gt; updatedb.py</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=133100]#</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br></pre></td></tr></table></figure><p>在交互式提示符下验证我们的脚本的工作——shelve对于数据库客户端的等价物：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(<span class="string">'persondb'</span>) <span class="comment"># Reopen database</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec = db[<span class="string">'Sue Jones'</span>] <span class="comment"># Fetch object by key</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">146410</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.lastName()</span><br><span class="line"><span class="string">'Jones'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.pay</span><br><span class="line"><span class="number">146410</span></span><br></pre></td></tr></table></figure><hr><p>本章完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：正如章题所言，本章中我们将建立一个类集(set of classes)，以实现一些具体的东西——记录和处理有关人的信息。在后面我们将会看到，我们所说的实例(instance)和类(class) 能够起到与传统术语中的记录(record)和规划(program)一样的作用。&lt;/p&gt;
&lt;p&gt;Python的类系统实际上主要只是在对象树中搜索属性，伴随着一个特别的 函数的第一个参数。(Despite its syntax details, Python’s class system really is largely just a matter of searching for an attribute in a tree of objects, along with a special first argument for functions.)&lt;/p&gt;
    
    </summary>
    
      <category term="Learning Python" scheme="http://KunKin.github.io/categories/Learning-Python/"/>
    
    
      <category term="Python" scheme="http://KunKin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter19.Advanced Function Topics</title>
    <link href="http://KunKin.github.io/2018/05/16/Chapter19-Advanced-Function-Topics/"/>
    <id>http://KunKin.github.io/2018/05/16/Chapter19-Advanced-Function-Topics/</id>
    <published>2018-05-16T03:47:07.000Z</published>
    <updated>2018-05-16T13:13:48.416Z</updated>
    
    <content type="html"><![CDATA[<p>这章讲函数的高级运用.</p><p>including 设计(design)、递归(recur)、函数对象(function object)、匿名(lambda)</p><a id="more"></a> <hr><h5 id="函数的设计层面"><a href="#函数的设计层面" class="headerlink" title="函数的设计层面"></a>函数的设计层面</h5><p>When you start using functions in earnest, you’re faced with choices about how to glue components together—for instance, how to decompose a task into purposeful functions (known as cohesion), how your functions should communicate (called coupling), and so on. You also need to take into account concepts such as the size of your functions, because they directly impact code usability. Some of this falls into the category of structured analysis and design, but it applies to Python code as to any other.</p><p>设计函数时面临的问题是把组件粘合在一起：比如，如何将任务分解为有目的的函数（cohesion），以及函数之间应如何交流（coupling）等。</p><p>还需要考虑诸如函数大小(size)等概念，因为它们直接影响代码的可用性。 其中一些属于结构化分析和设计类别，但它适用于其他Python代码。</p><p>关于函数设计原则：</p><table><thead><tr><th>PRINCIPLE</th><th>DETIALS</th></tr></thead><tbody><tr><td><strong>coupling</strong></td><td>use arguments for inputs and return for outputs.</td></tr><tr><td></td><td>use global variables only when truly necessary.</td></tr><tr><td></td><td>don’t change mutable arguments unless the caller expects it.</td></tr><tr><td></td><td>avoid changing variables in another module file directly.</td></tr><tr><td><strong>cohesion</strong></td><td>each function should have a single, unified purpose.</td></tr><tr><td><strong>size</strong></td><td>each function should be relatively small</td></tr></tbody></table><p>简而言之：降低耦合度(减少内外以及函数之间的相互影响封装性（Encapsulation）)，以及功能的单一性（或者说，专注），还有功能单一性对应的代码长度。</p><hr><p>#####递归函数（Recursive Functions）</p><p>1、可以用 if/else 三元表达式(ternary expression) 来保存一些代码实例(code real estate)：use Python’s if/else ternary expression to save some code real estate.</p><p>2、归纳任何可加的类型（当我们假设输入中至少有一个项目(item)时会更加简单）：generalize for any summable type(which is easier if we assume at least one item in the input)</p><p>3、使用Python 3.X 的拓展队列赋值来使得下面的 first/rest 更容易地递进：use Python 3.X’s extended sequence assignment to make the first/rest unpacking simpler</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">else</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Use ternary expression</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> L[<span class="number">0</span>] <span class="keyword">if</span> len(L) == <span class="number">1</span> <span class="keyword">else</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Any type, assume one</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line">first, *rest = L</span><br><span class="line"><span class="keyword">return</span> first <span class="keyword">if</span> <span class="keyword">not</span> rest <span class="keyword">else</span> first + mysum(rest) <span class="comment"># Use 3.X ext seq assign</span></span><br></pre></td></tr></table></figure><p>上面的例子中，后两个在L为 empty list 时会 fail 掉， 但是它们允许任何支持 “+” 操作的类型输入，而不局限于numbers.（然而这样子定义的函数并不具备多态性质，而是先定义的被后定义的覆盖了，于是后两个函数，或者说这三个顺着定义下来，再使用mysum(int)会报错，因为 ‘int’ object is not iterable）</p><p>• 单个参数时后两个函数也能工作：The latter two also work on a single string argument (e.g., mysum(‘spam’)), because strings are sequences of one-character strings.（strings 自己就是 一个由许多个单个字符的strings组成的，要记得在Python中，’a’是字符串而非字符）<br>• 第三个函数对于任意的可迭代对象都适用，包括open(filename)，但是不可迭代对象不行 ：The third variant works on arbitrary iterables, including open input files (mysum(open(name))), but the others do not because they index.<br>• 第三个函数不要定义成def mysum(first, *rest), 虽然跟原函数很像，但是却变得没有普适性，因为它期望输入独立的参数，而非一个可迭代对象。</p><p>值得注意的是 first, <em>rest = L 这个语句：用\</em>rest创建了一个list类型的rest对象之后，相当于把rest解压开来，然后按照a,b,c,d,… = List 的 形式把L中除了L[0]外的元素依次赋给了rest。这是一种*object的用法，值得学习。</p><p><em>双函数递归</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> L: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> nonempty(L) <span class="comment"># Call a function that calls me</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">nonempty</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Indirectly recursive</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mysum([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>])</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><hr><p>#####递归与循环的比较</p><p>Python强调简单的过程，因此用while 循环看起来会更加自然，例如，while通常使事情更加具体一些，并且它不要求函数被定义为允许递归调用。更好的是， for 循环能帮我们自动迭代，这使得递归在大部分情况下变得无关紧要（并且很可能在内存空间和执行时间方面效率较低）。</p><p>不过，递归并非一无是处，相反，在遍历任意形状的结构时，我们只能依靠递归（或者等价的基于显式堆栈的算法）。例如计算嵌套子列表结构(树)<code>[1，[2，[3,4]，5]，6，[7,8]]</code>中所有数字之和，由于不是线性迭代，任意嵌套的子列表简单的循环语句在这里不起作用。并且因为子列表可能嵌套到任意深度和任意形状，嵌套的循环语句也无能为力——无法知道有多少层嵌套。这时我们就需要用到递归了。</p><p>简而言之，递归在解决非线性迭代的问题时有很好的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> L: <span class="comment"># For each item at this level</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list):</span><br><span class="line">    tot += x <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    tot += sumtree(x) <span class="comment"># Recur for sublists</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br><span class="line"></span><br><span class="line">L = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]] <span class="comment"># Arbitrary nesting</span></span><br><span class="line">print(sumtree(L)) <span class="comment"># Prints 36</span></span><br><span class="line">print(sumtree(L[<span class="number">1</span>])) <span class="comment"># Prints 14</span></span><br><span class="line">print(sumtree((L[<span class="number">1</span>])[<span class="number">1</span>])) <span class="comment"># Prints 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pathological cases</span></span><br><span class="line">print(sumtree([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>]]]]])) <span class="comment"># Prints 15 (right-heavy)</span></span><br><span class="line">print(sumtree([[[[[<span class="number">1</span>], <span class="number">2</span>], <span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>])) <span class="comment"># Prints 15 (left-heavy)</span></span><br></pre></td></tr></table></figure><hr><p>#####递归与队列和栈的比较</p><p>Python是通过每次递归调用都在调用堆栈(call stack)上push信息来实现递归的，我们也可以通过使用自己的显式堆栈或队列来跟踪剩余的步骤，而不必递归调用来实现递归式过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span> <span class="comment"># Breadth-first, explicit queue</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  items = list(L) <span class="comment"># Start with copy of top level</span></span><br><span class="line">  <span class="keyword">while</span> items:</span><br><span class="line">    front = items.pop(<span class="number">0</span>) <span class="comment"># Fetch/delete front item</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(front, list):</span><br><span class="line">    tot += front <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    items.extend(front) <span class="comment"># &lt;== Append all in nested list</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure><p>从技术上讲，这段代码按照广度优先(breadth-first)的方式遍历列表，因为它将嵌套列表的内容添加到列表的末尾，形成了先进先出队列。 为了更好地模拟递归调用版本的遍历，我们可以将其更改为执行深度优先遍历(depth-first)，只需将嵌套列表的内容添加到列表的前面，形成后进先出堆栈：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#depth-first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span> <span class="comment"># Depth-first, explicit stack</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  items = list(L) <span class="comment"># Start with copy of top level</span></span><br><span class="line">  <span class="keyword">while</span> items:</span><br><span class="line">    front = items.pop(<span class="number">0</span>) <span class="comment"># Fetch/delete front item</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(front, list):</span><br><span class="line">    tot += front <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    items[:<span class="number">0</span>] = front <span class="comment"># &lt;== Prepend all in nested list</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure><p>这分别是广度优先搜索 和 深度优先搜索的结果(每行最后一个是该行前面的数的总和)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#L = [1, [2, [3, 4], 5], 6, [7, 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">36</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line"><span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">15</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">36</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure><hr><p>使用递归要避免无限递归循环(cycles)。特别是数据是循环的时候，比如循环图，之前的递归以及显式队列/堆栈都会失败，递归将落入无限递归循环，而其他方法也会落入简单的无限循环。</p><p>因此为了防止这种情况的出现，递归调用版本（the recursive call version）可以简单地保留并传递一个关于目前为止的访问状态集合(set)、字典(dictionary) 或者 列表(list):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> state <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">visited.add(state) <span class="comment"># x.add(state), x[state]=True, or x.append(state)</span></span><br><span class="line">...proceed...</span><br></pre></td></tr></table></figure><p>非递归类替代方案的做法，请注意，检查项目列表中已有的重复项可以避免调度状态(scheduling state)两次，但不会阻止程序重新访问先前遍历的状态,而导致被从列表中删除：</p><p>Note that checking for duplicates already on the items list would avoid scheduling a state twice, but would not prevent revisiting a state traversed earlier and hence removed from that list:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visited.add(front)</span><br><span class="line">...proceed...</span><br><span class="line">items.extend([x <span class="keyword">for</span> x <span class="keyword">in</span> front <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> visited])</span><br></pre></td></tr></table></figure><p>这个模型并不完全适用于本节的用例，它只是在列表中添加数字，但较大的应用程序将能够识别重复的状态 - 例如以前访问过的网页的URL。 </p><hr><p>某些程序可能还需要记录每个状态的完整路径，以便这些状态完成时报告解决方案。 在这种情况下，非递归方案的堆栈或队列中的每个项目都可能是完整路径列表，这些列表足以记录访问状态的记录，并且包含要在任一端探索的下一个项目。 另外请注意，标准Python限制了其运行时调用堆栈的深度（对递归调用程序至关重要），以捕获无限递归错误。 要扩展它，请使用sys模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrecursionlimit() <span class="comment"># 1000 calls deep default</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.setrecursionlimit(<span class="number">10000</span>) <span class="comment"># Allow deeper nesting</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sys.setrecursionlimit) <span class="comment"># Read more about it</span></span><br></pre></td></tr></table></figure><p>允许的最大设置可能因平台而异。 对于通过使用堆栈或队列来避免递归调用、并获得对遍历过程的更多控制的程序而言，这不是必需的。</p><hr><p>#####函数对象：属性和注释（Function Objects: Attributes and Annotations）</p><p>由于Python函数是对象，因此可以编写一般处理它们的程序。 函数对象可以被赋予其他名字，传递给其他函数，嵌入到数据结构中，从一个函数返回到另一个函数，等等，就好像它们是简单的数字或字符串一样。 函数对象也碰巧支持一种特殊的操作：可以通过在函数表达式之后的括号中列出参数来调用它们。 但是，函数与其他对象属于相同的一般类别。这通常被称为第一类对象模型(<em>a first-class object model</em>)，它在Python中无处不在，并且是函数式编程的必要部分。</p><p>function object 的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span> <span class="comment"># Name echo assigned to function object</span></span><br><span class="line">print(message)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(<span class="string">'Direct call'</span>) <span class="comment"># Call object through original name</span></span><br><span class="line">Direct call</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = echo <span class="comment"># Now x references the function too</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x(<span class="string">'Indirect call!'</span>) <span class="comment"># Call object through name by adding ()</span></span><br><span class="line">Indirect call!</span><br></pre></td></tr></table></figure><p>def实际上是把function对象赋值给了一个name，像其他对象一样，可以通过assign name 的方式(name = name) 来使得另一个name 能够引用这个function对象。</p><p>(有点像函数指针)</p><p>甚至能当参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">indirect</span><span class="params">(func, arg)</span>:</span></span><br><span class="line">func(arg) <span class="comment"># Call the passed-in object by adding ()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>indirect(echo, <span class="string">'Argument call!'</span>) <span class="comment"># Pass the function to another function</span></span><br><span class="line">Argument call!</span><br></pre></td></tr></table></figure><p>以及放进数据结构里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>schedule = [ (echo, <span class="string">'Spam!'</span>), (echo, <span class="string">'Ham!'</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (func, arg) <span class="keyword">in</span> schedule:</span><br><span class="line">func(arg) <span class="comment"># Call functions embedded in containers</span></span><br><span class="line">Spam!</span><br><span class="line">Ham!</span><br></pre></td></tr></table></figure><p>functions can also be created and returned for use elsewhere—the closure created in this mode also retains state from the enclosing scope:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(label)</span>:</span> <span class="comment"># Make a function but don't call it</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">        print(label + <span class="string">':'</span> + message)</span><br><span class="line">        <span class="keyword">return</span> echo<span class="comment">#Remeber what is returned!</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = make(<span class="string">'Spam'</span>) <span class="comment"># Label in enclosing scope is retained</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'Ham!'</span>) <span class="comment"># Call the function that make returned</span></span><br><span class="line">Spam:Ham!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'Eggs!'</span>)</span><br><span class="line">Spam:Eggs!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make(<span class="string">'Spam'</span>)(<span class="string">'Ham!'</span>)</span><br><span class="line">Spam:Ham!</span><br></pre></td></tr></table></figure><p>even:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(label)</span>:</span></span><br><span class="line">        print(<span class="number">1</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">            print(label + <span class="string">':'</span> + message)</span><br><span class="line">        <span class="keyword">return</span> echo</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make(<span class="string">'Spam'</span>)(<span class="string">'Eggs'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">Spam:Eggs</span><br></pre></td></tr></table></figure><hr><p>function object 的 expression 不止call：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__name__</span><br><span class="line"><span class="string">'func'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure><p>自检工具还能探索执行细节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__</span><br><span class="line">&lt;code object func at <span class="number">0x00000000021A6030</span>, file <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func.__code__)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>,</span><br><span class="line">...more omitted: <span class="number">37</span> total...</span><br><span class="line"><span class="string">'co_argcount'</span>, <span class="string">'co_cellvars'</span>, <span class="string">'co_code'</span>, <span class="string">'co_consts'</span>, <span class="string">'co_filename'</span>,</span><br><span class="line"><span class="string">'co_firstlineno'</span>, <span class="string">'co_flags'</span>, <span class="string">'co_freevars'</span>, <span class="string">'co_kwonlyargcount'</span>, <span class="string">'co_lnotab'</span>,</span><br><span class="line"><span class="string">'co_name'</span>, <span class="string">'co_names'</span>, <span class="string">'co_nlocals'</span>, <span class="string">'co_stacksize'</span>, <span class="string">'co_varnames'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__.co_varnames</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__.co_argcount</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>#####函数属性（Function Attributes）</p><p>函数属性不局限于前面列出的系统定义的属性，也可以为它们附加任意的用户定义属性(user-defined)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func</span><br><span class="line">&lt;function func at <span class="number">0x000000000296A1E0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.handles = <span class="string">'Button-Press'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.handles</span><br><span class="line"><span class="string">'Button-Press'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>,</span><br><span class="line">...<span class="keyword">and</span> more: <span class="keyword">in</span> <span class="number">3.</span>X all others have double underscores so your names won<span class="string">'t clash...</span></span><br><span class="line"><span class="string">__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'count'</span>, <span class="string">'handles'</span>]</span><br></pre></td></tr></table></figure><p>Python自带的属性都带有是”__X__”格式的（Python 3.X）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(f)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dir(f))</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> dir(f) <span class="keyword">if</span> <span class="keyword">not</span> x.startswith(<span class="string">'__'</span>)]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>可以使用这些属性直接将状态信息(<em>state information</em>)附加到函数对象上，而不是使用其他技术，例如全局变量，非局部变量和类。与非局部变量(nonlocal)不同，这些属性可以在函数本身的任何地方访问，即使在代码之外。<br>从某种意义上说，这也是一种在其他语言中模拟“静态局部变量”(static local)的方法 - 变量的名称在函数中是局部的，但在函数退出后其值保留。属性与对象（而不是范围）相关（并且必须通过其代码中的函数名称引用），但实际效果类似。<br>此外，当属性被附加到由其他工厂函数(factory functions)生成的函数时，它们也支持多次复制，每次调用和可写状态保留，就像非局部闭包和类实例属性</p><hr><p>#####函数注释(Function Annotations)</p><p>在Python 3.X（但不是2.X）中，也可以将注释信息（关于函数参数和结果的任意用户定义数据）附加到函数对象。<br>Python为指定注释提供了特殊的语法，但它对它本身不做任何事情; 注释是完全可选的，并且当存在时仅附加到函数对象的__annotations__属性以供其他工具使用。 例如，这样的工具可能会在错误测试的环境中使用注释。 我们在前一章中遇到了Python 3.X的关键字参数， 注释将进一步概括函数头语法。 考虑下面的非注解函数，它用三个参数编码并返回一个结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>在语法上，函数注释在def标题行中编码，作为与参数和返回值关联的任意表达式。</p><p> 对于参数，它们出现在紧跟在参数名称后面的冒号后面; </p><p>对于返回值，它们是在参数列表之后的 - &gt;之后编写的。 </p><p>例如，这段代码注释了前三个函数的参数以及它的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span>, b: <span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span>, c: float)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>对func的调用还是照常，只是注释以dictionary的形式存储在了__annotations__属性里。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; func.__annotations__</span><br><span class="line">&#123;&apos;c&apos;: &lt;class &apos;float&apos;&gt;, &apos;b&apos;: (1, 10), &apos;a&apos;: &apos;spam&apos;, &apos;return&apos;: &lt;class &apos;int&apos;&gt;&#125;</span><br></pre></td></tr></table></figure><p>由于这只是一些Python 对象 连接在 一个 Python对象上，因此annotation 也是能够被直接处理(process)的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span>, b, c: <span class="number">99</span>)</span>:</span></span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__annotations__</span><br><span class="line">&#123;<span class="string">'c'</span>: <span class="number">99</span>, <span class="string">'a'</span>: <span class="string">'spam'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> arg <span class="keyword">in</span> func.__annotations__:</span><br><span class="line">print(arg, <span class="string">'=&gt;'</span>, func.__annotations__[arg])</span><br><span class="line">c =&gt; 99</span><br><span class="line">a =&gt; spam</span><br></pre></td></tr></table></figure><p>有两点需要注意：</p><p>1、如果代码有annotation， 还是可以照常给参数设定默认值(defaults)</p><p>   （形式如 arg : annotation = default）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span> = <span class="number">4</span>, b: <span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span> = <span class="number">5</span>, c: float = <span class="number">6</span>)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func() <span class="comment"># 4 + 5 + 6 (all defaults)</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, c=<span class="number">10</span>) <span class="comment"># 1 + 5 + 10 (keywords work normally)</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__annotations__</span><br><span class="line">&#123;'c': &lt;class 'float'&gt;, 'b': (1, 10), 'a': 'spam', 'return': &lt;class 'int'&gt;&#125;</span><br></pre></td></tr></table></figure><p>2、前面示例中的空格都是可选的 —— 可以在函数头文件中的组件之间使用空格，但忽略空格可能会降低代码可读性。</p><p>但是：注释只能在def语句中使用，而不能在lambda表达式(下文对其说明)中使用，因为lambda的语法已经限制了它定义的函数的效用。</p><hr><p>#####匿名函数 (Anonymous Functions): lambda</p><p>lambda表达式创建了一个稍后调用的函数，但它返回的是函数而<em>不是将其分配给名称</em>。 因此lambda有时被称为匿名（即未命名）功能。 在实践中，它们通常用作内联函数定义的方式，或推迟执行一段代码。</p><p>lambda 表达式的格式：</p><p>​    <code>lambda argument1, argument2,... argumentN : expression using arguments</code></p><p>lambda 表达式返回的function object 跟用def 生成并引用的function object 运行起来是一样的。但是有一些差别使得lambda 在特别的方面很有用：</p><p>1、lambda 是（仅限于）一个表达式，而非声明：</p><p>​    例如，<em>lambda可以出现在Python语法不允许def的地方</em> - 例如列表字面量(list literal)或函数调用的参数(function call’s arguments)。 在def中，函数可以按名称引用，但必须在别处创建。 作为一个表达式，<em>lambda返回一个值（一个新的函数），可以选择分配一个名字</em>。 相比之下，def语句总是将新函数分配给头中的名称，而不是将其作为结果返回。</p><p>2、lambda 的主体是一个单一的表达式，而非一个语句块：</p><p>​    lambda的主体(body)与def 主体的return语句中放置的内容相似; 只需将结果输入为a naked expression，而非显式返回它， 因为它仅限于一个表达式，所以lambda比def更不常用 —— 你只能将如此多的逻辑压缩到lambda体中而不使用诸如if之类的语句。 <em>这是为了限制程序嵌套而设计的：lambda是为编写简单函数而设计的，def可以处理较大的任务。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y, z)</span>:</span> <span class="keyword">return</span> x + y + z</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x, y, z: x + y + z</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">#Function objects returned by running lambda expressions work exactly the same as those created and assigned by defs</span></span><br></pre></td></tr></table></figure><p>加了默认值(defaults):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Defaults work on lambda arguments, just like in a def:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = (<span class="keyword">lambda</span> a=<span class="string">"fee"</span>, b=<span class="string">"fie"</span>, c=<span class="string">"foe"</span>: a + b + c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x(<span class="string">"wee"</span>)</span><br><span class="line"><span class="string">'weefiefoe'</span></span><br></pre></td></tr></table></figure><p>lambda主体(body)中的代码也遵循与def中的代码相同的范围查找规则(scope lookup rules)。 lambda表达式引入了一个本地作用域，就像嵌套的def一样，它可以自动在封装函数、模块和内置作用域中看到名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">knights</span><span class="params">()</span>:</span></span><br><span class="line">        title = <span class="string">'Sir'</span></span><br><span class="line">        action = (<span class="keyword">lambda</span> x: title + <span class="string">' '</span> + x) <span class="comment"># Title in enclosing def scope</span></span><br><span class="line">        <span class="keyword">return</span> action <span class="comment"># Return a function object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act = knights()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg = act(<span class="string">'robin'</span>) <span class="comment"># 'robin' passed to x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">'Sir robin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act <span class="comment"># act: a function, not its result</span></span><br><span class="line">&lt;function knights.&lt;locals&gt;.&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x00000000029CA488</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">()</span>:</span></span><br><span class="line">      print()</span><br><span class="line"><span class="keyword">return</span> echo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()<span class="comment">#same as lambda</span></span><br><span class="line">&lt;function f.&lt;locals&gt;.echo at <span class="number">0x0000024429B60048</span>&gt;</span><br></pre></td></tr></table></figure><hr><p>#####用lambda的原因</p><p>一般来说，lambda可以作为一种函数简写方式派上用场，它允许您在使用它的代码中嵌入函数的定义。 它们完全是可选的——你可以总是使用def来代替，尤其是lambda表达式不能轻易满足函数需要时——但在要使用的位置中，lambda往往是简单的编码结构，你只需要嵌入小部分可执行代码内联（small bits of executable code inline）。<br>例如，回调处理程序经常被编码为直接嵌入到注册调用参数列表中的内联lambda表达式，而不是在文件中的其他位置定义def并用名称引用。<br>lambda也常用于编写跳转表(jump tables)，这些跳转表是按需执行的动作列表或字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, <span class="comment"># Inline function definition</span></span><br><span class="line"><span class="keyword">lambda</span> x: x ** <span class="number">3</span>,</span><br><span class="line"><span class="keyword">lambda</span> x: x ** <span class="number">4</span>] <span class="comment"># A list of three callable functions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> L:</span><br><span class="line">print(f(<span class="number">2</span>)) <span class="comment"># Prints 4, 8, 16</span></span><br><span class="line">    </span><br><span class="line">print(L[<span class="number">0</span>](<span class="number">3</span>)) <span class="comment"># Prints 9</span></span><br></pre></td></tr></table></figure><p>当需要将小块可执行代码填充到语句在句法上非法的地方时，lambda表达式对def来说是更具有优势的。 例如，前面的代码片段(code snippet,)通过在list literal中嵌入lambda表达式来构建三个函数的list； 在这样的list literal中，def（或者说，语句）不起作用。 等效的def编码需要临时函数名称（可能与其他函数名称冲突）并且函数需要定义在预期使用的上下文之外（可能需要几百行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">3</span> <span class="comment"># Define named functions</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">4</span></span><br><span class="line"></span><br><span class="line">L = [f1, f2, f3] <span class="comment"># Reference by name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> L:</span><br><span class="line">print(f(<span class="number">2</span>)) <span class="comment"># Prints 4, 8, 16</span></span><br><span class="line">    </span><br><span class="line">print(L[<span class="number">0</span>](<span class="number">3</span>)) <span class="comment"># Prints 9</span></span><br></pre></td></tr></table></figure><hr><p>#####多路分支选择(Multiway Branch Switches)</p><p>可以用Python中的字典和其他数据结构来做同样的事情来构建更一般的动作表(action table):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key = &apos;got&apos;</span><br><span class="line">&gt;&gt;&gt; &#123;&apos;already&apos;: (lambda: 2 + 2),</span><br><span class="line">&apos;got&apos;: (lambda: 2 * 4),</span><br><span class="line">&apos;one&apos;: (lambda: 2 ** 6)&#125;[key]()</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>当Python创建临时字典时，每个嵌套lambda生成并留下稍后调用的函数。 按键索引获取这些函数之一，括号会强制调用获取的函数。 当用这种方式进行编码时，字典变成了一种比通用的多路分支工具。</p><p>用def替代的方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>key = <span class="string">'one'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'already'</span>: f1, <span class="string">'got'</span>: f2, <span class="string">'one'</span>: f3&#125;[key]()</span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure><p>（注意<code>{&#39;already&#39;: f1, &#39;got&#39;: f2, &#39;one&#39;: f3}</code>中用的是函数名<code>f1</code>，而不是<code>f1()</code>,<code>f1()</code>代表的已经是调用函数了。）</p><p>替代方案也适用，但是即使只是一小段代码，def 在文件中也可能是任意的。 lambdas提供的代码接近性(code proximity)对于仅在单个上下文中使用的函数特别有用——如果这里的三个函数在别的地方没有用处，则将其定义嵌入dictionary中的lambda expression 是有意义的。 此外，定义形式要求您为这些小函数起名，<em>可能导致与此文件中的其他名称冲突</em>。<br>lambdas在函数调用参数列表中也派上用场，这是一种内联临时函数定义的方法，不会在程序中的任何其他位置使用。在图(map)中lambda函数有别的用途。</p><hr><p>#####不要混淆代码(Not to Obfuscate Code)</p><p>只有明确知道自己在做什么的时候才可以将Python中的大多数语句编写为基于表达式的等价语言。</p><p>比如，为了将<strong>选择逻辑</strong>(selection logic)嵌套在一个lambda中，可以用if/else三元表达式， 或者等价却更复杂的 and/or 组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">b</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">b <span class="keyword">if</span> a <span class="keyword">else</span> c<span class="comment">#if/else ternary expression</span></span><br><span class="line"></span><br><span class="line">((a <span class="keyword">and</span> b) <span class="keyword">or</span> c)<span class="comment">#and/or combination</span></span><br></pre></td></tr></table></figure><p>像这样的表达式能够被放进lambda中，因此它们可能被用来执行lambda函数里的选择逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower = (<span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower(<span class="string">'bb'</span>, <span class="string">'aa'</span>)</span><br><span class="line"><span class="string">'aa'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower(<span class="string">'aa'</span>, <span class="string">'bb'</span>)</span><br><span class="line"><span class="string">'aa'</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>此外，如果想在lambda表达式中执行<strong>循环</strong>，还可以嵌入像map calls(图调用)和list comprehension表达式这样的东西 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: list(map(sys.stdout.write, x)) <span class="comment"># 3.X: must use list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = showall([<span class="string">'spam\n'</span>, <span class="string">'toast\n'</span>, <span class="string">'eggs\n'</span>]) <span class="comment"># 3.X: can use print</span></span><br><span class="line">spam</span><br><span class="line">toast</span><br><span class="line">eggs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: [sys.stdout.write(line) <span class="keyword">for</span> line <span class="keyword">in</span> x]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = showall((<span class="string">'bright\n'</span>, <span class="string">'side\n'</span>, <span class="string">'of\n'</span>, <span class="string">'life\n'</span>))</span><br><span class="line">bright</span><br><span class="line">side</span><br><span class="line">of</span><br><span class="line">life</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: [print(line, end=<span class="string">''</span>) <span class="keyword">for</span> line <span class="keyword">in</span> x] <span class="comment"># Same: 3.X only</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: print(*x, sep=<span class="string">''</span>, end=<span class="string">''</span>) <span class="comment"># Same: 3.X only</span></span><br></pre></td></tr></table></figure><p>使用表达式模拟语句是有限制的：例如，工具(tool)比如说：内置setattr、命名空间的__dict__和就地就该可变对象的方法，虽然这些工具有时可以驻留，但是不能直接实现赋值语句的效果 ，函数式编程技术(functional programming techniques)可以让你深入复杂表达的黑暗领域(the dark<br>realm of convoluted expression.)。<br>仅请使用这些技巧作为最后的手段。如果不加以小心，它们可能会导致无法读取(unreadable)（又名混淆(obfuscated))）的Python代码。 一般来说，简单比复杂更好，显式比隐式更好，完整语句比隐晦表达(arcane expressions)更好。 这就是lambda仅限于表达式的原因。<br>如果有更大的代码逻辑，使用def；lambda是用于小块的内联代码的。<br>另一方面，适度使用这些技术是很有帮助的。</p><hr><p>#####关于and/or</p><p>and : 从左到右扫描，返回第一个为假的表达式值，无假值则返回最后一个表达式值。</p><p>or    : 从左到右扫描，返回第一个为真的表达式值，无真值则返回最后一个表达式值。</p><p>在Python中，and 和 or 执行布尔逻辑演算。但是它们并不返回布尔值，而是返回它们实际进行比较的值之一。（类似C++里面的&amp;&amp;和||的短路求值）</p><p>在布尔环境中，0、”、[]、()、{}、None为假；其它任何东西都为真。但是可以在类中定义特定的方法使得类实例的演算值为假。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"betabin"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'betabin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br></pre></td></tr></table></figure><p>看起来类似于条件运算符（bool ？a：b），是的，当a为true的时候是一样的。但是，当a为false的时候，就明显不同了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= <span class="string">""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =<span class="string">"python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br></pre></td></tr></table></figure><p>可见两种情况都返回了b，与<code>bool ? a : b</code>的效果不同</p><p>如果执意用and/or来实现条件运算符，可以用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">""</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"betabin"</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> <span class="keyword">and</span> [a] <span class="keyword">or</span> [b])[<span class="number">0</span>]  </span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><p>[“”]不为假，从而将a为假的可能性剔除，再通过下标0 (即是[0]) 再获得a。由于获得元素的途经统一，因此b也要套上[]。</p><p>and/or 技巧主要在 lambda中使用。</p><hr><p>#####范围(scope)</p><p>lambdas can be nested too</p><p>lambdas是嵌套函数范围查找的主要受益者(LEGB中的E)。下面的lambda出现在一个def中——一个典型案例——并且因此可以在调用封闭函数时，访问名称x在封闭函数作用域中的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">lambda</span> y: x + y) <span class="comment"># Make and return function, remember x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act = action(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act</span><br><span class="line">&lt;function action.&lt;locals&gt;.&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x00000000029CA2F0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act(<span class="number">2</span>) <span class="comment"># Call what action returned</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>((<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> y: x + y))(<span class="number">99</span>))(<span class="number">4</span>)</span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure><p>这里，嵌套的lambda结构在调用时会生成一个函数。在这两种情况下，嵌套lambda的代码都可以访问封闭lambda中的变量x。 这确实有用，但它似乎是相当复杂的代码; 为了可读性，通常最好避免嵌套lambda。</p><hr><p>#####回调函数(callback)</p><p>首先明晰一下什么是回调函数(callback)：</p><p>​    维基：指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。</p><p>​    百度：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回调函数1</span></span><br><span class="line"><span class="comment">#生成一个2k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#回调函数2</span></span><br><span class="line"><span class="comment">#生成一个4k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadruple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">4</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> even <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#中间函数</span></span><br><span class="line"><span class="comment">#接受一个生成偶数的函数作为参数</span></span><br><span class="line"><span class="comment">#返回一个奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddNumber</span><span class="params">(k, getEvenNumber)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getEvenNumber(k)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#起始函数，这里是程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="comment">#当需要生成一个2k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, double)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个4k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, quadruple)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个8k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, <span class="keyword">lambda</span> x: x * <span class="number">8</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">运行`callback_demp.py`，输出如下：</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><p>#####lambda 回调函数(callback)</p><p>lambda另一个常见的用途是为Python的tkinter GUI API定义内联回调函数(inline callback function)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Button, mainloop <span class="comment"># Tkinter in 2.X</span></span><br><span class="line">x = Button(</span><br><span class="line">        text=<span class="string">'Press me'</span>,</span><br><span class="line">        command=(<span class="keyword">lambda</span>:sys.stdout.write(<span class="string">'Spam\n'</span>))) <span class="comment"># 3.X: print()</span></span><br><span class="line">x.pack()</span><br><span class="line">mainloop() <span class="comment"># This may be optional in console mode</span></span><br></pre></td></tr></table></figure><p>在这里，我们将lambda生成的函数传递给command关键字参数以注册(register)回调处理程序。<br>这里的lambda相对于def的优点是处理按钮按下的代码就嵌入在创建按钮(button-creation)的调用中。<br>实际上，lambda延迟处理程序的执行，直到事件发生。如上例中，write在按钮被按下时而非被创建时被调用，并且有效地“知道”在事件发生时应该写入的字符串。<br>因为嵌套的函数作用域规则(the nested function scope rules)也适用于lambda表达式，所以它们也更容易用作回调处理程序（从Python 2.2开始） - 它们自动在它们编码的函数中看到名称，并且在大多数情况下不再需要传入缺省值。<br>这非常便于访问特殊的自我实例参数(special self instance argument)（封装类方法函数中的局部变量）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGui</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makewidgets</span><span class="params">(self)</span>:</span></span><br><span class="line">Button(command=(<span class="keyword">lambda</span>: self.onPress(<span class="string">"spam"</span>)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onPress</span><span class="params">(self, message)</span>:</span></span><br><span class="line">...use message...</span><br></pre></td></tr></table></figure><hr><p>#####函数编程工具(functional programming tools)</p><p>通过大多数定义，Python支持：过程式(procedural)（基本语句basic statements），object-oriented（类）和功能性。对于后者，Python包含一组内置函数，用于函数编程 - 将函数应用于序列和其他迭代器的工具。这个集合包括调用可迭代对象的元素上的函数的工具（map）、根据测试函数过滤元素（filter）、以及，将函数应用于项目对和运行结果（reduce）。<br>虽然边界有时有点模糊，但大多数定义中，Python的函数式编程库也包括前面探讨的一流对象模型(the first-class object model)，嵌套范围闭包(the first-class object model)和匿名函数lambdas.</p><p>#####Mapping Functions over Iterables: map</p><p>程序对list和其他sequence执行的更常见的操作是对每个元素应用操作，并收集结果——选择数据库表格的列，增加公司中雇员的付费字段，解析电子邮件附件等等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counters = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>updated = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> counters:</span><br><span class="line">updated.append(x + <span class="number">10</span>) <span class="comment"># Add 10 to each item</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>updated</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure><p>但是由于这是常见操作，Python 也提供了内置函数来实现这种功能。map函数将传入的函数(passed-in function)应用于可迭代对象中的每个元素，并返回一个包含所有函数调用结果的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x + <span class="number">10</span> <span class="comment"># Function to be run</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, counters)) <span class="comment"># Collect results</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure><p>通过传递一个<em>user-defined</em>函数来应用于列表中的每个元素的列表——map 调用 inc 中的每个项目，并将所有返回值收集到一个新列表中，我们能更普适地使用它。</p><p>因为map需要一个函数的传入和应用，所以它也恰好是lambda常见的地方之一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map((<span class="keyword">lambda</span> x: x + <span class="number">3</span>), counters)) <span class="comment"># Function expression</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>由于这个函数只在这里需要，它被写成了一个用lambda内联的形式(written inline as a lambda)。由于上例中map的使用与for循环是等价的，因此用一小段额外的代码就能够写出一个通用的遍历工具(a general mapping utility)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mymap</span><span class="params">(func, seq)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> seq: res.append(func(x))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个自定义的函数对于inc函数的效果是跟之前的map一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># Built-in is an iterable</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mymap(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># Ours builds a list (see generators)</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure><p>但是要注意，map是内置的，这说明它总是可用的、总是以同一种方式运作的，并且有一些性能优势。此外，map 有比上例更加高级的用法，比如给定多个序列参数(sequence arguments)，它将并行序列中的项作为不同的(distinct)参数发送给函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># 3**4</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(pow, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])) <span class="comment"># 1**2, 2**3, 3**4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>对于N个序列(N sequences)，映射期望(expect)一个 N-argument 函数。 在这里，pow函数在每次调用上都用到两个参数，每个参数由每个sequence分别传递。 在代码中模拟这种多重序列的通用性(multiple-sequence generality)并没有太多的额外工作，但是需要一些额外的迭代工具。</p><p>其实map的调用有点像list comprehension：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[inc(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]] <span class="comment"># Use () parens to generate items instead</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure><p>虽然list comprehension 很快，但是在一些情况下，map 可能比list comprehension 更快， 且需要更少的代码。On the other hand，map对每个元素应用一个函数调用(<em>function</em> call)而不是一个任意的表达式，这是一个不太常用的工具，并且通常需要额外的帮助函数或lambda表达式。 此外，用圆括号()而非方括号[]括起comprehension， 能产生一个对象，这个对象能根据请求来生成(<em>generate</em>) value以节省内存并提高响应速度，就像Python 3.X中的map一样。</p><p>#####Selecting Items in Iterables: filter</p><p>filter:根据测试函数(test function)选择迭代元素</p><p>因为过滤器(filter)也返回一个可迭代对象，所以过滤器（比如说，range）需要一个列表调用(list call)来在3.X中显示其所有结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(−<span class="number">5</span>, <span class="number">5</span>)) <span class="comment"># An iterable in 3.X</span></span><br><span class="line">[−<span class="number">5</span>, −<span class="number">4</span>, −<span class="number">3</span>, −<span class="number">2</span>, −<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter((<span class="keyword">lambda</span> x: x &gt; <span class="number">0</span>), range(−<span class="number">5</span>, <span class="number">5</span>))) <span class="comment"># An iterable in 3.X</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>函数返回true的 sequence 或 可迭代对象(iterable)中的 元素将被添加到结果列表中。 像map一样，这个用了filter的函数大致相当于下面的for循环，但它是内置的，简洁的，并且通常很快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(−<span class="number">5</span>, <span class="number">5</span>): <span class="comment"># The statement equivalent</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        res.append(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>像 map 一样，用一个更简单的结果（特别是当它可以避免创建一个新函数时），以及在需要延迟生成结果时用一个类似的生成器表达式， filter 能够被 list comprehension 模拟。</p><p>Also like map, filter can be emulated by list comprehension syntax with often-simpler results (especially when it can avoid creating a new function), and with a similar generator expression when delayed production of results is desired.</p><p>#####Combining Items in Iterables: reduce</p><p>reduce 函数更加复杂， 它接受一个可迭代对象(iterable)来运行，但它本身不是一个可迭代的对象——它返回一个单一的结果(single result)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce <span class="comment"># Import in 3.X, not in 2.X</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><p>在每个步骤中，reduce将当前的总和或总乘积连同list中的下一个元素传递给passed-in lambda函数。 默认情况下，用序列中的第一个元素来初始化起始值。 为了说明，这里是与这些调用中的第一个调用(求总和那个)等价的for循环，并且在循环内部添加硬编码(hardcode)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = L[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">res = res + x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>以下函数模拟reduce大部分内置行为，并帮助彻底揭开其操作的神秘面纱：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">myreduce</span><span class="params">(function, sequence)</span>:</span></span><br><span class="line">        tally = sequence[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> next <span class="keyword">in</span> sequence[<span class="number">1</span>:]:</span><br><span class="line">        tally = function(tally, next)</span><br><span class="line">        <span class="keyword">return</span> tally</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myreduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myreduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>内置的reduce还允许在list中的item之前放置可选的第三个参数，以便在序列为空时用作默认结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#253&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), [])</span><br><span class="line">TypeError: reduce() of empty sequence <span class="keyword">with</span> no initial value</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), <span class="number">0</span>,[])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#247&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), <span class="number">0</span>,[])</span><br><span class="line">TypeError: reduce() arg <span class="number">2</span> must support iteration</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [],<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [],<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#252&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">TypeError: reduce expected at most <span class="number">3</span> arguments, got <span class="number">4</span></span><br></pre></td></tr></table></figure><p>standard library 中的 operator module 提供了与内置表达式(build-in expression)相对应的函数，因此可用于某些功能工具的使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator, functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(operator.add, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]) <span class="comment"># Function-based +</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><hr><p>之前提到了硬编码(又叫写死)：</p><p><strong>硬编码</strong>（英语：<strong>Hard Code</strong>或<strong>Hard Coding</strong>）是指在软件实现上，将输出或输入的相关参数（例如：路径、输出的形式或格式）直接以常量的方式撰写在源代码中，而非在运行期间由外界指定的设置、资源、数据或格式做出适当回应。一般被认定是种反模式或不完美的实现，因为软件受到输入数据或输出的格式改变就必需修改源代码，对客户而言，改变源代码之外的小设置也许还比较容易。</p><p>但硬编码的状况也并非完全只有缺陷，因某些封装需要或软件本身的保护措施，有时是必要的手段。除此之外，有时候因应某些特殊的需求，制作出简单的应用程序，应用程序可能只会运行一次，或者永远只应付一种需求，利用硬编码来缩短开发的时间也是一种不错的决策。</p><hr><p>本章完毕li</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这章讲函数的高级运用.&lt;/p&gt;
&lt;p&gt;including 设计(design)、递归(recur)、函数对象(function object)、匿名(lambda)&lt;/p&gt;
    
    </summary>
    
      <category term="Learning Python" scheme="http://KunKin.github.io/categories/Learning-Python/"/>
    
    
      <category term="Python" scheme="http://KunKin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Permutation</title>
    <link href="http://KunKin.github.io/2018/05/16/Permutation/"/>
    <id>http://KunKin.github.io/2018/05/16/Permutation/</id>
    <published>2018-05-16T03:36:29.000Z</published>
    <updated>2018-12-29T07:21:20.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>N个数的全排列数，观察3个数的全排列数：</p><p>1 2 3</p><p>1 3 2</p><p>2 1 3</p><a id="more"></a> <p>2 3 1</p><p>3 1 2</p><p>3 2 1</p><p>可以看到第一个分别是1 2 3，而各自后面所跟着的，恰恰是剩下的数的全排列，以1为例，后面的 2 3 和 3 2是2、3的全排列</p><p>又比如4个数全排列：</p><p><img src="http://img.blog.csdn.net/20170319170336573?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlxaTEyM2k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="全排列"></p><p>即先依字典序安排一个数在首位，而剩下的数则在后面进行全排列，这就体现出了递归的思想，由此可见我们可以用递归来处理这个问题</p><p>抽象出来就是Permutation(N){ Head(); Permutation(N-1); }</p><h2 id="代码与说明"><a href="#代码与说明" class="headerlink" title="代码与说明"></a>代码与说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*递归最重要的是逻辑，不要钻牛角尖。</span></span><br><span class="line"><span class="comment">*写程序之前必须在纸上写出代码逻辑，纸张的记录能够辅助把握想法，</span></span><br><span class="line"><span class="comment">*光靠大脑来想总是顾此失彼，还会导致思路不清晰，甚至忘掉之前的思路。</span></span><br><span class="line"><span class="comment">*尤其是递归，在纸上列明逻辑便很容易写出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">之前的代码是</span></span><br><span class="line"><span class="comment">void permutation(char *s) &#123;</span></span><br><span class="line"><span class="comment">    if (strlen(s) == 1) &#123;</span></span><br><span class="line"><span class="comment">        printf("%c\n", s[0]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else &#123;</span></span><br><span class="line"><span class="comment">        int i;</span></span><br><span class="line"><span class="comment">        for (i = 0; i &lt; strlen(s); i++) &#123;</span></span><br><span class="line"><span class="comment">            printf("%c",s[i]);</span></span><br><span class="line"><span class="comment">            char s1[11] = "";</span></span><br><span class="line"><span class="comment">            char *p = s1;</span></span><br><span class="line"><span class="comment">            for (j = 0; j &lt; strlen(s); j++) &#123;</span></span><br><span class="line"><span class="comment">                if (j != i) &#123; *(p++) = s[j]; &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            permutation(s1);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">这样是有问题的，不定义before以存储已排列过的部分，则每次递归，都只打印出当前层次未确定的字符的排列。因为对每一层递归来说，上一层递归只执行一次，也就是说这层递归无论有多少情况，上一层都只打印一次。这就造成了缺项。</span></span><br><span class="line"><span class="comment">以 N=3 为例，以 1 为开头的全排列本该有两个，但是会出现 123 和 32 的结果，在第二个结果中1消失了，这是因为在递归中，处理第一位的操作只出现了一次。因此 N=3 的情况下，输出长度呈现 3 2 3 2 3 2 这样的情况。以上图的树来看，四个*的只输出一次，三个*输出4次，两个*输出12次，对应第一位被确定的情况下，第一位被打印出来的次数、第二位被打印出来的次数以及第三位的。</span></span><br><span class="line"><span class="comment">同理，N=4的情况下，输出长度会呈现 4 3 2 2 4 3 2 2 …… 这样的情况。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义了两个参数，s指的是待全排列的子串，before则保存是已排列过的部分，如1234，1243中的12即是已排列过的部分*/</span></span><br><span class="line"><span class="comment">/*本质上说全排列是位置变动，而与具体的值无关，因此只需要稍微安排一下字符串（为了按字典序输出），就能放心地使用递归直接对子串全排列*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *before)</span> </span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(<span class="built_in">strlen</span>(s)</span> </span>== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(before); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, before[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, s[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">char</span> newBefore[<span class="number">11</span>] = <span class="string">""</span>;</span><br><span class="line">          <span class="comment">/*这里之所以声明一个新的before是为了给每个下级递归分配独立的before避免冲突，事实上直接使用before会导致before一直增加元素直到数组溢出*/</span></span><br><span class="line">            </span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(before); j++) &#123;</span><br><span class="line">                newBefore[j] = before[j];</span><br><span class="line">            &#125;</span><br><span class="line">            newBefore[<span class="built_in">strlen</span>(newBefore)] = s[i];</span><br><span class="line">            <span class="keyword">char</span> s1[<span class="number">11</span>] = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">char</span> *p = s1;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(s); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i) &#123; *(p++) = s[j]; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/*对于每一次循环都进行一次递归调用，因为树的每个节点都有相同数量的子树，因此各自递归*/</span></span><br><span class="line">            permutation(s1, newBefore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">11</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        s[i] = (<span class="keyword">char</span>) (i + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> before[<span class="number">11</span>] = <span class="string">""</span>;</span><br><span class="line">    permutation(s, before);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;N个数的全排列数，观察3个数的全排列数：&lt;/p&gt;
&lt;p&gt;1 2 3&lt;/p&gt;
&lt;p&gt;1 3 2&lt;/p&gt;
&lt;p&gt;2 1 3&lt;/p&gt;
    
    </summary>
    
      <category term="Learning C" scheme="http://KunKin.github.io/categories/Learning-C/"/>
    
    
      <category term="C" scheme="http://KunKin.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://KunKin.github.io/2017/12/01/hello-world/"/>
    <id>http://KunKin.github.io/2017/12/01/hello-world/</id>
    <published>2017-12-01T11:13:48.563Z</published>
    <updated>2018-05-16T07:45:58.583Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a> <h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
