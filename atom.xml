<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KhunKin的书斋</title>
  
  
  <link href="/khunkin.github.io/atom.xml" rel="self"/>
  
  <link href="http://KunKin.github.io/"/>
  <updated>2018-05-16T07:51:47.696Z</updated>
  <id>http://KunKin.github.io/</id>
  
  <author>
    <name>Deng kunquan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chapter14-Iterations-and-Comprehensions</title>
    <link href="http://KunKin.github.io/2018/05/16/Chapter14-Iterations-and-Comprehensions/"/>
    <id>http://KunKin.github.io/2018/05/16/Chapter14-Iterations-and-Comprehensions/</id>
    <published>2018-05-16T07:50:41.000Z</published>
    <updated>2018-05-16T07:51:47.696Z</updated>
    
    <content type="html"><![CDATA[<p>前言：这一章主要是讲迭代（迭代器以及可迭代对象） 和 推导式（comprehension）</p><p>comprehension 就是 类似于list(x for x in object) 这种</p><p>iteration 包括 Iterator  和 Iterable 的对象，以及各种迭代器的使用，其中配合comprehension的话迭代器能发挥更多作用</p><a id="more"></a> <hr><p>关于list comprehension 很重要的一点：</p><p>List comprehensions might run much faster than manual for loop statements (often roughly twice as fast) because their iterations are performed at C language speed inside the interpreter, rather than with manual Python code.</p><p>就是说list comprehension是在Python 解释器里跑的，比手动写的Python编码快</p><p>（迭代器遍历比较快，这点Java中也一样）</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>) <span class="comment"># Read a four-line script file in this directory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline() <span class="comment"># readline loads one line on each call</span></span><br><span class="line"><span class="string">'import sys\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line"><span class="string">'print(sys.path)\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline()</span><br><span class="line"><span class="string">'x = 2\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline() <span class="comment"># Last lines may have a \n or not</span></span><br><span class="line"><span class="string">'print(x ** 32)\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.readline() <span class="comment"># Returns empty string at end-of-file</span></span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>) <span class="comment"># __next__ loads one line on each call too</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() <span class="comment"># But raises an exception at end-of-file</span></span><br><span class="line"><span class="string">'import sys\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() <span class="comment"># Use f.next() in 2.X, or next(f) in 2.X or 3.X</span></span><br><span class="line"><span class="string">'print(sys.path)\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line"><span class="string">'x = 2\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line"><span class="string">'print(x ** 32)\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>用__next__好过用readline： Such object may also be stepped through with a for loop or other iteration tool, because all iteration tools normally work internally by calling __next__ on each iteration and catching the StopIteration exception to determine when to exit.</p><p>大意是说，可以利用for循环或其他迭代器读取__next__，因为一般来说迭代器的每次迭代调用的也是__next__，而且迭代器还能根据“StopIteration”这个异常来终止迭代。</p><p>注意Python中也是有异常的，像Java一样。</p><hr><p>从文本文件中逐行读入所有的文本并打印，下面三种语句都有同样的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>): <span class="comment"># Use file iterators to read by lines</span></span><br><span class="line"><span class="meta">... </span>print(line.upper(), end=<span class="string">''</span>) <span class="comment"># Calls __next__, catches StopIteration</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>).readlines(): <span class="comment">#Notice that "readlines" has a "s"</span></span><br><span class="line"><span class="meta">... </span>print(line.upper(), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"><span class="meta">... </span>line = f.readline()</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> <span class="keyword">not</span> line: <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>print(line.upper(), end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>①：注意 print 用了一个 end=’ ‘，用来阻止Python在行末加’\n’——因为读入的语句中已经有一个’\n’了。事实上，①的方法是最好的逐行读取文本文的方法：1、编码简单；2、快；3、占用内存空间少</p><p>②中readline不是最好的选择，还占用很多内存空间（because this version really does load the entire file into memory all at once, it will not even work for files too big to fit into the memory space available on your computer.）</p><p>③中的while循环比基于迭代器（iterator-based）的for循环慢，因为在Python中迭代器（iterator）是以C语言的速度运行的，而③中的while循环是在Python虚拟机中以Python字节码运行的</p><p>综上：用①就好了，忘了②③吧</p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__() <span class="comment"># Call iteration method directly</span></span><br><span class="line"><span class="string">'import sys\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__next__()</span><br><span class="line"><span class="string">'print(sys.path)\n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(f) <span class="comment"># The next(f) built-in calls f.__next__() in 3.X</span></span><br><span class="line"><span class="string">'import sys\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(f) <span class="comment"># next(f) =&gt; [3.X: f.__next__()], [2.X: f.next()]</span></span><br><span class="line"><span class="string">'print(sys.path)\n'</span></span><br></pre></td></tr></table></figure><p>python3中提供了一个内置函数next()（built-in function）（__next__是方法(method)，注意二者区别）</p><p>从技术上讲，前面提到的迭代协议还有一点。 当for循环开始时，它首先通过将它传递给iter内置函数来从可迭代对象中获取一个迭代器; 由iter返回的对象又具有所需的下一个方法。 iter函数内部运行__iter__方法，非常像next和_<em>next\</em>_.</p><p><strong>迭代</strong>：用一个循环（比如 for 循环）来遍历容器（比如列表，元组）中的元素。</p><p><strong>可迭代对象</strong>：含有 <code>__iter__()</code> 方法或 <code>__getitem__()</code> 方法的对象。</p><p><strong>迭代器协议（iterator protocol）</strong>是指要实现对象的 <code>__iter()__</code> 和 <code>next()</code> 方法（注意：Python3 要实现 <code>__next__()</code> 方法），其中，<code>__iter()__</code> 方法返回迭代器对象本身，<code>next()</code> 方法返回容器的下一个元素，在没有后续元素时抛出 <code>StopIteration</code> 异常。</p><p><em>（也就是说要同时拥有<code>__iter()__</code> 和 <code>next()</code> 方法才符合iterator protocol）</em></p><p>使用 <code>hasattr()</code> 和 <code>isinstance()</code> 判断是否迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="string">'__iter__'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="string">'next'</span>)  <span class="comment"># 有 __iter__ 方法但是没有 next 方法，不是迭代器</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((), Iterator)</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p><strong>虽然元组、列表和字典等对象是可迭代的，但它们却不是迭代器</strong>，对于这些可迭代对象，可以使用 Python 内置的 <code>iter()</code> 函数获得它们的迭代器对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I = iter(L) <span class="comment"># Obtain an iterator object from an iterable</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I.__next__() <span class="comment"># Call iterator's next to advance to next item</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I.__next__() <span class="comment"># Or use I.next() in 2.X, next(I) in either line</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I.__next__()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I.__next__()</span><br><span class="line">...error text omitted...</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I = iter(L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> I: print(i)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> L: print(i)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>其中，iter(L)和L都是可迭代的（iterable），因此能以 “for i in X:”的形式进行迭代</p><hr><p><strong>next()函数和__next__()方法只能用于Iterator</strong>(其实还有__iter()__也只能用于Iterator)（iterator protocol）,所以要用这些函数和方法就要先用iter()取得object的iterator</p><hr><p>事实上，Python 的 <code>for</code> 循环就是先通过内置函数 <code>iter()</code> 获得一个迭代器，然后再不断调用 <code>next()</code> 函数实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获得 Iterator 对象</span></span><br><span class="line">it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获得下一个值</span></span><br><span class="line">        x = next(it)</span><br><span class="line">        <span class="keyword">print</span> x</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># 没有后续元素，退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>除了iter()返回的各种iterable object的 Iterator外，以<code>f = open(FILEPATH)</code>获得的file对象和以<code>E = enumerate(&#39;spam&#39;)</code>获得的enumerate对象也是Iterator.</p><hr><p>rstrip() ：the string method to remove whitespace on the right side. （也就是说，使用line.rstrip()的话，如果右边不是空白字符如\n,\t,\r,空格的话就不会被清除，是一种比较安全的去除右端空白字符的方法，而line[:-1]可能丢失有效信息 ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = f.readlines()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">'import sys'</span>, <span class="string">'print(sys.path)'</span>, <span class="string">'x = 2'</span>, <span class="string">'print(x ** 32)'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Optimal solution. It's efficient: </span></span><br><span class="line"><span class="comment">#1: fast(work is done inside the Python interpreter)</span></span><br><span class="line"><span class="comment">#2: list comprehensions' advantages for large files</span></span><br><span class="line"><span class="comment">#3: remarkably expressive</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">'import sys'</span>, <span class="string">'print(sys.path)'</span>, <span class="string">'x = 2'</span>, <span class="string">'print(x ** 32)'</span>]</span><br></pre></td></tr></table></figure><p>rstrip == right strip，同理，还有个lstrip方法（strip：去除）</p><p>另外：从读取到存储过程中的各种字符串操作（upper(), spilt(), replace(), in, slice）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.upper() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[<span class="string">'IMPORT SYS\n'</span>, <span class="string">'PRINT(SYS.PATH)\n'</span>, <span class="string">'X = 2\n'</span>, <span class="string">'PRINT(X ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.rstrip().upper() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[<span class="string">'IMPORT SYS'</span>, <span class="string">'PRINT(SYS.PATH)'</span>, <span class="string">'X = 2'</span>, <span class="string">'PRINT(X ** 32)'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.split() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[[<span class="string">'import'</span>, <span class="string">'sys'</span>], [<span class="string">'print(sys.path)'</span>], [<span class="string">'x'</span>, <span class="string">'='</span>, <span class="string">'2'</span>], [<span class="string">'print(x'</span>, <span class="string">'**'</span>, <span class="string">'32)'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.replace(<span class="string">' '</span>, <span class="string">'!'</span>) <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[<span class="string">'import!sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x!=!2\n'</span>, <span class="string">'print(x!**!32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">'sys'</span> <span class="keyword">in</span> line, line[:<span class="number">5</span>]) <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)]</span><br><span class="line">[(<span class="keyword">True</span>, <span class="string">'impor'</span>), (<span class="keyword">True</span>, <span class="string">'print'</span>), (<span class="keyword">False</span>, <span class="string">'x = 2'</span>), (<span class="keyword">False</span>, <span class="string">'print'</span>)]</span><br></pre></td></tr></table></figure><hr><p><strong>例：斐波那契数列迭代器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回迭代器对象本身</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回容器下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> self.a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    fib = Fib()    <span class="comment"># fib 是一个迭代器</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'isinstance(fib, Iterator): '</span>, isinstance(fib, Iterator)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fib:</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><hr><p><strong>过滤子句(Filter Clauses):if</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines = [line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>) <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'p'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lines</span><br><span class="line">[<span class="string">'print(sys.path)'</span>, <span class="string">'print(x ** 32)'</span>]</span><br></pre></td></tr></table></figure><p>当然我们也可以写成下面的语句（就是可能会慢）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#it takes up four lines instead of one and may run slower</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>):</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'p'</span>:</span><br><span class="line"><span class="meta">... </span>res.append(line.rstrip())</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="string">'print(sys.path)'</span>, <span class="string">'print(x ** 32)'</span>]</span><br></pre></td></tr></table></figure><p>for声明占用4行，list comprehension 一次只占一行，因此for声明可能一些。</p><p>我们也可以利用list comprehension加很多过滤条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[line.rstrip() <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>) <span class="keyword">if</span> line.rstrip()[<span class="number">-1</span>].isdigit()]</span><br><span class="line">[<span class="string">'x = 2'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fname = <span class="string">r'd:\books\5e\lp5e\draft1typos.txt'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(open(fname).readlines()) <span class="comment"># All lines</span></span><br><span class="line"><span class="number">263</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len([line <span class="keyword">for</span> line <span class="keyword">in</span> open(fname) <span class="keyword">if</span> line.strip() != <span class="string">''</span>]) <span class="comment"># Nonblank lines</span></span><br><span class="line"><span class="number">185</span></span><br></pre></td></tr></table></figure><p>​    ——“List comprehensions can become even more complex if we need them to.”</p><hr><p><strong>list comprehension中的嵌套循环</strong></p><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abc'</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'lmn'</span>]</span><br><span class="line">[<span class="string">'al'</span>, <span class="string">'am'</span>, <span class="string">'an'</span>, <span class="string">'bl'</span>, <span class="string">'bm'</span>, <span class="string">'bn'</span>, <span class="string">'cl'</span>, <span class="string">'cm'</span>, <span class="string">'cn'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#means</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'abc'</span>:</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'lmn'</span>:</span><br><span class="line"><span class="meta">... </span>res.append(x + y)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="string">'al'</span>, <span class="string">'am'</span>, <span class="string">'an'</span>, <span class="string">'bl'</span>, <span class="string">'bm'</span>, <span class="string">'bn'</span>, <span class="string">'cl'</span>, <span class="string">'cm'</span>, <span class="string">'cn'</span>]</span><br></pre></td></tr></table></figure><p>虽然list comprehension expressions为了性能变得很紧凑，但是对于那些“more involved work”，如果使用list comprehension expression 难以理解的话，最好还是用更简单明了的for语句结构。</p><hr><p>除了for外其他可迭代的“built-ins process”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#map</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(str.upper, open(<span class="string">'script2.py'</span>)) <span class="comment"># map is itself an iterable in 3.X</span></span><br><span class="line">&lt;map object at <span class="number">0x00000000029476D8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(str.upper, open(<span class="string">'script2.py'</span>)))</span><br><span class="line">[<span class="string">'IMPORT SYS\n'</span>, <span class="string">'PRINT(SYS.PATH)\n'</span>, <span class="string">'X = 2\n'</span>, <span class="string">'PRINT(X ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#sorted</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(open(<span class="string">'script2.py'</span>))</span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'print(x ** 32)\n'</span>, <span class="string">'x = 2\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#zip</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(open(<span class="string">'script2.py'</span>), open(<span class="string">'script2.py'</span>)))</span><br><span class="line">[(<span class="string">'import sys\n'</span>, <span class="string">'import sys\n'</span>), (<span class="string">'print(sys.path)\n'</span>, <span class="string">'print(sys.path)\n'</span>),</span><br><span class="line">(<span class="string">'x = 2\n'</span>, <span class="string">'x = 2\n'</span>), (<span class="string">'print(x ** 32)\n'</span>, <span class="string">'print(x ** 32)\n'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#enumerate</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(open(<span class="string">'script2.py'</span>)))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'import sys\n'</span>), (<span class="number">1</span>, <span class="string">'print(sys.path)\n'</span>), (<span class="number">2</span>, <span class="string">'x = 2\n'</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">'print(x ** 32)\n'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#filter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(bool, open(<span class="string">'script2.py'</span>))) <span class="comment"># nonempty=True</span></span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#functools.reduce</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools, operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(operator.add, open(<span class="string">'script2.py'</span>))</span><br><span class="line"><span class="string">'import sys\nprint(sys.path)\nx = 2\nprint(x ** 32)\n'</span></span><br></pre></td></tr></table></figure><p>essentially everything in Python’s built-in toolset that scans an object from left to right is defined to use the iteration protocol on the subject object.</p><p>(从Python的内置工具集中，从左到右扫描对象的所有内容定义为在主体对象上使用迭代协议。)</p><p>这甚至包括了 list, tuple等对象 和  字符串的’join’方法 以及一些其他的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(open(<span class="string">'script2.py'</span>))</span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple(open(<span class="string">'script2.py'</span>))</span><br><span class="line">(<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&amp;&amp;'</span>.join(open(<span class="string">'script2.py'</span>))</span><br><span class="line"><span class="string">'import sys\n&amp;&amp;print(sys.path)\n&amp;&amp;x = 2\n&amp;&amp;print(x ** 32)\n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = open(<span class="string">'script2.py'</span>) <span class="comment"># Sequence assignment</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, d</span><br><span class="line">(<span class="string">'import sys\n'</span>, <span class="string">'print(x ** 32)\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *b = open(<span class="string">'script2.py'</span>) <span class="comment"># 3.X extended form</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(<span class="string">'import sys\n'</span>, [<span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'y = 2\n'</span> <span class="keyword">in</span> open(<span class="string">'script2.py'</span>) <span class="comment"># Membership test</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'x = 2\n'</span> <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>] <span class="comment"># Slice assignment</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L[<span class="number">1</span>:<span class="number">3</span>] = open(<span class="string">'script2.py'</span>)</span><br><span class="line"><span class="comment">#[11, 'import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n', 44]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.extend(open(<span class="string">'script2.py'</span>)) <span class="comment"># list.extend method</span></span><br><span class="line"><span class="comment">#[11, 'import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n']</span></span><br></pre></td></tr></table></figure><p>但在读取文件内容上，append方法不同于extend方法：</p><p>​    extend: 把文件内容逐行append进list里</p><p>​    append:  把文件内容整体装在_io.TextIOWrapper对象里，以一个_io.TextIOWrapper对象的形式（而不是多个字符串对象）置于list尾部。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L.append(open(<span class="string">'script2.py'</span>)) <span class="comment"># list.append does not iterate</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">11</span>, &lt;_io.TextIOWrapper name=<span class="string">'script2.py'</span> mode=<span class="string">'r'</span> encoding=<span class="string">'cp1252'</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(L[<span class="number">1</span>])</span><br><span class="line">[<span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>, <span class="string">'print(x ** 32)\n'</span>]</span><br></pre></td></tr></table></figure><hr><p>The built-in dict call accepts an iterable zip result, and so does the set call, as well as the newer set and dictionary comprehension expressions in Python 3.X and 2.7.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(open(<span class="string">'script2.py'</span>))</span><br><span class="line">&#123;<span class="string">'print(x ** 32)\n'</span>, <span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;line <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>)&#125;</span><br><span class="line">&#123;<span class="string">'print(x ** 32)\n'</span>, <span class="string">'import sys\n'</span>, <span class="string">'print(sys.path)\n'</span>, <span class="string">'x = 2\n'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#(ix: line) for (ix, line) in enumerate(open('script2.py'))</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;ix: line <span class="keyword">for</span> ix, line <span class="keyword">in</span> enumerate(open(<span class="string">'script2.py'</span>))&#125;</span><br><span class="line">&#123;<span class="number">0</span>: <span class="string">'import sys\n'</span>, <span class="number">1</span>: <span class="string">'print(sys.path)\n'</span>, <span class="number">2</span>: <span class="string">'x = 2\n'</span>, <span class="number">3</span>: <span class="string">'print(x ** 32)\n'</span>&#125;</span><br></pre></td></tr></table></figure><p>事实上，set 和 dictionary 的comprehension expression 也支持上面我们所见到的拓展语句（extended syntax, 注意这个extended 与extend方法无关…）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;line <span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'script2.py'</span>) <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'p'</span>&#125;</span><br><span class="line">&#123;<span class="string">'print(x ** 32)\n'</span>, <span class="string">'print(sys.path)\n'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;ix: line <span class="keyword">for</span> (ix, line) <span class="keyword">in</span> enumerate(open(<span class="string">'script2.py'</span>)) <span class="keyword">if</span> line[<span class="number">0</span>] == <span class="string">'p'</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'print(sys.path)\n'</span>, <span class="number">3</span>: <span class="string">'print(x ** 32)\n'</span>&#125;</span><br></pre></td></tr></table></figure><p>典型的extended syntax 就是comprehension expression 后面的 if 语句。</p><hr><p>内置函数 sum(), any(), all(), max(), min() 的用法与效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum([<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>]) <span class="comment"># sum expects numbers only</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line">//The any built-ins <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> any items <span class="keyword">in</span> an iterable are <span class="keyword">True</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([<span class="string">'spam'</span>, <span class="string">''</span>, <span class="string">'ni'</span>])</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">//The all built-ins <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> all items <span class="keyword">in</span> an iterable are <span class="keyword">True</span>.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([<span class="string">'spam'</span>, <span class="string">''</span>, <span class="string">'ni'</span>])</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max([<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min([<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>这些函数工具都接收到一些可迭代对象作为参数，然后用迭代器协议扫描它们。</p><p>严格来说，max() 和 min() 也可以用在文件里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>max(open(<span class="string">'script2.py'</span>)) <span class="comment"># Line with max/min string value</span></span><br><span class="line"><span class="string">'x = 2\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(open(<span class="string">'script2.py'</span>))</span><br><span class="line"><span class="string">'import sys\n'</span></span><br></pre></td></tr></table></figure><hr><p>参数以 *arg 的形式传参给函数，那么，这个参数里的数据集将会被解压成单个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c, d)</span>:</span> print(a, b, c, d, sep=<span class="string">'&amp;'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span>&amp;<span class="number">2</span>&amp;<span class="number">3</span>&amp;<span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(*[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment"># Unpacks into arguments</span></span><br><span class="line"><span class="number">1</span>&amp;<span class="number">2</span>&amp;<span class="number">3</span>&amp;<span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(*open(<span class="string">'script2.py'</span>)) <span class="comment"># Iterates by lines too!</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">&amp;print(sys.path)</span><br><span class="line">&amp;x = <span class="number">2</span></span><br><span class="line">&amp;print(x ** <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>还可以用 zip() 来 unzip 一个 zip tuple:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Y = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(X, Y)) <span class="comment"># Zip tuples: returns an iterable</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A, B = zip(*zip(X, Y)) <span class="comment"># Unzip a zip!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#help(zip)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">class zip(object)</span></span><br><span class="line"><span class="string"> |  zip(iter1 [,iter2 [...]]) --&gt; zip object</span></span><br><span class="line"><span class="string"> |  </span></span><br><span class="line"><span class="string"> |  Return a zip object whose .__next__() method returns a tuple where</span></span><br><span class="line"><span class="string"> |  the i-th element comes from the i-th iterable argument.  The .__next__()</span></span><br><span class="line"><span class="string"> |  method continues until the shortest iterable in the argument sequence</span></span><br><span class="line"><span class="string"> |  is exhausted and then it raises StopIteration.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>更多关于zip：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">7</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(i <span class="keyword">for</span> i <span class="keyword">in</span> Z)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(*zip((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">7</span>))))</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">6</span>, <span class="number">7</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#zip() return a zip object which cannot index but force list of results.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># Unlike 2.X lists, cannot index, etc.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z[<span class="number">0</span>]</span><br><span class="line">TypeError: <span class="string">'zip'</span> object <span class="keyword">is</span> <span class="keyword">not</span> subscriptable</span><br><span class="line"></span><br><span class="line"><span class="comment">#Notice that list(*Z) and list(zip(*Z)) just return [].</span></span><br><span class="line"><span class="comment">##It is because Z is an iterator, so that after iterating(Z has been iterated ), Z is exhausted.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Z, Iterator)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Even *Z and list(*zip(arg1,arg2,...)) is a syntax error!</span></span><br><span class="line"><span class="comment">#Renmeber that the *arg is used to unpack a collection of values into individual arguments.</span></span><br><span class="line"><span class="comment">#And *zip(arg1, arg2) is unpacked into two individual arguments, while list() can just takes at most 1 argument, so that list(*zip(arg1,arg2[,...])) is a syntax error, but the syntax like list(*zip((1,),(2,))) is right</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(*zip((<span class="number">1</span>,),(<span class="number">2</span>,)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>zip()会将相同位置的元素装在一个元素个数等于zip()参数个数的tuple中，有的tuple比别的tuple多出一些元素的话，这些元素将会被丢弃。</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">zip()</th></tr></thead><tbody><tr><td style="text-align:left">(1,2,3)<br>(4,5)<br>(6,7)</td><td style="text-align:left">\</td><td>1\</td><td>\</td><td>2\</td><td><br>\</td><td>4\</td><td>\</td><td>5\</td><td><br>\</td><td>6\</td><td>\</td><td>7\</td></tr></tbody></table><p>可以看出来就是一个转置矩阵的效果， 那么 zip(*zip(arg1, arg2,…)) 就是除去不平整的尾数后进行两次转置，也就是相当于：原tuple组去除不平整的尾数。</p><p>zip的迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)) <span class="comment"># zip is the same: a one-pass iterator</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z</span><br><span class="line">&lt;zip object at <span class="number">0x0000000002951108</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(Z)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">20</span>), (<span class="number">3</span>, <span class="number">30</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> pair <span class="keyword">in</span> Z: print(pair) <span class="comment"># Exhausted after one pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> pair <span class="keyword">in</span> Z: print(pair) <span class="comment"># Iterator used automatically or manually</span></span><br><span class="line">...</span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)) <span class="comment"># Manual iteration (iter() not needed)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Z)</span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Z)</span><br><span class="line">(<span class="number">2</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>另注：(1) 是int类型， 要定义只有一个元素的tuple，需要用(1,)的形式，以避免与运算中的括号产生歧义。但是list 和 dictionary 就不用，因为[] 和 {} 没有歧义。</p><hr><p>range() 也是一个 object，属于 <code>&lt;class &#39;range&#39;&gt;</code>，range 是 iterable 的， 因此可以用<code>iter(range(arg))</code>来生成range的迭代器。</p><hr><p>map(映射)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = map(abs, (<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># map returns an iterable, not a list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M</span><br><span class="line">&lt;map object at <span class="number">0x00000000029B75C0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(M) <span class="comment"># Use iterator manually: exhausts results</span></span><br><span class="line"><span class="number">1</span> <span class="comment"># These do not support len() or indexing</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(M)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(M)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(M)</span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> M: print(x) <span class="comment"># map iterator is now empty: one pass only</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = map(abs, (<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># Make a new iterable/iterator to scan again</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> M: print(x) <span class="comment"># Iteration contexts auto call next()</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(abs, (<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>))) <span class="comment"># Can force a real list if needed</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>mapping class（映射类型）只有dict，但是有一个map()函数，返回的是map类型（注意区分！）</p><table><thead><tr><th>mapping</th><th>map()</th></tr></thead><tbody><tr><td>dict</td><td>map</td></tr></tbody></table><p>关于map()函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">map</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">map</span><span class="params">(func, *iterables)</span> --&gt; map object</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  Make an iterator that computes the function using arguments from</span></span><br><span class="line"><span class="class"> |  each of the iterables.  Stops when the shortest iterable is exhausted.</span></span><br></pre></td></tr></table></figure><hr><p>filter:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">filter</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">filter</span><span class="params">(function or None, iterable)</span> --&gt; filter object</span></span><br><span class="line"><span class="class"> |  </span></span><br><span class="line"><span class="class"> |  Return an iterator yielding those items of iterable for which function(item)</span></span><br><span class="line"><span class="class"> |  is true. If function is <span class="keyword">None</span>, return the items that are true.</span></span><br></pre></td></tr></table></figure><p>It returns items in an iterable for which a passed-in function returns True.</p><p>(True includes nonempty objects) </p><p>(bool returns an object’s truth value)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>filter(bool, [<span class="string">'spam'</span>, <span class="string">''</span>, <span class="string">'ni'</span>])</span><br><span class="line">&lt;filter object at <span class="number">0x00000000029B7B70</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(bool, [<span class="string">'spam'</span>, <span class="string">''</span>, <span class="string">'ni'</span>]))</span><br><span class="line">[<span class="string">'spam'</span>, <span class="string">'ni'</span>]</span><br></pre></td></tr></table></figure><hr><p>iterator 有一个很重要的特性就是被读取之后就不能寻回之前的数据了，简而言之它具有单向性和不可逆性。</p><hr><p>有一点要注意区别：对于不同的类型生成的迭代器，他们的性质有所区别</p><p>对于同一个range对象R，I1和I2是使用R生成的两个迭代器，注意到I1和I2的迭代进程是独立的。</p><p>​    这就是range对象的 multiple pass Iterator 的特性：it supports multiple iterators over its result that remember their positions independently.</p><p>​    （range支持len 和 indexing）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>R = range(<span class="number">3</span>) <span class="comment"># range allows multiple iterators</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(R)</span><br><span class="line">TypeError: range object <span class="keyword">is</span> <span class="keyword">not</span> an iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1 = iter(R)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I2 = iter(R) <span class="comment"># Two iterators on one range</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1) <span class="comment"># I1 is at a different spot than I2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>而map, zip, filter 不是这样，这些类型的某个对象生成的不同的迭代器的迭代进程是共享的，因为：the iter call is optional for stepping through such objects’results—their iter is themselves。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Z = zip((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1 = iter(Z)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I2 = iter(Z) <span class="comment"># Two iterators on one zip</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line">(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I1)</span><br><span class="line">(<span class="number">2</span>, <span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2) <span class="comment"># (3.X) I2 is at same spot as I1!</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>M = map(abs, (<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>)) <span class="comment"># Ditto for map (and filter)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1 = iter(M); I2 = iter(M)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(I1), next(I1), next(I1))</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2) <span class="comment"># (3.X) Single scan is exhausted!</span></span><br><span class="line">StopIteration</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>R = range(<span class="number">3</span>) <span class="comment"># But range allows many iterators</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I1, I2 = iter(R), iter(R)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[next(I1), next(I1), next(I1)]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(I2) <span class="comment"># Multiple active scans, like 2.X lists</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>简而言之就是，对于自身就是迭代器的对象来说，迭代进程是共享的，自身不是迭代器的对象迭代进程不是共享的。</p><p>因为对于range这些<code>isinstance(object, Iterator)</code>返回<code>False</code>的类型来说，iter(range(arg))实际上是创建了一个新的Iterator，因此创建的Iterator是独立的。</p><p>而zip, map, filter 这些对象都是<code>isinstance(object, Iterator)</code>返回<code>True</code>的，他们自己就是迭代器，iter()实际上就是引用了自身，所以无论用iter()创建多少个Iterator对象实际上都只有原对象自己一个，对每一个Iterator对象操作实际上都是操作原对象，因此进程就共享了。</p><hr><p>Dictionary View Iterables：</p><p>the dictionary keys, values, and items methods return iterable view objects that generate result items one at a time, instead of producing result lists all at once in memory</p><p>dict对象的 key, values 和 items 方法能返回 iterable 的 “view 对象”(view object)（但不是Iterator，所以要用next()的话得手动 iter() 生成相应的Iterator。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>D = dict(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>K = D.keys() <span class="comment"># A view object in 3.X, not a list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>K</span><br><span class="line">dict_keys([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(K) <span class="comment"># Views are not iterators themselves</span></span><br><span class="line">TypeError: dict_keys object <span class="keyword">is</span> <span class="keyword">not</span> an iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> D.keys(): print(k, end=<span class="string">' '</span>) <span class="comment"># All iteration contexts use auto</span></span><br><span class="line">...</span><br><span class="line">a b c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>V = D.values() <span class="comment"># Ditto for values() and items() views</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>V</span><br><span class="line">dict_values([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(V) <span class="comment"># Need list() to display or index as list</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>V[<span class="number">0</span>]</span><br><span class="line">TypeError: <span class="string">'dict_values'</span> object does <span class="keyword">not</span> support indexing</span><br><span class="line"><span class="comment">#The views (view object, incluing dict_values, dict_keys, dict_items) does not support len(), index</span></span><br></pre></td></tr></table></figure><p>Finally, remember again that because keys no longer returns a list, the traditional coding pattern for scanning a dictionary by sorted keys won’t work in 3.X. Instead, convert keys views first with a list call, or use the sorted call on either a keys view or the dictionary itself, as follows.</p><p>keys不返回list，因此不能通过排列好的keys来扫描一个字典。</p><p>对每一个keys view 或者 dictionary 它自己使用排序调用（sorted call）。</p><p>或者把keys view 转换成一个列表调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(D.items())</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (k, v) <span class="keyword">in</span> D.items(): print(k, v, end=<span class="string">' '</span>)</span><br><span class="line">...</span><br><span class="line">a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> sorted(D.keys()): print(k, D[k], end=<span class="string">' '</span>)</span><br><span class="line">...</span><br><span class="line">a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> sorted(D): print(k, D[k], end=<span class="string">' '</span>) <span class="comment"># "Best practice" key sorting</span></span><br><span class="line">...</span><br><span class="line">a <span class="number">1</span> b <span class="number">2</span> c <span class="number">3</span></span><br></pre></td></tr></table></figure><hr><p>本章完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：这一章主要是讲迭代（迭代器以及可迭代对象） 和 推导式（comprehension）&lt;/p&gt;
&lt;p&gt;comprehension 就是 类似于list(x for x in object) 这种&lt;/p&gt;
&lt;p&gt;iteration 包括 Iterator  和 Iterable 的对象，以及各种迭代器的使用，其中配合comprehension的话迭代器能发挥更多作用&lt;/p&gt;
    
    </summary>
    
      <category term="Learning Python" scheme="http://KunKin.github.io/categories/Learning-Python/"/>
    
    
      <category term="Python" scheme="http://KunKin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Learning MySQL</title>
    <link href="http://KunKin.github.io/2018/05/16/Learning-MySQL/"/>
    <id>http://KunKin.github.io/2018/05/16/Learning-MySQL/</id>
    <published>2018-05-16T03:49:02.000Z</published>
    <updated>2018-05-16T07:52:39.635Z</updated>
    
    <content type="html"><![CDATA[<p>显示MySql数据库物理文件存放位置：</p><p>cmd :   show global variables like “%datadir”;</p><p>使用命令行连接MySQL：</p><p>mysql -u root -p</p><a id="more"></a> <hr><p>我们知道，在ms sql server中或access中，<br>若要查询前10条记录，使用top 10即可，<br>但在mysql中不支持这个写法。</p><p>LIMIT可以实现top N查询，也可以实现M至N（某一段）的记录查询，具体语法如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM MYTABLE</span><br><span class="line"></span><br><span class="line">ORDER BY AFIELD </span><br><span class="line"></span><br><span class="line">LIMIT offset, recnum</span><br></pre></td></tr></table></figure><p>其中OFFSET为从第几条（M+1）记录开始，recnum为返回的记录条数。例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from mytable</span><br><span class="line"></span><br><span class="line">ORDER BY afield </span><br><span class="line"></span><br><span class="line">LIMIT 2, 5</span><br></pre></td></tr></table></figure><p>即意为从第3条记录开始的5条记录。</p><p>那么《SQL必知必会》中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT TOP 5 prod_name</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure><p>在MySQL中的等价语句是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">LIMIT 0,5;</span><br></pre></td></tr></table></figure><hr><p>降序是用DESC关键字：</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; ORDER BY prod_price DESC;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BR03    |      11.99 | 18 inch teddy bear  |</span><br><span class="line">| RYL01   |       9.49 | King doll           |</span><br><span class="line">| RYL02   |       9.49 | Queen doll          |</span><br><span class="line">| BR02    |       8.99 | 12 inch teddy bear  |</span><br><span class="line">| BR01    |       5.99 | 8 inch teddy bear   |</span><br><span class="line">| RGAN01  |       4.99 | Raggedy Ann         |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>DESC是接在要降序的列名后面，而不是所有列名后面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; ORDER BY prod_price, prod_name DESC;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">| RGAN01  |       4.99 | Raggedy Ann         |</span><br><span class="line">| BR01    |       5.99 | 8 inch teddy bear   |</span><br><span class="line">| BR02    |       8.99 | 12 inch teddy bear  |</span><br><span class="line">| RYL02   |       9.49 | Queen doll          |</span><br><span class="line">| RYL01   |       9.49 | King doll           |</span><br><span class="line">| BR03    |      11.99 | 18 inch teddy bear  |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; FROM Products</span><br><span class="line">    -&gt; ORDER BY prod_price DESC, prod_name DESC;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BR03    |      11.99 | 18 inch teddy bear  |</span><br><span class="line">| RYL02   |       9.49 | Queen doll          |</span><br><span class="line">| RYL01   |       9.49 | King doll           |</span><br><span class="line">| BR02    |       8.99 | 12 inch teddy bear  |</span><br><span class="line">| BR01    |       5.99 | 8 inch teddy bear   |</span><br><span class="line">| RGAN01  |       4.99 | Raggedy Ann         |</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; from Products</span><br><span class="line">    -&gt; order by prod_price DESC, prod_name;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BR03    |      11.99 | 18 inch teddy bear  |</span><br><span class="line">| RYL01   |       9.49 | King doll           |</span><br><span class="line">| RYL02   |       9.49 | Queen doll          |</span><br><span class="line">| BR02    |       8.99 | 12 inch teddy bear  |</span><br><span class="line">| BR01    |       5.99 | 8 inch teddy bear   |</span><br><span class="line">| RGAN01  |       4.99 | Raggedy Ann         |</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">+---------+------------+---------------------+</span><br></pre></td></tr></table></figure><p>DESC也可以写成DESCENGING。</p><p>（另外还有升序  ASC和 ASCENDING ，但是由于升序是默认的，所以ASC没什么用）</p><hr><p><strong>过滤</strong></p><p>用WHERE子句</p><p>但是ORDER BY 子句与WHERE子句同用时，ORDER BY 子句需要放在WHERE 子句后，不然会出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; from products</span><br><span class="line">    -&gt; order by prod_price DESC, prod_name</span><br><span class="line">    -&gt; where prod_price = &apos;3.49&apos;;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;where prod_price = &apos;3.49&apos;&apos; at line 4</span><br><span class="line"></span><br><span class="line">mysql&gt; select prod_id, prod_price, prod_name</span><br><span class="line">    -&gt; from Products</span><br><span class="line">    -&gt; where prod_price = &apos;3.49&apos;</span><br><span class="line">    -&gt; order by prod_price DESC, prod_name</span><br><span class="line">    -&gt; ;</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| prod_id | prod_price | prod_name           |</span><br><span class="line">+---------+------------+---------------------+</span><br><span class="line">| BNBG02  |       3.49 | Bird bean bag toy   |</span><br><span class="line">| BNBG01  |       3.49 | Fish bean bag toy   |</span><br><span class="line">| BNBG03  |       3.49 | Rabbit bean bag toy |</span><br><span class="line">+---------+------------+---------------------+</span><br></pre></td></tr></table></figure><p>WHERE 子句操作符：</p><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;&gt;</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">!&lt;</td><td style="text-align:center">不小于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">!&gt;</td><td style="text-align:center">不大于</td></tr><tr><td style="text-align:center">BETWEEN</td><td style="text-align:center">在指定的两个值之间</td></tr><tr><td style="text-align:center">IS NULL</td><td style="text-align:center">为NULL值</td></tr></tbody></table><hr><p><strong>NULL 和 非匹配</strong></p><p>空值检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_email IS NULL;</span><br><span class="line"></span><br><span class="line">cust_name</span><br><span class="line">----------</span><br><span class="line">Kids Place</span><br><span class="line">The Toy Store</span><br></pre></td></tr></table></figure><p>通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL值的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返回这些结果。</p><p>过滤数据时，一定要验证被过滤列中含NULL的行确实出现在返回的数据中。</p><hr><p><strong>通配符%可以匹配0、1、多个字符，但不匹配NULL</strong></p><hr><p><strong>通配符%请注意空格：</strong></p><p>包括Access在内的许多DBMS都用空格来填补字段的内容，例如，某列有50个字符，而存储的文本为<code>Fish bean bag toy</code>（17个字符），则为了填满该列需要在文本后附加33个空格。这样做一般对数据及其使用没有影响，但是可能对<code>WHERE prod_name LIKE &#39;F%y&#39;</code>这样的语句有负面影响。子句<code>WHERE prod_name LIKE &#39;F%y&#39;</code>只匹配以F开头、以y结尾的prod_name。如果值后面跟空格，则不是以y结尾，所以<code>Fish bean bag toy</code>就不会被检索出来。简单的解决办法是用<code>F%y%</code>，但是更好的解决方法是用函数去掉空格。</p><hr><p>通配符<code>%</code>匹配任意个字符，<code>_</code>匹配一个字符。</p><p>DB2不支持<code>_</code></p><p>Microsoft Access用的是<code>?</code>而非<code>_</code></p><hr><p>SELECT子句顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">FROM</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">HAVING</span><br><span class="line">ORDER BY</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;显示MySql数据库物理文件存放位置：&lt;/p&gt;
&lt;p&gt;cmd :   show global variables like “%datadir”;&lt;/p&gt;
&lt;p&gt;使用命令行连接MySQL：&lt;/p&gt;
&lt;p&gt;mysql -u root -p&lt;/p&gt;
    
    </summary>
    
      <category term="Learning MySQL" scheme="http://KunKin.github.io/categories/Learning-MySQL/"/>
    
    
      <category term="MySQL" scheme="http://KunKin.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Chapter28.A More Realistic Example</title>
    <link href="http://KunKin.github.io/2018/05/16/Chapter28-A-More-Realistic-Example/"/>
    <id>http://KunKin.github.io/2018/05/16/Chapter28-A-More-Realistic-Example/</id>
    <published>2018-05-16T03:47:35.000Z</published>
    <updated>2018-05-16T07:52:25.843Z</updated>
    
    <content type="html"><![CDATA[<p>前言：正如章题所言，本章中我们将建立一个类集(set of classes)，以实现一些具体的东西——记录和处理有关人的信息。在后面我们将会看到，我们所说的实例(instance)和类(class) 能够起到与传统术语中的记录(record)和规划(program)一样的作用。</p><p>Python的类系统实际上主要只是在对象树中搜索属性，伴随着一个特别的 函数的第一个参数。(Despite its syntax details, Python’s class system really is largely just a matter of searching for an attribute in a tree of objects, along with a special first argument for functions.)</p><a id="more"></a> <hr><h3 id="第一步：制作实例-Making-Instance"><a href="#第一步：制作实例-Making-Instance" class="headerlink" title="第一步：制作实例(Making Instance)"></a>第一步：制作实例(Making Instance)</h3><h4 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person.py (start)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span> <span class="comment"># Start a class</span></span><br></pre></td></tr></table></figure><h4 id="构造方法（constructor-method）"><a href="#构造方法（constructor-method）" class="headerlink" title="构造方法（constructor method）"></a>构造方法（constructor method）</h4><p>​    实例对象属性通常是这么创建的：赋值给类的方法函数(method function)中的self属性。 为实例属性赋初始值的常规方式是在__init__构造方法中将它们分配给self，__init__构造方法中包含了每次创建实例时Python都会自动运行的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add record field initialization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job, pay)</span>:</span> <span class="comment"># Constructor takes three arguments</span></span><br><span class="line">        self.name = name <span class="comment"># Fill out fields when created</span></span><br><span class="line">        self.job = job <span class="comment"># self is the new instance object</span></span><br><span class="line">        self.pay = pay</span><br></pre></td></tr></table></figure><p>这是一种非常常见的编码模式：我们将要附加到instance的数据作为参数传递给构造函数方法，并将它们分配给自身以永久保留它们。<br>从面向对象的角度来说，self是新创建的实例对象，name，job和pay成为保存在对象上的状态信息——供以后使用的描述性数据。 尽管其他技术（例如封闭作用域引用闭包）也可以节省细节，但实例属性使其非常明确且易于理解。</p><p>注意，self.job 是类的属性，而job是__init__函数范围内的变量，两者同名而异出。通过把局部变量job的值赋给self.job 属性，可以把传参存在对象里以供之后使用。</p><p>一般来说，在Python里一定要明了：一个name在哪里被分配，或者这个name被赋值给了什么对象。</p><p>事实上，__init__函数虽然名字奇怪(wired)，但是它只是一个普通的函数，正如同一般的函数一样，我们能够给它的参数们提供的默认值(default)，这样就可以防止它们的值不可用(unavailable)或者没用(unuseful)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span> <span class="comment"># Normal function args</span></span><br><span class="line">self.name = name</span><br><span class="line">  self.job = job</span><br><span class="line">self.pay = pay</span><br></pre></td></tr></table></figure><h4 id="一边写一边测试"><a href="#一边写一边测试" class="headerlink" title="一边写一边测试"></a>一边写一边测试</h4><blockquote><p>增量模型是把待开发的软件系统模块化，将每个模块作为一个增量组件，从而分批次地分析、设计、编码和测试这些增量组件。运用增量模型的软件开发过程是递增式的过程。相对于瀑布模型而言，采用增量模型进行开发，开发人员不需要一次性地把整个软件产品提交给用户，而是可以分批次进行提交。</p></blockquote><p>编程最好以增量模型的形式编程，进行单元测试。</p><p>Python虽然有交互式的测试，但是它是很乏味的：每次都要重新导入模块并且重新输入测试样例。所以Python的交互式提示一般都是用来进行简单的一次性测试的。</p><p>更加实质性的测试：在包含了要测试的对象的文件底部编写代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add incremental self-test code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">        </span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>) <span class="comment"># Test the class</span></span><br><span class="line">sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>) <span class="comment"># Runs __init__ automatically</span></span><br><span class="line">print(bob.name, bob.pay) <span class="comment"># Fetch attached attributes</span></span><br><span class="line">print(sue.name, sue.pay) <span class="comment"># sue's and bob's attrs differ</span></span><br></pre></td></tr></table></figure><p>注意到bob用了默认值；而sue在创建对象的时候用到了关键字参数(keyword argument)，当然也可以依靠位置来代替，不过用关键字有两个两个好处：1、关键字能提醒我们这个数据是什么；2、用关键字允许我们不按顺序地输入参数。</p><p>上面那个例子的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; person.py</span><br><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br></pre></td></tr></table></figure><p>从技术上讲，Bob和Sue都是命名空间对象(namespace objects)，就像所有的类实例一样，它们都有自己独立的由类创建的状态信息副本。 因为类的每个实例都有自己的一组self属性，所以类以这种方式自然地记录多个对象的信息; 就像内置类型（如列表和字典）一样，类可以作为一种对象工厂(object factory)。</p><p>上面的测试方法有个很大的缺陷：每次文件作为脚本运行并作为模块导入时，它的top-level print语句都会运行，因此如果我们在导入了这个文件中的这个类，那么每次导入文件时print语句也会跟着文件导入，于是每次导入文件时都会看到测试代码的输出。</p><p>为了克服这个缺陷，我们使用__name__模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: <span class="comment"># When run for testing only</span></span><br><span class="line">    <span class="comment"># self-test code</span></span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob.name, bob.pay)</span><br><span class="line">    print(sue.name, sue.pay)</span><br></pre></td></tr></table></figure><p>上面这个文件作为top-level 脚本运行时，将运行测试语句，因为这时文件的__name__是__main__；</p><p>而当文件作为一个类库(library of classes)被导入到其他文件时，测试语句将不会被运行，因为上面这个文件的__name__并不是__main__：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; person.py</span><br><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">C:\code&gt; python</span><br><span class="line">Python <span class="number">3.3</span><span class="number">.0</span> (v3<span class="number">.3</span><span class="number">.0</span>:bd8afb90ebf2, Sep <span class="number">29</span> <span class="number">2012</span>, <span class="number">10</span>:<span class="number">57</span>:<span class="number">17</span>) ...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> person</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="第二步：添加行为方法（Adding-Behavior-Methods）"><a href="#第二步：添加行为方法（Adding-Behavior-Methods）" class="headerlink" title="第二步：添加行为方法（Adding Behavior Methods）"></a>第二步：添加行为方法（Adding Behavior Methods）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Process embedded built-in types: strings, mutability</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob.name, bob.pay)</span><br><span class="line">    print(sue.name, sue.pay)</span><br><span class="line">    print(bob.name.split()[<span class="number">-1</span>]) <span class="comment"># Extract object's last name</span></span><br><span class="line">    sue.pay *= <span class="number">1.10</span> <span class="comment"># Give this object a raise</span></span><br><span class="line">    print(<span class="string">'%.2f'</span> % sue.pay)</span><br></pre></td></tr></table></figure><p>后三行是新加的，当它们运行的时候，我们将bob的姓(last name)提取了出来并通过基本数字操作修改她的薪资属性来支付薪水。某种意义上来说，sue也是一个可变对象，她的状态就像list一样在调用append后一样就地改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line">Smith</span><br><span class="line"><span class="number">110000.00</span></span><br></pre></td></tr></table></figure><p>但是这样子的代码并不是好主意，像这些类以外的（outside of the class）硬编码操作很可能会导致维护问题：当需要改变工作方式或薪酬时，需要搜索并更新每一个事件、修改多个副本等，而这些代码通常是分散的，频繁的变动几乎是必然的。所以我们需要写<strong>方法函数（coding method）</strong></p><hr><p><strong>编写方法（Coding Methods）</strong></p><p>——<strong>encapsulation(封装)</strong></p><p>​     在接口后面封装操作逻辑，使得每个操作在我们的程序中只编码一次。好处是：分解代码以消除冗余，从而优化可维护性；将operation转换为method可以将它们应用于类的任何实例，而不仅仅是那些被硬编码处理的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add methods to encapsulate operations for maintainability</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.job = job</span><br><span class="line">self.pay = pay</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span> <span class="comment"># Behavior methods</span></span><br><span class="line"><span class="keyword">return</span> self.name.split()[<span class="number">-1</span>] <span class="comment"># self is implied subject</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">self.pay = int(self.pay * (<span class="number">1</span> + percent)) <span class="comment"># Must change here only</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob.name, bob.pay)</span><br><span class="line">    print(sue.name, sue.pay)</span><br><span class="line">    print(bob.lastName(), sue.lastName()) <span class="comment"># Use the new methods</span></span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>) <span class="comment"># instead of hardcoding</span></span><br><span class="line">    print(sue.pay)</span><br></pre></td></tr></table></figure><p>method只是普通的函数，它们附属于类并且被设计用来处理这些类的实例。</p><p>这个instance是调用method的主体(subject)，并被自动传递给method的self参数。</p><p>现在运行时，我们的文件输出与之前类似 - 我们大多只是重构了代码，以允许在未来更轻松地进行更改，而不会改变其行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line">Smith Jones</span><br><span class="line"><span class="number">110000</span></span><br></pre></td></tr></table></figure><p>上例中有些问题：在加薪之后，现在的薪水仍然是一个整数 - 我们通过调用方法内置的int来将数学结果转换为整数，整数和浮点对象具有相同的接口并可在表达式中混合使用。我们可以用<code>round(N,2)</code>来四舍五入并保留cent、使用decimal类型确定精度、或将货币值存储为完整的浮点数并用<code>%.2f</code>或<code>{0:.2f}</code>格式化字符串来表现它们以显示cent。</p><p>formats.py模块中的money函数可以显示逗号，美分和货币符号。</p><p>Python通过自动将实例传递给方法的第一个参数（通常称为self）来告诉方法要处理哪个实例。</p><p>• bob.lastName()，bob是传递给self的隐含主体(implied subject)。<br>• sue.lastName()，sue替换了self。</p><p>最终效果是每一次调用，方法都获取了隐含主体(implied subject)的名(name).（The net effect is that the method fetches the name of the implied subject each time）</p><p>此外，例中的<code>giveRaisse</code>方法假定了<code>percent</code>是以0到1之间的浮点数的形式传进来的，这个假设健壮性太差(1000%的加薪也不是没可能，但是1000%是10，输进去就是BUG了)。因此要注意考虑函数参数实际可能的范围。在后面的章节中会用到函数装饰器(function decorator)和断言(assert)语句，它们能够在开发过程中自动进行有效性测试。(顺带一提，单元测试也用到了assert)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@rangetest(percent=(0.0, 1.0)) # Use decorator to validate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br></pre></td></tr></table></figure><hr><h3 id="第三步：操作器重载"><a href="#第三步：操作器重载" class="headerlink" title="第三步：操作器重载"></a>第三步：操作器重载</h3><p>现在，我们有一个相当全面的类来生成和初始化实例，以及以method形式处理instance的两个新behavior。</p><p>尽管如此，测试仍然不方便：为了跟踪我们的对象，我们必须手动获取并打印各个属性(individual attributes)。不幸的是，实例对象的默认显示格式不是很好——它显示对象的类名和内存地址（除了作为唯一标识符外，它在Python中基本上是无用的）。</p><p>把脚本的最后一行改成<code>print(sue)</code>以便将对象表现为一个整体，于是我们将看到：<code>sue</code>是3.X中的“对象(object)”，是2.X中的“实例(instance)”:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bob Smith <span class="number">0</span></span><br><span class="line">Sue Jones <span class="number">100000</span></span><br><span class="line">Smith Jones</span><br><span class="line">&lt;__main__.Person object at <span class="number">0x00000000029A0668</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>提供打印显示</strong></p><p>使用操作器重载能做得更好——在一个类里编写方法，这些方法能够在运行类的实例时，截取(intercept)和处理(process)内置操作。</p><p>具体而言，我们可以利用Python中仅次于__init__的第二个最常用的运算符重载方法：__repr__方法和__str__方法。</p><p>每当一个实例被转换成它的打印字符串（就是<code>&lt;__main__.Person object at 0x00000000029A0668&gt;</code>这种形式的）时，__repr__方法和__str__方法会被自动运行。</p><p>因为这就是打印一个对象所做的事情，所以，如果该对象定义了一个对象自身(defines one itself)，或者继承了一个超类的话，那么净传递效果(the net transitive effect)是打印这个对象，这个对象会显示这个对象的__str__或__repr__方法返回的内容（无论返回了什么）。此外，双下划线名称将如同任何其他名称一样被继承。</p><p>（Because that’s what printing an object does, the net transitive effect is that printing an object displays whatever is returned by the object’s __str__ or __repr__ method, if the object either defines one itself or inherits one from a superclass. Double-underscored names are inherited just like any other.）</p><p>从技术上说，<code>__str__</code>优于<code>print</code>和<code>str</code>，并且<code>__repr__</code>被用作这些函数(<code>__str__</code>、<code>print</code>、<code>str</code>)以及所有其他上下文(context，译成”运行环境”会好点？)的备用(fallback)。虽然<code>__str__</code>和<code>__repr__</code>二者都可以用于在不同的context中实现不同的显示，但仅编写<code>__repr__</code>就足以在所有情况下给出单独的显示——打印、嵌套外观和交互式反馈(interactive echoes)。而<code>__str__</code>只有在有限的文章里才可以被用来作为替代显示（an alternative display）。</p><p>我们已经编写的<code>__init__</code>构造函数方法严格来说也是操作符重载 - 它在构造时自动运行以初始化新创建的实例。 然而，构造函数非常普遍，这使得构造函数看起来几乎像一个特例。 像<code>__repr__</code>这样目标更明确(focused)的方法允许我们利用特定的操作并在我们的对象用于这些context时提供专门的行为(specialized behavior)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add __repr__ overload method for printing objects</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">    self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span> <span class="comment"># Added method</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)  <span class="comment"># String to print</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob)</span><br><span class="line">    print(sue)</span><br><span class="line">    print(bob.lastName(), sue.lastName())</span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(sue)</span><br></pre></td></tr></table></figure><p>注意，这里用了字符串的<code>%</code>格式化去构建在<code>__repr__</code>中的显示字符串。在底层，类会使用类似的build-in type objects and operations 去完成任务。在很大程度上，类只是添加了一个将功能和数据打包在一起并支持扩展的额外结构层(an additional layer of <em>structure</em>)。  </p><p>本例还改变了我们的自测代码(self-test code)去直接输出整个对象，而不是打印个别属性。 运行时，输出(output)现在变得更加的连贯以及有意义; “[…]”行由我们的新<code>__repr__</code>返回，由<code>print</code>操作自动运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: Sue Jones, <span class="number">110000</span>]</span><br></pre></td></tr></table></figure><p><strong>这样，利用对<code>__repr__</code>方法的重载，我们在别的文件中就能直接通过<code>print(ObjectName)</code>来获得对象的attribute。</strong></p><p>设计注意事项：<code>__repr__</code>方法经常用于在提供一个代码的低级别对象显示，而<code>__str__</code>则用于更多user-friendly的信息显示。 有时类用<code>__str__</code>为用户友好的显示提供，用<code>__repr__</code>为开发人员提供额外的详细信息。 因为<code>print</code> 调用<code>__str__</code>，而交互式提示与<code>__repr__</code>相呼应，所以这可以为目标受众(target audiences)提供适当的显示。<br>由于<code>__repr__</code>适用于更多的展示案例，包括嵌套外表，并且由于我们对显示两种不同格式不感兴趣，因此全面的<code>__repr__</code>足以满足我们的课程。</p><hr><h3 id="第四步：用子类自定义行为-Customizing-Behavior-by-Subclassing"><a href="#第四步：用子类自定义行为-Customizing-Behavior-by-Subclassing" class="headerlink" title="第四步：用子类自定义行为(Customizing Behavior by Subclassing)"></a>第四步：用子类自定义行为(Customizing Behavior by Subclassing)</h3><p>现在这个类尚未用到的唯一一个OOP的主要概念是使用继承的自定义(customization by inheritance)。</p><p>我们将定义一个父类/子类(superclass/subclass)关系，它允许扩展这个软件并将一些行为替换为继承行为。</p><p><strong>编写子类</strong></p><p>定义一个<code>Person</code>的子类:<code>Manager</code>，<code>Manager</code>用一个更有针对性的版本来替换被继承的<code>giveRaise</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span> <span class="comment"># Define a subclass of Person</span></span><br></pre></td></tr></table></figure><p>格式为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subclass</span><span class="params">(superclass)</span>:</span> <span class="comment"># Define a subclass of Person</span></span><br></pre></td></tr></table></figure><p>According to the inheritance search rules, the lowest version of the name wins：采用最低级别（父子关系中最低级别）的函数(跟Java一样)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span> <span class="comment"># Inherit Person attrs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span> <span class="comment"># Redefine to customize</span></span><br></pre></td></tr></table></figure><p>下面是一个糟糕的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">self.pay = int(self.pay * (<span class="number">1</span> + percent + bonus)) <span class="comment"># Bad: cut and paste</span></span><br></pre></td></tr></table></figure><p>这个例子中的函数内容仅仅是从父类中复制粘贴而来的。这与原来的运行结果一模一样，但是维护难度却加倍了了——比如要针对所有人员都修改提薪的方式(算法)，我们不仅需要修改父类，还要修改子类，这使得维护的工作量加倍了。</p><p>好的例子应当是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">Person.giveRaise(self, percent + bonus) <span class="comment"># Good: augment original</span></span><br></pre></td></tr></table></figure><p>直接调用父类中的函数，那么要针对所有人员都修改提薪的方式(算法)时，直接修改父类中的函数就可以了。</p><p>一个类的方法总是可以被实例调用（常见，Python通常会自动将实例发送到<code>self</code>变量）或者被类调用（不常见，必须手动传递该实例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.method(args...)</span><br></pre></td></tr></table></figure><p>会被Python自动转换成等价的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>.<span class="title">method</span><span class="params">(instance, args...)</span></span></span><br></pre></td></tr></table></figure><p>通过类直接调用会严重地破坏继承，并且将调用级别在类树(class tree)提高了——为了运行一个特别的版本。在我们的例子中，我们可以使用这种技术在Person中调用默认的<code>GiveRaise</code>，尽管它已经在 Manager 级别上重新定义了。</p><p>在某种意义上，我们必须通过Person调用，因为Manager的 <code>giveRaise</code> 代码中的<code>self.giveRaise()</code>会循环——因为 self 已经是 Manager，<code>self.giveRaise()</code>会再次解析为<code>Manager.giveRaise</code>，等等如此递归直到可用内存耗尽。</p><p>（如果<code>Person.giveRaise</code>改成<code>self.giveRaise</code>那么就会出现： self.giveRaise(args…)  –&gt; Manager.giveRaise(self,args…) –&gt; self.giveRaise(self,args…) –&gt; ……）</p><p>这种写法保证了我们想要能够执行标准的GiveRaise操作，只是做了一些额外的添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add customization of one behavior in a subclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">    self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span> <span class="comment"># Redefine at this level</span></span><br><span class="line">Person.giveRaise(self, percent + bonus) <span class="comment"># Call Person's version</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob)</span><br><span class="line">    print(sue)</span><br><span class="line">    print(bob.lastName(), sue.lastName())</span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(sue)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="string">'mgr'</span>, <span class="number">50000</span>) <span class="comment"># Make a Manager: __init__</span></span><br><span class="line">    tom.giveRaise(<span class="number">.10</span>) <span class="comment"># Runs custom version</span></span><br><span class="line">    print(tom.lastName()) <span class="comment"># Runs inherited method</span></span><br><span class="line">    print(tom) <span class="comment"># Runs inherited __repr__</span></span><br></pre></td></tr></table></figure><p>说白了跟Java里的继承一样。</p><p>Java程序员可能特别感兴趣的是知道Python也有一个super内置函数，允许更一般地回调父类的方法 。但是继承父类有很多缺点，因此使用要谨慎：一旦你继续进行多重继承，它不是你想象的那样，甚至超出了你所认为的范围。它所调用的类可能根本不是父类，甚至可能根据context而不同。或者改述一句电影台词：Python的父类就像一盒巧克力——你永远不知道你会得到什么！</p><p><strong>行为的多态性</strong></p><p>为了使这种对继承行为的捕获(acquisition of inherited behavior)更加清晰，我们可以在我们的文件末尾添加以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ...</span><br><span class="line">    print(<span class="string">'--All three--'</span>)</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> (bob, sue, tom):<span class="comment"># Process objects generically</span></span><br><span class="line">        obj.giveRaise(<span class="number">.10</span>)    <span class="comment"># Run this object's giveRaise</span></span><br><span class="line">        print(obj)   <span class="comment"># Run the common __repr__</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: Sue Jones, <span class="number">110000</span>]</span><br><span class="line">Jones</span><br><span class="line">[Person: Tom Jones, <span class="number">60000</span>]</span><br><span class="line">--All three--</span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">121000</span>]</span><br><span class="line">[Person: Tom Jones, <span class="number">72000</span>]</span><br></pre></td></tr></table></figure><p>在添加的代码中，object是一个Person或者一个Manager，Python自动运行相应的<code>giveRaise</code>，<code>giveRaise</code>是根据对象的类型分派的。正如我们所知，多态性是Python灵活性的核心。</p><p>另一方面，打印针对所有三个对象运行相同的<code>__repr__</code>，因为它只在Person中编码一次（Person）,而Manager负责的是特化和应用(specialize and apply)我们原先写在Person上的代码。虽然这个例子很小，但它已经利用OOP的定制和重用代码的天赋;有了类，这几乎像是自动的。</p><p><strong>继承，定制以及拓展(Inherit, Customize, and Extend)</strong></p><p>事实上，类可能比我们的例子更灵活。 通常，类可以inherit，customize或extend超类中的现有代码。 例如，尽管我们专注于customize，但如果Manager需要完全不同的东西（Python同名引用，Python namesake reference intended），我们还可以向Manager中添加不存在于Person中的特有(unique)方法。 在下例中，<code>giveRaise</code>重新定义了一个超类的方法来定制它，但是<code>someThingElse</code>定义了一些新的扩展方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span> ...</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span>    <span class="comment"># Inherit</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, ...)</span>:</span> ... <span class="comment"># Customize</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">someThingElse</span><span class="params">(self, ...)</span>:</span> ... <span class="comment"># Extend</span></span><br><span class="line">        </span><br><span class="line">tom = Manager()</span><br><span class="line">tom.lastName() <span class="comment"># Inherited verbatim</span></span><br><span class="line">tom.giveRaise() <span class="comment"># Customized version</span></span><br><span class="line">tom.someThingElse() <span class="comment"># Extension here</span></span><br><span class="line">print(tom) <span class="comment"># Inherited overload method</span></span><br></pre></td></tr></table></figure><p><code>someThingElse</code>中定制的方法只能用被Manager类的对象使用，而对于非Manager的Person类对象来说是不能使用<code>someThingElse</code>的。</p><p><strong>面向对象编程的主要观念(OOP: The Big Idea)</strong></p><p>我们通过自定义已完成的内容进行编程，而不是复制或更改现有代码。总的来说，与其他方法相比，类所隐含的编程风格可以从根本上缩短开发时间。</p><p>例如，在上面的例子中，理论上可以不需要子类化就实现一个自定义的<code>giveRaise</code>操作，但是其他选项产生的代码都不够优化：<br>​    •虽然我们可以简单地将Manager从头开始编码为新的独立代码，但我们必须重新实现Person中与Managers相同的所有行为。<br>​    •虽然我们可以简单地改变现有的Person 类，以满足Manager给予的要求，但这样做可能会破坏我们仍然需要原始Person behavior的地方。<br>​    •尽管我们可以简单地复制Person类的全部内容，将副本更名为Manager，并更改了<code>GiveRaise</code>，但这样做会导致代码冗余，从而加倍我们未来的工作量——将来对Person所做的更改不会被Manager自动pick up，而是必须手动传递(propagated)到Manager的代码里。复制粘贴方法现在看起来可能很快，但它将来会使您的工作翻倍。</p><p>用类构建的可定制层次结构(customizable hierarchies)为随着时间推移而发展的软件提供了更好的解决方案。 Python中没有其他工具支持这种开发模式。因为我们可以通过编写新的子类来定制和扩展(tailor and extend)我们之前的工作，所以我们可以利用我们已经完成的工作，而不是每次从头开始，打破已有的工作，或者引入多个在将来可能需要更新的代码副本。如果用得好，OOP是程序员的一个强大盟友。</p><hr><h3 id="第五步：自定义构造函数-Customizing-Constructors-Too"><a href="#第五步：自定义构造函数-Customizing-Constructors-Too" class="headerlink" title="第五步：自定义构造函数(Customizing Constructors, Too)"></a>第五步：自定义构造函数(Customizing Constructors, Too)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person.py</span></span><br><span class="line"><span class="comment"># Add customization of constructor in a subclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">self.job = job</span><br><span class="line">self.pay = pay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">    self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[Person: %s, %s]'</span> % (self.name, self.pay)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span> <span class="comment"># Redefine constructor</span></span><br><span class="line">Person.__init__(self, name, <span class="string">'mgr'</span>, pay)  <span class="comment"># Run original with 'mgr'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">Person.giveRaise(self, percent + bonus)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob)</span><br><span class="line">    print(sue)</span><br><span class="line">    print(bob.lastName(), sue.lastName())</span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(sue)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)  <span class="comment"># Job name not needed:</span></span><br><span class="line">    tom.giveRaise(<span class="number">.10</span>)     <span class="comment"># Implied/set by class</span></span><br><span class="line">    print(tom.lastName())</span><br><span class="line">    print(tom)</span><br></pre></td></tr></table></figure><p>子类中定制构造函数</p><p>虽然构造函数有一个奇怪的名字，但效果是一样的。因为我们也需要Person的构建逻辑来运行（初始化实例属性），所以我们必须这样调用它;否则，实例不会附加任何属性。</p><p>从重定义(redefine)中调用超类的构造函数，这种方式证明是Python中常见的编码模式。Python使用继承来查找并在构造时只调用类树中最底层的那个<code>__init__</code>方法。如果你需要更高级的<code>__init__</code>方法在构造时运行（通常你会这样做），你必须手动调用它们，一般是通过超类的名字来调用它们。这样做的好处是可以清楚地知道将哪个参数传递给超类的构造函数，并且可以选择根本不调用它：不调用超类构造函数可以让你完全替代它的逻辑，而不是增强它。<br>这个文件的自测代码的输出和以前一样 - 我们没有改变它的功能，我们只是简单地重组来消除一些逻辑冗余：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: Sue Jones, <span class="number">110000</span>]</span><br><span class="line">Jones</span><br><span class="line">[Person: Tom Jones, <span class="number">60000</span>]</span><br></pre></td></tr></table></figure><p><strong>面向对象编程比你想象的更加简单(OOP Is Simpler Than You May Think)</strong></p><p>本章到这里已经介绍了Python 中OOP机制(machinery)的所有重要概念:</p><p>·创建实例——填写实例属性</p><p>·行为方法——将逻辑封装在类的方法中</p><p>·操作重载——为内置操作（如print）提供行为</p><p>·定制行为——在子类中重新定义方法以对它们进行专门化</p><p>·定制构造器—为超类步骤添加初始化逻辑</p><p><em>**</em>注意：重载和定制看着很像（都是改变既定方法），但是在概念上有所区别</p><p>这些概念大多基于三个简单的观点：对象树中属性的继承搜索(the inheritance search<br>for attributes in object trees)；方法中特别的self变量；操作重载对方法的自动调度(dispatch)。</p><p>我们还通过利用(harnessing)类的分解代码倾向(propensity for factoring code)来减少冗余(redundancy)，使我们的代码在将来更易于更改。例如，我们在方法中封装了逻辑，并从扩展中调用回超类方法，以避免具有相同代码的多个副本。这些步骤中的大部分都是阶级结构化力量的自然结果。<br>总的来说，这就是Python中的OOP。类肯定会变得比这更大，并且还有一些更高级的类概念，比如装饰器(decorators)和元类(metaclasses)，我们将在后面的章节中讨论这些概念。然而，就基础知识而言，我们的课程已经完成了这一切。事实上，如果你已经掌握了我们编写的类的工作方式，那么大多数OOP Python代码现在应该在你的范围之内。</p><p><strong>组合类的其他方式(Other Ways to Combine Classes)</strong></p><p>虽然OOP的基本机制在Python中很简单，但在较大程序中，将类放在一起的方式也是一种艺术。此前我们关注继承，是因为它是Python提供的机制，但是也有其他方式来组合class。</p><p>例如，有一种常见的编码模式，就涉及到将对象嵌套在一起以构建组合(composite)。这更多是与设计有关而非与Python。作为一个简单的例子，我们可以通过嵌入一个Person(而非继承)来使用这个组合思想，从而拓展Manager。</p><p>下面的代码在文件person-composite.py中编码，通过使用<code>__getattr__</code>操作的重载方法来拦截未定义的属性提取(attribute fetches)，并用内置的getattr将它们交给嵌入对象。 通过getattr调用获取属性与通过  “X.Y” 形式(如 Tom.job)获取属性相同，并且因此表现出继承，区别在于属性名称Y是一个运行时字符串(runtime string)。<br>通过结合这些工具，这里的giveRaise方法仍然通过改变传递给嵌入对象的参数来实现定制。实际上，Manager成为一个控制层，将调用传递给(down to)嵌入对象，而不是超类方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person-composite.py</span></span><br><span class="line"><span class="comment"># Embedding-based Manager alternative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">...same...</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span></span><br><span class="line">    self.person = Person(name, <span class="string">'mgr'</span>, pay) <span class="comment"># Embed a Person object</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">    self.person.giveRaise(percent + bonus) <span class="comment"># Intercept and delegate</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> getattr(self.person, attr)    <span class="comment"># Delegate all other attrs</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(self.person)   <span class="comment"># Must overload again (in 3.X)</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">...same...</span><br></pre></td></tr></table></figure><p>这个Manager替代方案代表了一种通常称为<strong>委托(delegation)</strong>的通用编码模式——一种基于组合的结构，用于管理被包装的对象(wrapped object)并向其发送(propagate)方法调用。</p><p>这个模式适用于我们的例子，但它需要大约两倍的代码，并且对于我们想要直接表达的直接自定义类型而言，不如继承合适(is less well suited than inheritance to the kinds of direct customizations we meant to express)。</p><p>在这里，Manager并不是真正的Person，所以我们需要用额外的代码来手动将方法调用分发给嵌入对象；运算符重载方法（如<code>__repr__</code>）必须重新定义；并且添加新的管理器行为并不那么直接，因为状态信息被删除了一个级别。</p><p>尽管如此，当嵌入对象需要与容器进行比direct customization所表明的交互更有限的交互时，对象嵌入(object embedding)和基于对象嵌入的设计模式(design patterns)能够很好地吻合。</p><p> 例如，如果我们想要将类适应到它不支持的预期接口，或者跟踪或验证对另一个对象方法的调用，那么像这样的控制器层或代理(controller layer or proxy)可能会派上用场。</p><p>此外，假设的Department类可以聚合(aggregate)其他对象，以便将它们作为一组来处理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File person-department.py</span></span><br><span class="line"><span class="comment"># Aggregate embedded objects into a composite</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">...same...</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">...same...</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">    self.members = list(args)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addMember</span><span class="params">(self, person)</span>:</span></span><br><span class="line">    self.members.append(person)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaises</span><span class="params">(self, percent)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> person <span class="keyword">in</span> self.members:</span><br><span class="line">    person.giveRaise(percent)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showAll</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> person <span class="keyword">in</span> self.members:</span><br><span class="line">print(person)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line">    </span><br><span class="line">    development = Department(bob, sue) <span class="comment"># Embed objects in a composite</span></span><br><span class="line">    development.addMember(tom)</span><br><span class="line">    development.giveRaises(<span class="number">.10</span>) <span class="comment"># Runs embedded objects' giveRaise</span></span><br><span class="line">    development.showAll() <span class="comment"># Runs embedded objects' __repr__</span></span><br></pre></td></tr></table></figure><p>运行时，Department的<code>showAll</code>方法能够列出当前状态下部门中所有人的信息:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">[Person: Sue Jones, <span class="number">110000</span>]</span><br><span class="line">[Person: Tom Jones, <span class="number">60000</span>]</span><br></pre></td></tr></table></figure><p>在Python 3.X中，以及在启用3.X的“new style”类的2.X中时，我们在本章编写的文件person-composite.py的另一个基于委托(delegation-based)的Manager类，如果不重新定义运算符的重载方法属性，将不能够 拦截并委托(intercept and delegate) 运算符的重载方法属性(operator<br>overloading method attributes)（如<code>__repr__</code>）。虽然我们知道<code>__repr__</code>是我们具体示例中唯一使用的名称，但这对于基于委托的类来说是一个普遍问题。</p><p>回想一下，诸如打印和添加等内置操作隐式地调用操作符重载方法，如<code>__repr__</code>和<code>__add__</code>。在3.X的新样式类(new-style classes)中，像这样的内置操作不会通过通用属性管理器(generic attribute manager)来路由(route)它们的隐式属性提取：既不调用<code>__getattr__</code>（运行未定义的属性）也不调用<code>__getattribute__</code>（针对所有属性运行）。这就是为什么我们必须在替代管理器中重新定义<code>__repr__</code>以确保将打印路由到3.X中的嵌入式Person对象。</p><p>在上上个例子中注释掉<code>__repr__</code>方法，输出变成了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c:\code&gt; py −<span class="number">3</span> person-composite.py</span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">...etc...</span><br><span class="line">&lt;__main__.Manager object at <span class="number">0x00000000029AA8D0</span>&gt;</span><br><span class="line"></span><br><span class="line">c:\code&gt; py −<span class="number">2</span> person-composite.py</span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line">...etc...</span><br><span class="line">[Person: Tom Jones, <span class="number">60000</span>]</span><br></pre></td></tr></table></figure><p>从技术上讲，这是因为内置操作在2.X的默认经典类中开始隐式搜索实例中的方法名称，但从3.X强制的new-style classes开始，完全跳过实例。相比之下，显式的名称属性提取总是首先在两个模型中路由到实例。在2.X经典类中，内置路由属性也是这种方式——打印，例如，路由<code>__repr__</code>到<code>__getattr__</code>。这就是为什么对Manager作注释的<code>__repr__</code>在2.X中没有效果：该调用委托给了Person。new-style classes也从它们的自动对象(automatic object)的超类中继承了<code>__repr__</code>的默认值，这会阻止<code>__getattr__</code>，但new-style的<code>__getattribute__</code>不会拦截该名称。</p><hr><h3 id="第六步：使用自检工具-Using-Introspection-Tools"><a href="#第六步：使用自检工具-Using-Introspection-Tools" class="headerlink" title="第六步：使用自检工具(Using Introspection Tools)"></a>第六步：使用自检工具(Using Introspection Tools)</h3><p>现在我们完成并演示了Python OOP的大部分基础。但是还有一点小问题：</p><p>·第一，print(Tom)出来的是Person而非更具体的Manager，从技术上来说这是不对的：不够精确。</p><p>·第二，也是更重要的：当前的显示格式只显示了我们在<code>__repr__</code>中包含的属性，这对拓展是不利的，或许解释不了未来的目标。例如，我们还不能验证tom的job名称是否已由Manager的构造函数正确设置为mgr，因为我们为Person编码的<code>__repr__</code>不打印此字段。 更糟糕的是，如果我们在<code>__init__</code>中扩展或以其他方式更改分配给我们对象的一组属性，我们必须记住还要更新<code>__repr__</code>以显示新名称，否则随着时间的推移它会变得不同步。</p><p>最后一点意味着，我们再次通过在代码中引入冗余来为自己做出潜在的额外工作。 因为<code>__repr__</code>中的任何差异都会反映在程序的输出中，所以这种冗余可能比我们之前提到的其他形式更明显; 仍然，避免未来额外的工作通常是一件好事。</p><p><strong>特殊的类属性</strong></p><p>这些问题我们可以用Python的内检工具来解决，这些工具有特殊的属性和函数，可以访问对象实现(objects’ implementations)的内部。这些工具有些高级，通常用于编写其他程序员使用的工具，而不是用作程序员开发应用程序时使用的工具。</p><p>·内置的 <code>instance.__class__</code>属性提供了从instance到创建这个实例的class的链接。类像模块一样有一个<code>__name__</code>，以及一个用于提供超类访问的<code>__bases__</code>队列，我们可以在这里使用它们（而不是我们自己硬编码出来的代码）来打印创建实例的类的名称。</p><p>·内置的<code>object.__dict__</code>属性为附加到名称空间对象的每个属性提供一个包含一个键/值对的字典（包括模块，类和实例）。 因为它是一个字典，所以我们可以获取它的键列表(fetch its key list)，按键索引(index by key)，遍历键(iterate over its keys)等等，来通用地处理所有属性。 我们可以在这里使用它来打印任何实例中的所有属性，而不仅仅是我们在自定义显示中进行硬编码的属性。</p><p>对上面二者的快速回顾（注意：如何在交互式提示符下使用from语句加载Person——类名称存在并从模块中导入，与函数名称和其他变量完全相同）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> person <span class="keyword">import</span> Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob <span class="comment"># Show bob's __repr__ (not __str__)</span></span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(bob)  <span class="comment"># Ditto: print =&gt; __str__ or __repr__</span></span><br><span class="line">[Person: Bob Smith, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob.__class__   <span class="comment"># Show bob's class and its name</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">person</span>.<span class="title">Person</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">bob</span>.<span class="title">__class__</span>.<span class="title">__name__</span></span></span><br><span class="line"><span class="class">'<span class="title">Person</span>'</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">list</span><span class="params">(bob.__dict__.keys<span class="params">()</span>)</span>   # <span class="title">Attributes</span> <span class="title">are</span> <span class="title">really</span> <span class="title">dict</span> <span class="title">keys</span></span></span><br><span class="line">['pay', 'job', 'name']   # Use list to force list in 3.X</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line">print(key, <span class="string">'=&gt;'</span>, bob.__dict__[key]) <span class="comment"># Index manually</span></span><br><span class="line">pay =&gt; 0</span><br><span class="line">job =&gt; None</span><br><span class="line">name =&gt; Bob Smith</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> bob.__dict__:</span><br><span class="line">print(key, <span class="string">'=&gt;'</span>, getattr(bob, key)) <span class="comment"># == obj.attr  (but attr is a var)</span></span><br><span class="line">pay =&gt; 0</span><br><span class="line">job =&gt; None</span><br><span class="line">name =&gt; Bob Smith</span><br></pre></td></tr></table></figure><p>如果实例的类定义了<code>__slots__</code>，那么可以从实例访问的某些属性可能不会存储在<code>__dict__</code>字典中：比如说，new-style classes的可选且相对模糊的特征（因此包括了Python 3.X中的所有类）在实例中有序地存储了属性;可能完全排除实例<code>__dict__</code>。由于<strong>插槽(slot)</strong>实际上属于类而不是实例，并且由于它们在任何情况下都很少使用，所以我们可以在这里合理地忽略它们，并将注意力集中在正常的<code>__dict__</code>上。</p><p>但是，正如我们所做的那样，请记住，某些程序可能需要为缺少的<code>__dict__</code>捕获异常，或者如果用户可能会部署插槽，则使用<code>hasattr</code>来测试或<code>getattr</code>以及默认值。下一节的代码如果被带有插槽的类使用（如果它缺乏插槽，那么<code>__dict__</code>的存在是可以保证的），它不会fail，但插槽和其他“虚拟”属性不会作为实例数据报告。</p><p><strong>一个通用显示工具</strong></p><p>我们可以将这些接口(interface)用在显示准确类名的超类中，并格式化任何类(any class)的实例的所有属性。下面的例子中，因为<code>__repr__</code>的显示重载使用了通用自检工具，所以它将在任何实例上工作，而不管实例的属性如何设置。</p><p>因为这是一个类，它会自动成为一个通用的格式化工具：由于继承，它可以加入到任何希望使用其显示格式的类中。 还有一个额外的好处，如果我们想要改变实例的显示方式，我们只需要改变这个类，因为继承它的<code>__repr__</code>的每个类在下次运行时都会自动选择新的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File classtools.py (new)</span></span><br><span class="line"><span class="string">"Assorted class utilities and tools"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttrDisplay</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Provides an inheritable display overload method that shows</span></span><br><span class="line"><span class="string">    instances with their class names and a name=value pair for</span></span><br><span class="line"><span class="string">    each attribute stored on the instance itself (but not attrs</span></span><br><span class="line"><span class="string">    inherited from its classes). Can be mixed into any class,</span></span><br><span class="line"><span class="string">    and will work on any instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gatherAttrs</span><span class="params">(self)</span>:</span></span><br><span class="line">        attrs = []</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> sorted(self.__dict__):</span><br><span class="line">        attrs.append(<span class="string">'%s=%s'</span> % (key, getattr(self, key)))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">', '</span>.join(attrs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'[%s: %s]'</span> % (self.__class__.__name__, self.gatherAttrs())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TopTest</span><span class="params">(AttrDisplay)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">            self.attr1 = TopTest.count</span><br><span class="line">            self.attr2 = TopTest.count+<span class="number">1</span></span><br><span class="line">            TopTest.count += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SubTest</span><span class="params">(TopTest)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    X, Y = TopTest(), SubTest()<span class="comment"># Make two instances</span></span><br><span class="line">    print(X)    <span class="comment"># Show all instance attrs</span></span><br><span class="line">    print(Y)   <span class="comment"># Show lowest class name</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[TopTest: attr1=<span class="number">0</span>, attr2=<span class="number">1</span>]</span><br><span class="line">[SubTest: attr1=<span class="number">2</span>, attr2=<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>把<code>X, Y = TopTest(), SubTest()</code>换成<code>X, Y = SubTest(), TopTest()</code>输出变成了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[SubTest: attr1=<span class="number">0</span>, attr2=<span class="number">1</span>]</span><br><span class="line">[TopTest: attr1=<span class="number">2</span>, attr2=<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>(类型自身的属性被改变：每次创建一个新的<code>TopTest</code>类或者其子类实例，<code>TopTest</code>这个类自身的属性都被改变(count += 2)，并且这个改变是保留效果的，这是因为<code>TopTest</code>作为类本身也是一个对象，利用<code>TopTest</code>生成实例对象，其实也是调用了<code>TopTest</code>这个类的对象来生成新的实例的，调用过程中<code>TopTest</code>这个类的属性被改变了，而作为一个既有对象，在作用域内它的属性改变效果是保留的。)</p><p>↑类属性</p><p><strong>实例与类属性的比较(Instance Versus Class Attributes)</strong></p><p>由于类被附加到继承树底部的self对象上，因此类只显示实例属性—— self 的 <code>__dict__</code>属性所包含的东西，而没有实例从类树中较上层的类继承的属性（例如，计算此文件的自检代码——用作实例计数器的类属性）。继承的类属性仅附加到类，不会复制到实例。</p><p>如果您希望也包含继承属性，您可以爬上(climb)实例类的<code>__class__</code>链接，使用<code>__dict__</code>获取类属性，然后遍历(iterate through)该类的<code>__bases__</code>属性以爬到更高的超类，并根据需要重复。如果你喜欢简单代码，在实例上运行一个内置的<code>dir</code>调用(而非<code>__dict__</code>)会产生和climb相同的效果，因为<code>dir</code>结果在排序结果列表中包含了继承名称：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> person <span class="keyword">import</span> Person</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(bob.__dict__.keys()) <span class="comment"># 3.X keys is a view, not a list</span></span><br><span class="line">[<span class="string">'name'</span>, <span class="string">'job'</span>, <span class="string">'pay'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(bob) <span class="comment"># 3.X includes class type methods</span></span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>,</span><br><span class="line"><span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>,</span><br><span class="line">...more omitted: <span class="number">31</span> attrs...</span><br><span class="line"><span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>,</span><br><span class="line"><span class="string">'giveRaise'</span>, <span class="string">'job'</span>, <span class="string">'lastName'</span>, <span class="string">'name'</span>, <span class="string">'pay'</span>]</span><br></pre></td></tr></table></figure><p>(回顾： 过滤掉带有双下划线的元素：)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dir(bob))</span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(name <span class="keyword">for</span> name <span class="keyword">in</span> dir(bob) <span class="keyword">if</span> <span class="keyword">not</span> name.startswith(<span class="string">'__'</span>))</span><br><span class="line">[<span class="string">'giveRaise'</span>, <span class="string">'job'</span>, <span class="string">'lastName'</span>, <span class="string">'name'</span>, <span class="string">'pay'</span>]</span><br></pre></td></tr></table></figure><p><strong>工具类中的名称注意事项</strong></p><p>最后一个细节,因为<code>classtools</code>模块中的<code>AttrDisplay</code>类是一个通用工具，可以混合到其他任意类中，所以我们必须意识到与客户端类发生意外名称冲突的可能性。 假设客户端子类可能要同时使用它的<code>__repr__</code>和<code>gatherAttrs</code>，但后者可能不仅仅是子类所期望的 - 如果子类无意中定义了它自己的收集<code>Attrs</code>名称，它可能会中断我们的类，因为在子类中的较低版本将被使用，而不是我们的.</p><p>在文件的自测代码中向<code>TopTest</code>添加<code>gatherAttrs</code>; 除非新方法是相同的，或者有意定制原始方法，否则我们的工具类将不再按计划工作——<code>AttrDisplay</code>中的<code>self.gatherAttrs</code>会从<code>TopTest</code>实例重新搜索：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopTest</span><span class="params">(AttrDisplay)</span>:</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gatherAttrs</span><span class="params">(self)</span>:</span> <span class="comment"># Replaces method in AttrDisplay!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Spam'</span></span><br></pre></td></tr></table></figure><p>这不一定是坏的 - 有时我们希望其他方法可用于子类，无论是直接调用还是用这种方式定制。 但是，如果我们真的只想提供一个<code>__repr__</code>，这并不理想。</p><p>为了尽量减少这种名称冲突的可能性，Python程序员通常在名称外部使用添加一个前缀下划线的方法：<code>_gatherAttrs</code>。这不是万无一失的（如果另一个类也定义了<code>_gatherAttrs</code>），但它通常是足够的，并且它是Python类的内部方法常见的命名约定。</p><p>一个更好的但不常用的解决方案是在方法名前面使用两个下划线：<code>__gatherAttrs</code>给我们。</p><p>Python自动扩展这些名称来包含封闭类的名称，这使得它们在通过继承搜索查找时真正具有唯一性， 这是一个通常称为伪类属性的功能。</p><p><strong>类的最终形式(Our Classes’ Final Form)</strong></p><p>现在，为了在我们的类中使用这个通用工具，我们需要做的就是从它的模块中导入它，并通过在我们的顶级类中继承来mix它，并且摆脱我们之前编码得更具体的<code>__repr__</code>。 新的重载显示方法将由Person和Manager的实例来继承; Manager从Person中获取<code>__repr__</code>，它现在从另一个模块中编码的<code>AttrDisplay</code>中获取它。 以下是应用这些更改的我们的person.py文件的最终版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File classtools.py (new)</span></span><br><span class="line">...<span class="keyword">as</span> listed earlier...</span><br><span class="line"></span><br><span class="line"><span class="comment"># File person.py (final)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Record and process information about people.</span></span><br><span class="line"><span class="string">Run this file directly to test its classes.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> classtools <span class="keyword">import</span> AttrDisplay <span class="comment"># Use generic display tool</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(AttrDisplay)</span>:</span> <span class="comment"># Mix in a repr at this level</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create and process person records</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, job=None, pay=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.job = job</span><br><span class="line">        self.pay = pay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastName</span><span class="params">(self)</span>:</span>   <span class="comment"># Assumes last is last</span></span><br><span class="line">    <span class="keyword">return</span> self.name.split()[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent)</span>:</span>    <span class="comment"># Percent must be 0..1</span></span><br><span class="line">    self.pay = int(self.pay * (<span class="number">1</span> + percent))</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A customized Person with special requirements</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, pay)</span>:</span></span><br><span class="line">    Person.__init__(self, name, <span class="string">'mgr'</span>, pay) <span class="comment"># Job name is implied</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">giveRaise</span><span class="params">(self, percent, bonus=<span class="number">.10</span>)</span>:</span></span><br><span class="line">    Person.giveRaise(self, percent + bonus)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bob = Person(<span class="string">'Bob Smith'</span>)</span><br><span class="line">    sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">    print(bob)</span><br><span class="line">    print(sue)</span><br><span class="line">    print(bob.lastName(), sue.lastName())</span><br><span class="line">    sue.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(sue)</span><br><span class="line">    tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line">    tom.giveRaise(<span class="number">.10</span>)</span><br><span class="line">    print(tom.lastName())</span><br><span class="line">    print(tom)</span><br></pre></td></tr></table></figure><p>由于是最终版，我们添加了一些注释——用于功能性描述的docstrings(“””… …”””)，用于小笔记的#，方法之间的空行——以在类或者方法变得large时增加可读性。</p><p>当我们现在运行这个代码时，我们看到了对象的所有属性，而不仅仅是我们在原始<code>__repr__</code>中硬编码的那些属性。 我们的最终问题得到了解决：因为<code>AttrDisplay</code>直接从自身实例中取出类名，所以每个对象都显示为最接近（最低）的类的名称，现在显示为Manager，而不是Person，最后我们可以验证他的job名称已由Manager构造函数正确填写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; person.py</span><br><span class="line">[Person: job=<span class="keyword">None</span>, name=Bob Smith, pay=<span class="number">0</span>]</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">100000</span>]</span><br><span class="line">Smith Jones</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">110000</span>]</span><br><span class="line">Jones</span><br><span class="line">[Manager: job=mgr, name=Tom Jones, pay=<span class="number">60000</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="最终步：在数据库中存储对象-Step-7-Final-Storing-Objects-in-a-Database"><a href="#最终步：在数据库中存储对象-Step-7-Final-Storing-Objects-in-a-Database" class="headerlink" title="最终步：在数据库中存储对象(Step 7 (Final): Storing Objects in a Database)"></a>最终步：在数据库中存储对象(Step 7 (Final): Storing Objects in a Database)</h3><p>现在，我们的工作几乎完成。我们现在有一个双模块系统，它不仅实现了我们的原始设计目标来代表人，还提供了一个通用的属性显示工具，我们可以在将来的其他程序中使用它。通过编写模块文件中的函数和类，我们确保它们自然支持重用。通过将我们的软件编码为类，我们确保它自然支持扩展。<br>尽管我们的类按计划运行，但他们创建的对象并不是真正的数据库记录。也就是说，如果我们关闭Python，我们的实例将会消失——它们是内存中的瞬态对象，不会像文件一样存储在更永久的介质中，所以它们在未来的程序运行中将不可用。事实证明，使实例对象更加永久是件容易的事情，它具有称为对象持久性的Python特性——在创建它们的程序退出后，使对象继续存在。作为本教程的最后一步，让我们使对象成为永久的。</p><p>名词解释：</p><p>储存器pickle : 将任意Python对象序列化为一串字节</p><p>dbm(Database management module) ：实现用于存储字符串的按键存取文件系统</p><p>shelve ：使用其他两个模块通过密钥将Python对象存储在文件上</p><p><strong>存储器模块(The pickle module)</strong></p><p>pickle模块是一种超常的对象格式化和解格式化工具：在内存中给出了一个几乎任意的Python对象，它都能将对象转换为一串字节，之后这串字节可以用来重建内存中的原始对象。 pickle模块几乎可以处理任何你可以创建的对象——list，dictionary以及它们的嵌套组合和类实例。 后者是特别有用的东西，因为它们提供了数据（属性）和行为（方法）; 实际上，这个组合大致相当于“记录”和“程序”。因为pickle是如此普遍，所以它可以将额外的代码替换掉，或者您可能会编写它来创建和解析对象的自定义文本文件表示(custom text file representations)。 通过将一个对象的pickle字符串存储在一个文件中，可以使其永久持久：只需稍后加载并取消它即可重新创建原始对象。</p><p><strong>书架模块(The shelve module)</strong></p><p>尽管使用pickle本身很容易将对象存储在简单的平面文件中，并在稍后将其加载，但shelve模块提供了一个额外的结构层，允许您通过键存储pickle的对象。 shelve使用pickle将对象转换为它的pickled字符串，并将该字符串存储在dbm文件中的键下;当稍后加载时，shelve通过键提取pickled字符串，并用pickle在内存中重新创建原始对象。这完全是一个窍门，但是对于你的脚本来说，一个搁置对象的东西看起来就像dictionary——你可以通过索引来获取索引，分配给键来存储，并使用诸如<code>len</code>，<code>in</code>和<code>dict.keys</code>之类的字典工具来获取信息。书架自动将字典操作映射到存储在文件中的对象。<br>实际上，对于您的脚本，shelve和普通dictionary之间唯一的编码区别在于，您必须首先打开shelve，并且在更改后必须关闭它们。<br>最终结果是，shelve提供了一个简单的数据库，用于通过键存储和获取本地Python对象，从而使它们在程序运行期间保持持久性。它不支持诸如SQL之类的查询工具，并且它缺少在企业级数据库中找到的一些高级功能（例如真正的事务处理），但是存储在shelve上的本地Python对象一旦被键取回，可能会被使用Python语言的全部功能进行处理(be processed with the full power of the Python language)。</p><p><strong>在书架数据库里存储对象(Storing Objects on a Shelve Database)</strong></p><p>现在我们编写一个命名为makedb.py的文件来将类的对象放到shelve里，由于这是一个新文件，因此我们需要导入我们的类以创建一些存储实例。 我们之前使用它来在交互提示中加载一个类，但实际上，与函数和其他变量一样，有两种方法可以从文件加载类（类名与变量类似于any other，并且在这个运行环境中根本不奇怪）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> person  <span class="comment"># Load class with import</span></span><br><span class="line">bob = person.Person(...)  <span class="comment"># Go through module name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person <span class="comment"># Load class with from</span></span><br><span class="line">bob = Person(...)   <span class="comment"># Use name directly</span></span><br></pre></td></tr></table></figure><p>使用<code>from</code>来加载脚本能使得输入变少一点。</p><p>一定有了实例，放在shelve上是很容易的，只需导入shelve模块，使用外部文件名打开一个新shelve，将对象分配给shelve中的键，并在完成后关闭shelve。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File makedb.py: store Person objects on a shelve database</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> person <span class="keyword">import</span> Person, Manager <span class="comment"># Load our classes</span></span><br><span class="line">bob = Person(<span class="string">'Bob Smith'</span>)    <span class="comment"># Re-create objects to be stored</span></span><br><span class="line">sue = Person(<span class="string">'Sue Jones'</span>, job=<span class="string">'dev'</span>, pay=<span class="number">100000</span>)</span><br><span class="line">tom = Manager(<span class="string">'Tom Jones'</span>, <span class="number">50000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.open(<span class="string">'persondb'</span>)  <span class="comment"># Filename where objects are stored</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> (bob, sue, tom):   <span class="comment"># Use object's name attr as key</span></span><br><span class="line">db[obj.name] = obj  <span class="comment"># Store object on shelve by key</span></span><br><span class="line">db.close() <span class="comment"># Close after making changes</span></span><br></pre></td></tr></table></figure><p>将名称作为关键字分配给shelve是要为了方便，事实上，密钥可以是任何字符串，包括我们可能使用工具ID和时间戳（可在OS和时间标准库模块中获得）等工具创建的唯一字符串。唯一的规则是键必须是字符串，并且应该是唯一的，因为我们可以为每个键只存储一个对象，尽管该对象可以是列表字典或其他包含许多对象本身的对象。</p><p>事实上，我们存储在键下的值可以是几乎任何类型的Python对象，如字符串，列表和字典的内置类型，以及用户定义的类实例，以及所有这些和更多的嵌套组合。</p><p><strong>以交互方式探索书架(Exploring Shelves Interactively)</strong></p><p>此时，当前目录中有一个或多个真实文件，其名称全部以“persondb”开头。创建的实际文件可能因平台而异，与内置的打开函数一样，除非它包含目录路径，否则shelve.open()中的文件名与当前工作目录相关。这些文件无论存储在哪里，都会实现一个包含我们三个Python对象的pickled表示的键控访问文件。不要删除这些文件 - 它们是您的数据库，并且是备份或移动存储时需要复制或传输的文件。</p><p>我们可以从Windows资源管理器或Python shell中查看shelve文件，但它们是二进制散列文件(binary hash files)，并且它们的大部分内容在shelve模块的运行环境之外没有多大意义。</p><p>使用Python 3.X并没有安装额外的软件，我们的数据库存储在三个文件中（在2.X中，它只是一个文件，persondb，因为bsddb扩展模块预装了Python for shelf;在3.X中，bsddb是一个可选的第三方开源插件）。例如，Python的标准库glob模块允许我们在Python代码中获取目录列表来验证这些文件，并且我们可以用文本或二进制模式打开这些文件来探索字符串和字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>glob.glob(<span class="string">'person*'</span>)</span><br><span class="line">[<span class="string">'person-composite.py'</span>, <span class="string">'person-department.py'</span>, <span class="string">'person.py'</span>, <span class="string">'person.pyc'</span>,</span><br><span class="line"><span class="string">'persondb.bak'</span>, <span class="string">'persondb.dat'</span>, <span class="string">'persondb.dir'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'persondb.dir'</span>).read())</span><br><span class="line"><span class="string">'Sue Jones'</span>, (<span class="number">512</span>, <span class="number">92</span>)</span><br><span class="line"><span class="string">'Tom Jones'</span>, (<span class="number">1024</span>, <span class="number">91</span>)</span><br><span class="line"><span class="string">'Bob Smith'</span>, (<span class="number">0</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(open(<span class="string">'persondb.dat'</span>,<span class="string">'rb'</span>).read())</span><br><span class="line"><span class="string">b'\x80\x03cperson\nPerson\nq\x00)\x81q\x01&#125;q\x02(X\x03\x00\x00\x00jobq\x03NX\x03\x00</span></span><br><span class="line"><span class="string">...more omitted...</span></span><br></pre></td></tr></table></figure><p>这个内容不是不可能破译，但它在不同的平台上可能有所不同，并且它不是一个易于使用的数据库接口！ 为了更好地验证我们的工作，我们可以编写另一个脚本，或者在交互式提示符下翻找我们的shelve。 因为shelve是包含了Python对象的Python对象，所以我们可以用普通的Python语法和开发模式来处理它们。 在这里，交互式提示有效地成为数据库客户端(database client)：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(<span class="string">'persondb'</span>) <span class="comment"># Reopen the shelve</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(db) <span class="comment"># Three 'records' stored</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(db.keys()) <span class="comment"># keys is the index</span></span><br><span class="line">[<span class="string">'Sue Jones'</span>, <span class="string">'Tom Jones'</span>, <span class="string">'Bob Smith'</span>] <span class="comment"># list() to make a list in 3.X</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob = db[<span class="string">'Bob Smith'</span>] <span class="comment"># Fetch bob by key</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob <span class="comment"># Runs __repr__ from AttrDisplay</span></span><br><span class="line">[Person: job=<span class="keyword">None</span>, name=Bob Smith, pay=<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bob.lastName() <span class="comment"># Runs lastName from Person</span></span><br><span class="line"><span class="string">'Smith'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> db: <span class="comment"># Iterate, fetch, print</span></span><br><span class="line">print(key, <span class="string">'=&gt;'</span>, db[key])</span><br><span class="line"></span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=100000]</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key <span class="keyword">in</span> sorted(db):</span><br><span class="line">print(key, <span class="string">'=&gt;'</span>, db[key]) <span class="comment"># Iterate by sorted keys</span></span><br><span class="line"></span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=100000]</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br></pre></td></tr></table></figure><p>请注意，我们无需在此处导入我们的Person或Manager类，以加载或使用我们的存储对象。例如，我们可以自由地调用bob的<code>lastName</code>方法，并自动获得自定义的打印显示格式，即使我们在这里没有他的Person类。这是有效的，因为当Python pickle一个类实例时，它会记录它的自身实例属性，以及它所创建的类的名称和类所在的模块。当bob稍后从shelve中取出并取出时，Python会自动重新导入该类并链接到它。这个方案的结果是，类实例在将来被加载时自动获得他们所有的类行为。我们必须导入我们的类才能创建新的实例，而不是处理现有的实例。虽然这是一个故意的特征，但这个方案的后果有点混杂：</p><p>· 缺点是：当实例稍后加载时，类和它们的模块文件必须是可导入的(importable)。更正式地说，pickleable类必须在sys.path模块搜索路径中列出的目录中可访问的模块文件的顶层编码（并且不应该存在于最顶层的脚本文件的模块<code>__main__</code>中，除非它们在使用时始终处于模块中）。由于这种外部模块文件的要求，有些应用程序会选择更简单的对象，例如字典或列表，特别是要通过Internet传输时。</p><p>· 优点是：类的源代码文件中的更改会在类的实例再次加载时自动更新(picked up);通常不需要自己更新存储对象，因为更新其类的代码会改变它们的行为。</p><p>shelve也有众所周知的局限性（本章最后的数据库建议提到了其中的一些）。对于简单的对象存储，shelve和pickle是非常易于使用的工具。</p><p><strong>更新shelve上的对象</strong></p><p>现在让我们编写一个程序，每次运行它时都会更新一个实例（记录），以证明我们的对象确实是持久的——即每次运行Python程序时它们的当前值都可用。 以下文件updatedb.py打印数据库，并每次都对我们的存储对象进行加注。 如果你追踪这里发生的事情，你会注意到我们获得了很多“免费”的工具——打印对象时会自动使用通用的<code>__repr__</code>重载方法，并且通过调用我们之前编写的giveRaise方法来提薪。 对于基于OOP继承模型的对象，这一切“正常运作”，即使它们在同一个文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># File updatedb.py: update Person object on database</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">db = shelve.open(<span class="string">'persondb'</span>) <span class="comment"># Reopen shelve with same filename</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> sorted(db):   <span class="comment"># Iterate to display database objects</span></span><br><span class="line">print(key, <span class="string">'\t=&gt;'</span>, db[key]) <span class="comment"># Prints with custom format</span></span><br><span class="line"></span><br><span class="line">sue = db[<span class="string">'Sue Jones'</span>]  <span class="comment"># Index by key to fetch</span></span><br><span class="line">sue.giveRaise(<span class="number">.10</span>)   <span class="comment"># Update in memory using class's method</span></span><br><span class="line">db[<span class="string">'Sue Jones'</span>] = sue  <span class="comment"># Assign to key to update in shelve</span></span><br><span class="line">db.close() <span class="comment"># Close after making changes</span></span><br></pre></td></tr></table></figure><p>由于此脚本在启动时打印数据库，因此我们必须至少运行两次以查看我们的对象更改：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; updatedb.py</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=100000]#</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">C:\code&gt; updatedb.py</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=110000]#</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">C:\code&gt; updatedb.py</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=121000]#</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br><span class="line"></span><br><span class="line">C:\code&gt; updatedb.py</span><br><span class="line">Bob Smith =&gt; [Person: job=None, name=Bob Smith, pay=0]</span><br><span class="line">Sue Jones =&gt; [Person: job=dev, name=Sue Jones, pay=133100]#</span><br><span class="line">Tom Jones =&gt; [Manager: job=mgr, name=Tom Jones, pay=50000]</span><br></pre></td></tr></table></figure><p>在交互式提示符下验证我们的脚本的工作——shelve对于数据库客户端的等价物：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\code&gt; python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>db = shelve.open(<span class="string">'persondb'</span>) <span class="comment"># Reopen database</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec = db[<span class="string">'Sue Jones'</span>] <span class="comment"># Fetch object by key</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec</span><br><span class="line">[Person: job=dev, name=Sue Jones, pay=<span class="number">146410</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.lastName()</span><br><span class="line"><span class="string">'Jones'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rec.pay</span><br><span class="line"><span class="number">146410</span></span><br></pre></td></tr></table></figure><hr><p>本章完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：正如章题所言，本章中我们将建立一个类集(set of classes)，以实现一些具体的东西——记录和处理有关人的信息。在后面我们将会看到，我们所说的实例(instance)和类(class) 能够起到与传统术语中的记录(record)和规划(program)一样的作用。&lt;/p&gt;
&lt;p&gt;Python的类系统实际上主要只是在对象树中搜索属性，伴随着一个特别的 函数的第一个参数。(Despite its syntax details, Python’s class system really is largely just a matter of searching for an attribute in a tree of objects, along with a special first argument for functions.)&lt;/p&gt;
    
    </summary>
    
      <category term="Learning Python" scheme="http://KunKin.github.io/categories/Learning-Python/"/>
    
    
      <category term="Python" scheme="http://KunKin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Chapter19.Advanced Function Topics</title>
    <link href="http://KunKin.github.io/2018/05/16/Chapter19-Advanced-Function-Topics/"/>
    <id>http://KunKin.github.io/2018/05/16/Chapter19-Advanced-Function-Topics/</id>
    <published>2018-05-16T03:47:07.000Z</published>
    <updated>2018-05-16T07:52:15.170Z</updated>
    
    <content type="html"><![CDATA[<p>这章讲函数的高级运用.</p><p>including 设计(design)、递归(recur)、函数对象(function object)、匿名(lambda)</p><a id="more"></a> <hr><h5 id="函数的设计层面"><a href="#函数的设计层面" class="headerlink" title="函数的设计层面"></a>函数的设计层面</h5><p>When you start using functions in earnest, you’re faced with choices about how to glue components together—for instance, how to decompose a task into purposeful functions (known as cohesion), how your functions should communicate (called coupling), and so on. You also need to take into account concepts such as the size of your functions, because they directly impact code usability. Some of this falls into the category of structured analysis and design, but it applies to Python code as to any other.</p><p>设计函数时面临的问题是把组件粘合在一起：比如，如何将任务分解为有目的的函数（cohesion），以及函数之间应如何交流（coupling）等。</p><p>还需要考虑诸如函数大小(size)等概念，因为它们直接影响代码的可用性。 其中一些属于结构化分析和设计类别，但它适用于其他Python代码。</p><p>关于函数设计原则：</p><table><thead><tr><th>PRINCIPLE</th><th>DETIALS</th></tr></thead><tbody><tr><td><strong>coupling</strong></td><td>use arguments for inputs and return for outputs.</td></tr><tr><td></td><td>use global variables only when truly necessary.</td></tr><tr><td></td><td>don’t change mutable arguments unless the caller expects it.</td></tr><tr><td></td><td>avoid changing variables in another module file directly.</td></tr><tr><td><strong>cohesion</strong></td><td>each function should have a single, unified purpose.</td></tr><tr><td><strong>size</strong></td><td>each function should be relatively small</td></tr></tbody></table><p>简而言之：降低耦合度(减少内外以及函数之间的相互影响封装性（Encapsulation）)，以及功能的单一性（或者说，专注），还有功能单一性对应的代码长度。</p><hr><p><strong>递归函数（Recursive Functions）</strong></p><p>1、可以用 if/else 三元表达式(ternary expression) 来保存一些代码实例(code real estate)：use Python’s if/else ternary expression to save some code real estate.</p><p>2、归纳任何可加的类型（当我们假设输入中至少有一个项目(item)时会更加简单）：generalize for any summable type(which is easier if we assume at least one item in the input)</p><p>3、使用Python 3.X 的拓展队列赋值来使得下面的 first/rest 更容易地递进：use Python 3.X’s extended sequence assignment to make the first/rest unpacking simpler</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> L <span class="keyword">else</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Use ternary expression</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> L[<span class="number">0</span>] <span class="keyword">if</span> len(L) == <span class="number">1</span> <span class="keyword">else</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Any type, assume one</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line">first, *rest = L</span><br><span class="line"><span class="keyword">return</span> first <span class="keyword">if</span> <span class="keyword">not</span> rest <span class="keyword">else</span> first + mysum(rest) <span class="comment"># Use 3.X ext seq assign</span></span><br></pre></td></tr></table></figure><p>上面的例子中，后两个在L为 empty list 时会 fail 掉， 但是它们允许任何支持 “+” 操作的类型输入，而不局限于numbers.（然而这样子定义的函数并不具备多态性质，而是先定义的被后定义的覆盖了，于是后两个函数，或者说这三个顺着定义下来，再使用mysum(int)会报错，因为 ‘int’ object is not iterable）</p><p>• 单个参数时后两个函数也能工作：The latter two also work on a single string argument (e.g., mysum(‘spam’)), because strings are sequences of one-character strings.（strings 自己就是 一个由许多个单个字符的strings组成的，要记得在Python中，’a’是字符串而非字符）<br>• 第三个函数对于任意的可迭代对象都适用，包括open(filename)，但是不可迭代对象不行 ：The third variant works on arbitrary iterables, including open input files (mysum(open(name))), but the others do not because they index.<br>• 第三个函数不要定义成def mysum(first, *rest), 虽然跟原函数很像，但是却变得没有普适性，因为它期望输入独立的参数，而非一个可迭代对象。</p><p>值得注意的是 first, <em>rest = L 这个语句：用\</em>rest创建了一个list类型的rest对象之后，相当于把rest解压开来，然后按照a,b,c,d,… = List 的 形式把L中除了L[0]外的元素依次赋给了rest。这是一种*object的用法，值得学习。</p><p><em>双函数递归</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> L: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> nonempty(L) <span class="comment"># Call a function that calls me</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">nonempty</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">return</span> L[<span class="number">0</span>] + mysum(L[<span class="number">1</span>:]) <span class="comment"># Indirectly recursive</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mysum([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>])</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure><hr><p><strong>递归与循环的比较</strong></p><p>Python强调简单的过程，因此用while 循环看起来会更加自然，例如，while通常使事情更加具体一些，并且它不要求函数被定义为允许递归调用。更好的是， for 循环能帮我们自动迭代，这使得递归在大部分情况下变得无关紧要（并且很可能在内存空间和执行时间方面效率较低）。</p><p>不过，递归并非一无是处，相反，在遍历任意形状的结构时，我们只能依靠递归（或者等价的基于显式堆栈的算法）。例如计算嵌套子列表结构(树)<code>[1，[2，[3,4]，5]，6，[7,8]]</code>中所有数字之和，由于不是线性迭代，任意嵌套的子列表简单的循环语句在这里不起作用。并且因为子列表可能嵌套到任意深度和任意形状，嵌套的循环语句也无能为力——无法知道有多少层嵌套。这时我们就需要用到递归了。</p><p>简而言之，递归在解决非线性迭代的问题时有很好的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> L: <span class="comment"># For each item at this level</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list):</span><br><span class="line">    tot += x <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    tot += sumtree(x) <span class="comment"># Recur for sublists</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br><span class="line"></span><br><span class="line">L = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>], <span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]] <span class="comment"># Arbitrary nesting</span></span><br><span class="line">print(sumtree(L)) <span class="comment"># Prints 36</span></span><br><span class="line">print(sumtree(L[<span class="number">1</span>])) <span class="comment"># Prints 14</span></span><br><span class="line">print(sumtree((L[<span class="number">1</span>])[<span class="number">1</span>])) <span class="comment"># Prints 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pathological cases</span></span><br><span class="line">print(sumtree([<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, [<span class="number">5</span>]]]]])) <span class="comment"># Prints 15 (right-heavy)</span></span><br><span class="line">print(sumtree([[[[[<span class="number">1</span>], <span class="number">2</span>], <span class="number">3</span>], <span class="number">4</span>], <span class="number">5</span>])) <span class="comment"># Prints 15 (left-heavy)</span></span><br></pre></td></tr></table></figure><hr><p><strong>递归与队列和栈的比较</strong></p><p>Python是通过每次递归调用都在调用堆栈(call stack)上push信息来实现递归的，我们也可以通过使用自己的显式堆栈或队列来跟踪剩余的步骤，而不必递归调用来实现递归式过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span> <span class="comment"># Breadth-first, explicit queue</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  items = list(L) <span class="comment"># Start with copy of top level</span></span><br><span class="line">  <span class="keyword">while</span> items:</span><br><span class="line">    front = items.pop(<span class="number">0</span>) <span class="comment"># Fetch/delete front item</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(front, list):</span><br><span class="line">    tot += front <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    items.extend(front) <span class="comment"># &lt;== Append all in nested list</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure><p>从技术上讲，这段代码按照广度优先(breadth-first)的方式遍历列表，因为它将嵌套列表的内容添加到列表的末尾，形成了先进先出队列。 为了更好地模拟递归调用版本的遍历，我们可以将其更改为执行深度优先遍历(depth-first)，只需将嵌套列表的内容添加到列表的前面，形成后进先出堆栈：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#depth-first</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumtree</span><span class="params">(L)</span>:</span> <span class="comment"># Depth-first, explicit stack</span></span><br><span class="line">  tot = <span class="number">0</span></span><br><span class="line">  items = list(L) <span class="comment"># Start with copy of top level</span></span><br><span class="line">  <span class="keyword">while</span> items:</span><br><span class="line">    front = items.pop(<span class="number">0</span>) <span class="comment"># Fetch/delete front item</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(front, list):</span><br><span class="line">    tot += front <span class="comment"># Add numbers directly</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    items[:<span class="number">0</span>] = front <span class="comment"># &lt;== Prepend all in nested list</span></span><br><span class="line">  <span class="keyword">return</span> tot</span><br></pre></td></tr></table></figure><p>这分别是广度优先搜索 和 深度优先搜索的结果(每行最后一个是该行前面的数的总和)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#L = [1, [2, [3, 4], 5], 6, [7, 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">36</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line"><span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">15</span></span><br><span class="line">----------------------------------------</span><br><span class="line"><span class="comment">#breadth-first</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">36</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span></span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure><hr><p>使用递归要避免无限递归循环(cycles)。特别是数据是循环的时候，比如循环图，之前的递归以及显式队列/堆栈都会失败，递归将落入无限递归循环，而其他方法也会落入简单的无限循环。</p><p>因此为了防止这种情况的出现，递归调用版本（the recursive call version）可以简单地保留并传递一个关于目前为止的访问状态集合(set)、字典(dictionary) 或者 列表(list):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> state <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">visited.add(state) <span class="comment"># x.add(state), x[state]=True, or x.append(state)</span></span><br><span class="line">...proceed...</span><br></pre></td></tr></table></figure><p>非递归类替代方案的做法，请注意，检查项目列表中已有的重复项可以避免调度状态(scheduling state)两次，但不会阻止程序重新访问先前遍历的状态,而导致被从列表中删除：</p><p>Note that checking for duplicates already on the items list would avoid scheduling a state twice, but would not prevent revisiting a state traversed earlier and hence removed from that list:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visited.add(front)</span><br><span class="line">...proceed...</span><br><span class="line">items.extend([x <span class="keyword">for</span> x <span class="keyword">in</span> front <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> visited])</span><br></pre></td></tr></table></figure><p>这个模型并不完全适用于本节的用例，它只是在列表中添加数字，但较大的应用程序将能够识别重复的状态 - 例如以前访问过的网页的URL。 </p><hr><p>某些程序可能还需要记录每个状态的完整路径，以便这些状态完成时报告解决方案。 在这种情况下，非递归方案的堆栈或队列中的每个项目都可能是完整路径列表，这些列表足以记录访问状态的记录，并且包含要在任一端探索的下一个项目。 另外请注意，标准Python限制了其运行时调用堆栈的深度（对递归调用程序至关重要），以捕获无限递归错误。 要扩展它，请使用sys模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getrecursionlimit() <span class="comment"># 1000 calls deep default</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.setrecursionlimit(<span class="number">10000</span>) <span class="comment"># Allow deeper nesting</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sys.setrecursionlimit) <span class="comment"># Read more about it</span></span><br></pre></td></tr></table></figure><p>允许的最大设置可能因平台而异。 对于通过使用堆栈或队列来避免递归调用、并获得对遍历过程的更多控制的程序而言，这不是必需的。</p><hr><p><strong>函数对象：属性和注释（Function Objects: Attributes and Annotations）</strong></p><p>由于Python函数是对象，因此可以编写一般处理它们的程序。 函数对象可以被赋予其他名字，传递给其他函数，嵌入到数据结构中，从一个函数返回到另一个函数，等等，就好像它们是简单的数字或字符串一样。 函数对象也碰巧支持一种特殊的操作：可以通过在函数表达式之后的括号中列出参数来调用它们。 但是，函数与其他对象属于相同的一般类别。这通常被称为第一类对象模型(<em>a first-class object model</em>)，它在Python中无处不在，并且是函数式编程的必要部分。</p><p>function object 的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span> <span class="comment"># Name echo assigned to function object</span></span><br><span class="line">print(message)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>echo(<span class="string">'Direct call'</span>) <span class="comment"># Call object through original name</span></span><br><span class="line">Direct call</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = echo <span class="comment"># Now x references the function too</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x(<span class="string">'Indirect call!'</span>) <span class="comment"># Call object through name by adding ()</span></span><br><span class="line">Indirect call!</span><br></pre></td></tr></table></figure><p>def实际上是把function对象赋值给了一个name，像其他对象一样，可以通过assign name 的方式(name = name) 来使得另一个name 能够引用这个function对象。</p><p>(有点像函数指针)</p><p>甚至能当参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">indirect</span><span class="params">(func, arg)</span>:</span></span><br><span class="line">func(arg) <span class="comment"># Call the passed-in object by adding ()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>indirect(echo, <span class="string">'Argument call!'</span>) <span class="comment"># Pass the function to another function</span></span><br><span class="line">Argument call!</span><br></pre></td></tr></table></figure><p>以及放进数据结构里：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>schedule = [ (echo, <span class="string">'Spam!'</span>), (echo, <span class="string">'Ham!'</span>) ]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> (func, arg) <span class="keyword">in</span> schedule:</span><br><span class="line">func(arg) <span class="comment"># Call functions embedded in containers</span></span><br><span class="line">Spam!</span><br><span class="line">Ham!</span><br></pre></td></tr></table></figure><p>functions can also be created and returned for use elsewhere—the closure created in this mode also retains state from the enclosing scope:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(label)</span>:</span> <span class="comment"># Make a function but don't call it</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">        print(label + <span class="string">':'</span> + message)</span><br><span class="line">        <span class="keyword">return</span> echo<span class="comment">#Remeber what is returned!</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F = make(<span class="string">'Spam'</span>) <span class="comment"># Label in enclosing scope is retained</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'Ham!'</span>) <span class="comment"># Call the function that make returned</span></span><br><span class="line">Spam:Ham!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>F(<span class="string">'Eggs!'</span>)</span><br><span class="line">Spam:Eggs!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make(<span class="string">'Spam'</span>)(<span class="string">'Ham!'</span>)</span><br><span class="line">Spam:Ham!</span><br></pre></td></tr></table></figure><p>even:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make</span><span class="params">(label)</span>:</span></span><br><span class="line">        print(<span class="number">1</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(message)</span>:</span></span><br><span class="line">            print(label + <span class="string">':'</span> + message)</span><br><span class="line">        <span class="keyword">return</span> echo</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make(<span class="string">'Spam'</span>)(<span class="string">'Eggs'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">Spam:Eggs</span><br></pre></td></tr></table></figure><hr><p>function object 的 expression 不止call：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__name__</span><br><span class="line"><span class="string">'func'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure><p>自检工具还能探索执行细节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__</span><br><span class="line">&lt;code object func at <span class="number">0x00000000021A6030</span>, file <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func.__code__)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>,</span><br><span class="line">...more omitted: <span class="number">37</span> total...</span><br><span class="line"><span class="string">'co_argcount'</span>, <span class="string">'co_cellvars'</span>, <span class="string">'co_code'</span>, <span class="string">'co_consts'</span>, <span class="string">'co_filename'</span>,</span><br><span class="line"><span class="string">'co_firstlineno'</span>, <span class="string">'co_flags'</span>, <span class="string">'co_freevars'</span>, <span class="string">'co_kwonlyargcount'</span>, <span class="string">'co_lnotab'</span>,</span><br><span class="line"><span class="string">'co_name'</span>, <span class="string">'co_names'</span>, <span class="string">'co_nlocals'</span>, <span class="string">'co_stacksize'</span>, <span class="string">'co_varnames'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__.co_varnames</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__.co_argcount</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>函数属性（Function Attributes）</strong></p><p>函数属性不局限于前面列出的系统定义的属性，也可以为它们附加任意的用户定义属性(user-defined)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func</span><br><span class="line">&lt;function func at <span class="number">0x000000000296A1E0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.count</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.handles = <span class="string">'Button-Press'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.handles</span><br><span class="line"><span class="string">'Button-Press'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>,</span><br><span class="line">...<span class="keyword">and</span> more: <span class="keyword">in</span> <span class="number">3.</span>X all others have double underscores so your names won<span class="string">'t clash...</span></span><br><span class="line"><span class="string">__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'count'</span>, <span class="string">'handles'</span>]</span><br></pre></td></tr></table></figure><p>Python自带的属性都带有是”__X__”格式的（Python 3.X）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(f)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dir(f))</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> dir(f) <span class="keyword">if</span> <span class="keyword">not</span> x.startswith(<span class="string">'__'</span>)]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>可以使用这些属性直接将状态信息(<em>state information</em>)附加到函数对象上，而不是使用其他技术，例如全局变量，非局部变量和类。与非局部变量(nonlocal)不同，这些属性可以在函数本身的任何地方访问，即使在代码之外。<br>从某种意义上说，这也是一种在其他语言中模拟“静态局部变量”(static local)的方法 - 变量的名称在函数中是局部的，但在函数退出后其值保留。属性与对象（而不是范围）相关（并且必须通过其代码中的函数名称引用），但实际效果类似。<br>此外，当属性被附加到由其他工厂函数(factory functions)生成的函数时，它们也支持多次复制，每次调用和可写状态保留，就像非局部闭包和类实例属性</p><hr><p> <strong>函数注释(Function Annotations)</strong></p><p>在Python 3.X（但不是2.X）中，也可以将注释信息（关于函数参数和结果的任意用户定义数据）附加到函数对象。<br>Python为指定注释提供了特殊的语法，但它对它本身不做任何事情; 注释是完全可选的，并且当存在时仅附加到函数对象的__annotations__属性以供其他工具使用。 例如，这样的工具可能会在错误测试的环境中使用注释。 我们在前一章中遇到了Python 3.X的关键字参数， 注释将进一步概括函数头语法。 考虑下面的非注解函数，它用三个参数编码并返回一个结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>在语法上，函数注释在def标题行中编码，作为与参数和返回值关联的任意表达式。</p><p> 对于参数，它们出现在紧跟在参数名称后面的冒号后面; </p><p>对于返回值，它们是在参数列表之后的 - &gt;之后编写的。 </p><p>例如，这段代码注释了前三个函数的参数以及它的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span>, b: <span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span>, c: float)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>对func的调用还是照常，只是注释以dictionary的形式存储在了__annotations__属性里。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; func.__annotations__</span><br><span class="line">&#123;&apos;c&apos;: &lt;class &apos;float&apos;&gt;, &apos;b&apos;: (1, 10), &apos;a&apos;: &apos;spam&apos;, &apos;return&apos;: &lt;class &apos;int&apos;&gt;&#125;</span><br></pre></td></tr></table></figure><p>由于这只是一些Python 对象 连接在 一个 Python对象上，因此annotation 也是能够被直接处理(process)的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span>, b, c: <span class="number">99</span>)</span>:</span></span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__annotations__</span><br><span class="line">&#123;<span class="string">'c'</span>: <span class="number">99</span>, <span class="string">'a'</span>: <span class="string">'spam'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> arg <span class="keyword">in</span> func.__annotations__:</span><br><span class="line">print(arg, <span class="string">'=&gt;'</span>, func.__annotations__[arg])</span><br><span class="line">c =&gt; 99</span><br><span class="line">a =&gt; spam</span><br></pre></td></tr></table></figure><p>有两点需要注意：</p><p>1、如果代码有annotation， 还是可以照常给参数设定默认值(defaults)</p><p>   （形式如 arg : annotation = default）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span> = <span class="number">4</span>, b: <span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span> = <span class="number">5</span>, c: float = <span class="number">6</span>)</span> -&gt; int:</span></span><br><span class="line"><span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func() <span class="comment"># 4 + 5 + 6 (all defaults)</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, c=<span class="number">10</span>) <span class="comment"># 1 + 5 + 10 (keywords work normally)</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__annotations__</span><br><span class="line">&#123;'c': &lt;class 'float'&gt;, 'b': (1, 10), 'a': 'spam', 'return': &lt;class 'int'&gt;&#125;</span><br></pre></td></tr></table></figure><p>2、前面示例中的空格都是可选的 —— 可以在函数头文件中的组件之间使用空格，但忽略空格可能会降低代码可读性。</p><p>但是：注释只能在def语句中使用，而不能在lambda表达式(下文对其说明)中使用，因为lambda的语法已经限制了它定义的函数的效用。</p><hr><p><strong>匿名函数 (Anonymous Functions): lambda</strong></p><p>lambda表达式创建了一个稍后调用的函数，但它返回的是函数而<em>不是将其分配给名称</em>。 因此lambda有时被称为匿名（即未命名）功能。 在实践中，它们通常用作内联函数定义的方式，或推迟执行一段代码。</p><p>lambda 表达式的格式：</p><p>​    <code>lambda argument1, argument2,... argumentN : expression using arguments</code></p><p>lambda 表达式返回的function object 跟用def 生成并引用的function object 运行起来是一样的。但是有一些差别使得lambda 在特别的方面很有用：</p><p>1、lambda 是（仅限于）一个表达式，而非声明：</p><p>​    例如，<em>lambda可以出现在Python语法不允许def的地方</em> - 例如列表字面量(list literal)或函数调用的参数(function call’s arguments)。 在def中，函数可以按名称引用，但必须在别处创建。 作为一个表达式，<em>lambda返回一个值（一个新的函数），可以选择分配一个名字</em>。 相比之下，def语句总是将新函数分配给头中的名称，而不是将其作为结果返回。</p><p>2、lambda 的主体是一个单一的表达式，而非一个语句块：</p><p>​    lambda的主体(body)与def 主体的return语句中放置的内容相似; 只需将结果输入为a naked expression，而非显式返回它， 因为它仅限于一个表达式，所以lambda比def更不常用 —— 你只能将如此多的逻辑压缩到lambda体中而不使用诸如if之类的语句。 <em>这是为了限制程序嵌套而设计的：lambda是为编写简单函数而设计的，def可以处理较大的任务。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, y, z)</span>:</span> <span class="keyword">return</span> x + y + z</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x, y, z: x + y + z</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment">#Function objects returned by running lambda expressions work exactly the same as those created and assigned by defs</span></span><br></pre></td></tr></table></figure><p>加了默认值(defaults):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Defaults work on lambda arguments, just like in a def:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = (<span class="keyword">lambda</span> a=<span class="string">"fee"</span>, b=<span class="string">"fie"</span>, c=<span class="string">"foe"</span>: a + b + c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x(<span class="string">"wee"</span>)</span><br><span class="line"><span class="string">'weefiefoe'</span></span><br></pre></td></tr></table></figure><p>lambda主体(body)中的代码也遵循与def中的代码相同的范围查找规则(scope lookup rules)。 lambda表达式引入了一个本地作用域，就像嵌套的def一样，它可以自动在封装函数、模块和内置作用域中看到名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">knights</span><span class="params">()</span>:</span></span><br><span class="line">        title = <span class="string">'Sir'</span></span><br><span class="line">        action = (<span class="keyword">lambda</span> x: title + <span class="string">' '</span> + x) <span class="comment"># Title in enclosing def scope</span></span><br><span class="line">        <span class="keyword">return</span> action <span class="comment"># Return a function object</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act = knights()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg = act(<span class="string">'robin'</span>) <span class="comment"># 'robin' passed to x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">'Sir robin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act <span class="comment"># act: a function, not its result</span></span><br><span class="line">&lt;function knights.&lt;locals&gt;.&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x00000000029CA488</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">()</span>:</span></span><br><span class="line">      print()</span><br><span class="line"><span class="keyword">return</span> echo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()<span class="comment">#same as lambda</span></span><br><span class="line">&lt;function f.&lt;locals&gt;.echo at <span class="number">0x0000024429B60048</span>&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>用lambda的原因</strong></p><p>一般来说，lambda可以作为一种函数简写方式派上用场，它允许您在使用它的代码中嵌入函数的定义。 它们完全是可选的——你可以总是使用def来代替，尤其是lambda表达式不能轻易满足函数需要时——但在要使用的位置中，lambda往往是简单的编码结构，你只需要嵌入小部分可执行代码内联（small bits of executable code inline）。<br>例如，回调处理程序经常被编码为直接嵌入到注册调用参数列表中的内联lambda表达式，而不是在文件中的其他位置定义def并用名称引用。<br>lambda也常用于编写跳转表(jump tables)，这些跳转表是按需执行的动作列表或字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, <span class="comment"># Inline function definition</span></span><br><span class="line"><span class="keyword">lambda</span> x: x ** <span class="number">3</span>,</span><br><span class="line"><span class="keyword">lambda</span> x: x ** <span class="number">4</span>] <span class="comment"># A list of three callable functions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> L:</span><br><span class="line">print(f(<span class="number">2</span>)) <span class="comment"># Prints 4, 8, 16</span></span><br><span class="line">    </span><br><span class="line">print(L[<span class="number">0</span>](<span class="number">3</span>)) <span class="comment"># Prints 9</span></span><br></pre></td></tr></table></figure><p>当需要将小块可执行代码填充到语句在句法上非法的地方时，lambda表达式对def来说是更具有优势的。 例如，前面的代码片段(code snippet,)通过在list literal中嵌入lambda表达式来构建三个函数的list； 在这样的list literal中，def（或者说，语句）不起作用。 等效的def编码需要临时函数名称（可能与其他函数名称冲突）并且函数需要定义在预期使用的上下文之外（可能需要几百行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">3</span> <span class="comment"># Define named functions</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x ** <span class="number">4</span></span><br><span class="line"></span><br><span class="line">L = [f1, f2, f3] <span class="comment"># Reference by name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> L:</span><br><span class="line">print(f(<span class="number">2</span>)) <span class="comment"># Prints 4, 8, 16</span></span><br><span class="line">    </span><br><span class="line">print(L[<span class="number">0</span>](<span class="number">3</span>)) <span class="comment"># Prints 9</span></span><br></pre></td></tr></table></figure><hr><p><strong>多路分支选择(Multiway Branch Switches)</strong></p><p>可以用Python中的字典和其他数据结构来做同样的事情来构建更一般的动作表(action table):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key = &apos;got&apos;</span><br><span class="line">&gt;&gt;&gt; &#123;&apos;already&apos;: (lambda: 2 + 2),</span><br><span class="line">&apos;got&apos;: (lambda: 2 * 4),</span><br><span class="line">&apos;one&apos;: (lambda: 2 ** 6)&#125;[key]()</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>当Python创建临时字典时，每个嵌套lambda生成并留下稍后调用的函数。 按键索引获取这些函数之一，括号会强制调用获取的函数。 当用这种方式进行编码时，字典变成了一种比通用的多路分支工具。</p><p>用def替代的方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span> <span class="keyword">return</span> <span class="number">2</span> ** <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>key = <span class="string">'one'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'already'</span>: f1, <span class="string">'got'</span>: f2, <span class="string">'one'</span>: f3&#125;[key]()</span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure><p>（注意<code>{&#39;already&#39;: f1, &#39;got&#39;: f2, &#39;one&#39;: f3}</code>中用的是函数名<code>f1</code>，而不是<code>f1()</code>,<code>f1()</code>代表的已经是调用函数了。）</p><p>替代方案也适用，但是即使只是一小段代码，def 在文件中也可能是任意的。 lambdas提供的代码接近性(code proximity)对于仅在单个上下文中使用的函数特别有用——如果这里的三个函数在别的地方没有用处，则将其定义嵌入dictionary中的lambda expression 是有意义的。 此外，定义形式要求您为这些小函数起名，<em>可能导致与此文件中的其他名称冲突</em>。<br>lambdas在函数调用参数列表中也派上用场，这是一种内联临时函数定义的方法，不会在程序中的任何其他位置使用。在图(map)中lambda函数有别的用途。</p><hr><p><strong>不要混淆代码(Not to Obfuscate Code)</strong></p><p>只有明确知道自己在做什么的时候才可以将Python中的大多数语句编写为基于表达式的等价语言。</p><p>比如，为了将<strong>选择逻辑</strong>(selection logic)嵌套在一个lambda中，可以用if/else三元表达式， 或者等价却更复杂的 and/or 组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">b</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">b <span class="keyword">if</span> a <span class="keyword">else</span> c<span class="comment">#if/else ternary expression</span></span><br><span class="line"></span><br><span class="line">((a <span class="keyword">and</span> b) <span class="keyword">or</span> c)<span class="comment">#and/or combination</span></span><br></pre></td></tr></table></figure><p>像这样的表达式能够被放进lambda中，因此它们可能被用来执行lambda函数里的选择逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower = (<span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower(<span class="string">'bb'</span>, <span class="string">'aa'</span>)</span><br><span class="line"><span class="string">'aa'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lower(<span class="string">'aa'</span>, <span class="string">'bb'</span>)</span><br><span class="line"><span class="string">'aa'</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>此外，如果想在lambda表达式中执行<strong>循环</strong>，还可以嵌入像map calls(图调用)和list comprehension表达式这样的东西 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: list(map(sys.stdout.write, x)) <span class="comment"># 3.X: must use list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = showall([<span class="string">'spam\n'</span>, <span class="string">'toast\n'</span>, <span class="string">'eggs\n'</span>]) <span class="comment"># 3.X: can use print</span></span><br><span class="line">spam</span><br><span class="line">toast</span><br><span class="line">eggs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: [sys.stdout.write(line) <span class="keyword">for</span> line <span class="keyword">in</span> x]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = showall((<span class="string">'bright\n'</span>, <span class="string">'side\n'</span>, <span class="string">'of\n'</span>, <span class="string">'life\n'</span>))</span><br><span class="line">bright</span><br><span class="line">side</span><br><span class="line">of</span><br><span class="line">life</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: [print(line, end=<span class="string">''</span>) <span class="keyword">for</span> line <span class="keyword">in</span> x] <span class="comment"># Same: 3.X only</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>showall = <span class="keyword">lambda</span> x: print(*x, sep=<span class="string">''</span>, end=<span class="string">''</span>) <span class="comment"># Same: 3.X only</span></span><br></pre></td></tr></table></figure><p>使用表达式模拟语句是有限制的：例如，工具(tool)比如说：内置setattr、命名空间的__dict__和就地就该可变对象的方法，虽然这些工具有时可以驻留，但是不能直接实现赋值语句的效果 ，函数式编程技术(functional programming techniques)可以让你深入复杂表达的黑暗领域(the dark<br>realm of convoluted expression.)。<br>仅请使用这些技巧作为最后的手段。如果不加以小心，它们可能会导致无法读取(unreadable)（又名混淆(obfuscated))）的Python代码。 一般来说，简单比复杂更好，显式比隐式更好，完整语句比隐晦表达(arcane expressions)更好。 这就是lambda仅限于表达式的原因。<br>如果有更大的代码逻辑，使用def；lambda是用于小块的内联代码的。<br>另一方面，适度使用这些技术是很有帮助的。</p><hr><p><strong>关于and/or</strong></p><p>and : 从左到右扫描，返回第一个为假的表达式值，无假值则返回最后一个表达式值。</p><p>or    : 从左到右扫描，返回第一个为真的表达式值，无真值则返回最后一个表达式值。</p><p>在Python中，and 和 or 执行布尔逻辑演算。但是它们并不返回布尔值，而是返回它们实际进行比较的值之一。（类似C++里面的&amp;&amp;和||的短路求值）</p><p>在布尔环境中，0、”、[]、()、{}、None为假；其它任何东西都为真。但是可以在类中定义特定的方法使得类实例的演算值为假。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"betabin"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'betabin'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br></pre></td></tr></table></figure><p>看起来类似于条件运算符（bool ？a：b），是的，当a为true的时候是一样的。但是，当a为false的时候，就明显不同了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a= <span class="string">""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b =<span class="string">"python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> a <span class="keyword">or</span> b</span><br><span class="line"><span class="string">'python'</span></span><br></pre></td></tr></table></figure><p>可见两种情况都返回了b，与<code>bool ? a : b</code>的效果不同</p><p>如果执意用and/or来实现条件运算符，可以用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">""</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"betabin"</span>  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> <span class="keyword">and</span> [a] <span class="keyword">or</span> [b])[<span class="number">0</span>]  </span><br><span class="line"><span class="string">''</span></span><br></pre></td></tr></table></figure><p>[“”]不为假，从而将a为假的可能性剔除，再通过下标0 (即是[0]) 再获得a。由于获得元素的途经统一，因此b也要套上[]。</p><p>and/or 技巧主要在 lambda中使用。</p><hr><p><strong>范围(scope)</strong></p><p>lambdas can be nested too</p><p>lambdas是嵌套函数范围查找的主要受益者(LEGB中的E)。下面的lambda出现在一个def中——一个典型案例——并且因此可以在调用封闭函数时，访问名称x在封闭函数作用域中的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">lambda</span> y: x + y) <span class="comment"># Make and return function, remember x</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act = action(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act</span><br><span class="line">&lt;function action.&lt;locals&gt;.&lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x00000000029CA2F0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>act(<span class="number">2</span>) <span class="comment"># Call what action returned</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>((<span class="keyword">lambda</span> x: (<span class="keyword">lambda</span> y: x + y))(<span class="number">99</span>))(<span class="number">4</span>)</span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure><p>这里，嵌套的lambda结构在调用时会生成一个函数。在这两种情况下，嵌套lambda的代码都可以访问封闭lambda中的变量x。 这确实有用，但它似乎是相当复杂的代码; 为了可读性，通常最好避免嵌套lambda。</p><hr><p><strong>回调函数(callback)</strong></p><p>首先明晰一下什么是回调函数(callback)：</p><p>​    维基：指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。</p><p>​    百度：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回调函数1</span></span><br><span class="line"><span class="comment">#生成一个2k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#回调函数2</span></span><br><span class="line"><span class="comment">#生成一个4k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadruple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">4</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">from</span> even <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#中间函数</span></span><br><span class="line"><span class="comment">#接受一个生成偶数的函数作为参数</span></span><br><span class="line"><span class="comment">#返回一个奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddNumber</span><span class="params">(k, getEvenNumber)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getEvenNumber(k)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#起始函数，这里是程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="comment">#当需要生成一个2k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, double)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个4k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, quadruple)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个8k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, <span class="keyword">lambda</span> x: x * <span class="number">8</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">运行`callback_demp.py`，输出如下：</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">9</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><hr><p><strong>lambda 回调函数(callback)</strong></p><p>lambda另一个常见的用途是为Python的tkinter GUI API定义内联回调函数(inline callback function)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> Button, mainloop <span class="comment"># Tkinter in 2.X</span></span><br><span class="line">x = Button(</span><br><span class="line">        text=<span class="string">'Press me'</span>,</span><br><span class="line">        command=(<span class="keyword">lambda</span>:sys.stdout.write(<span class="string">'Spam\n'</span>))) <span class="comment"># 3.X: print()</span></span><br><span class="line">x.pack()</span><br><span class="line">mainloop() <span class="comment"># This may be optional in console mode</span></span><br></pre></td></tr></table></figure><p>在这里，我们将lambda生成的函数传递给command关键字参数以注册(register)回调处理程序。<br>这里的lambda相对于def的优点是处理按钮按下的代码就嵌入在创建按钮(button-creation)的调用中。<br>实际上，lambda延迟处理程序的执行，直到事件发生。如上例中，write在按钮被按下时而非被创建时被调用，并且有效地“知道”在事件发生时应该写入的字符串。<br>因为嵌套的函数作用域规则(the nested function scope rules)也适用于lambda表达式，所以它们也更容易用作回调处理程序（从Python 2.2开始） - 它们自动在它们编码的函数中看到名称，并且在大多数情况下不再需要传入缺省值。<br>这非常便于访问特殊的自我实例参数(special self instance argument)（封装类方法函数中的局部变量）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGui</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makewidgets</span><span class="params">(self)</span>:</span></span><br><span class="line">Button(command=(<span class="keyword">lambda</span>: self.onPress(<span class="string">"spam"</span>)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onPress</span><span class="params">(self, message)</span>:</span></span><br><span class="line">...use message...</span><br></pre></td></tr></table></figure><hr><p><strong>函数编程工具(functional programming tools)</strong></p><p>通过大多数定义，Python支持：过程式(procedural)（基本语句basic statements），object-oriented（类）和功能性。对于后者，Python包含一组内置函数，用于函数编程 - 将函数应用于序列和其他迭代器的工具。这个集合包括调用可迭代对象的元素上的函数的工具（map）、根据测试函数过滤元素（filter）、以及，将函数应用于项目对和运行结果（reduce）。<br>虽然边界有时有点模糊，但大多数定义中，Python的函数式编程库也包括前面探讨的一流对象模型(the first-class object model)，嵌套范围闭包(the first-class object model)和匿名函数lambdas.</p><p><strong>Mapping Functions over Iterables: map</strong></p><p>程序对list和其他sequence执行的更常见的操作是对每个元素应用操作，并收集结果——选择数据库表格的列，增加公司中雇员的付费字段，解析电子邮件附件等等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>counters = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>updated = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> counters:</span><br><span class="line">updated.append(x + <span class="number">10</span>) <span class="comment"># Add 10 to each item</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>updated</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure><p>但是由于这是常见操作，Python 也提供了内置函数来实现这种功能。map函数将传入的函数(passed-in function)应用于可迭代对象中的每个元素，并返回一个包含所有函数调用结果的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x + <span class="number">10</span> <span class="comment"># Function to be run</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, counters)) <span class="comment"># Collect results</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure><p>通过传递一个<em>user-defined</em>函数来应用于列表中的每个元素的列表——map 调用 inc 中的每个项目，并将所有返回值收集到一个新列表中，我们能更普适地使用它。</p><p>因为map需要一个函数的传入和应用，所以它也恰好是lambda常见的地方之一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map((<span class="keyword">lambda</span> x: x + <span class="number">3</span>), counters)) <span class="comment"># Function expression</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>由于这个函数只在这里需要，它被写成了一个用lambda内联的形式(written inline as a lambda)。由于上例中map的使用与for循环是等价的，因此用一小段额外的代码就能够写出一个通用的遍历工具(a general mapping utility)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mymap</span><span class="params">(func, seq)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> seq: res.append(func(x))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这个自定义的函数对于inc函数的效果是跟之前的map一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment"># Built-in is an iterable</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mymap(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># Ours builds a list (see generators)</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure><p>但是要注意，map是内置的，这说明它总是可用的、总是以同一种方式运作的，并且有一些性能优势。此外，map 有比上例更加高级的用法，比如给定多个序列参数(sequence arguments)，它将并行序列中的项作为不同的(distinct)参数发送给函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># 3**4</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(pow, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])) <span class="comment"># 1**2, 2**3, 3**4</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>对于N个序列(N sequences)，映射期望(expect)一个 N-argument 函数。 在这里，pow函数在每次调用上都用到两个参数，每个参数由每个sequence分别传递。 在代码中模拟这种多重序列的通用性(multiple-sequence generality)并没有太多的额外工作，但是需要一些额外的迭代工具。</p><p>其实map的调用有点像list comprehension：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(inc, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[inc(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]] <span class="comment"># Use () parens to generate items instead</span></span><br><span class="line">[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure><p>虽然list comprehension 很快，但是在一些情况下，map 可能比list comprehension 更快， 且需要更少的代码。On the other hand，map对每个元素应用一个函数调用(<em>function</em> call)而不是一个任意的表达式，这是一个不太常用的工具，并且通常需要额外的帮助函数或lambda表达式。 此外，用圆括号()而非方括号[]括起comprehension， 能产生一个对象，这个对象能根据请求来生成(<em>generate</em>) value以节省内存并提高响应速度，就像Python 3.X中的map一样。</p><p><strong>Selecting Items in Iterables: filter</strong></p><p>filter:根据测试函数(test function)选择迭代元素</p><p>因为过滤器(filter)也返回一个可迭代对象，所以过滤器（比如说，range）需要一个列表调用(list call)来在3.X中显示其所有结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(−<span class="number">5</span>, <span class="number">5</span>)) <span class="comment"># An iterable in 3.X</span></span><br><span class="line">[−<span class="number">5</span>, −<span class="number">4</span>, −<span class="number">3</span>, −<span class="number">2</span>, −<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter((<span class="keyword">lambda</span> x: x &gt; <span class="number">0</span>), range(−<span class="number">5</span>, <span class="number">5</span>))) <span class="comment"># An iterable in 3.X</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>函数返回true的 sequence 或 可迭代对象(iterable)中的 元素将被添加到结果列表中。 像map一样，这个用了filter的函数大致相当于下面的for循环，但它是内置的，简洁的，并且通常很快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(−<span class="number">5</span>, <span class="number">5</span>): <span class="comment"># The statement equivalent</span></span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        res.append(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>像 map 一样，用一个更简单的结果（特别是当它可以避免创建一个新函数时），以及在需要延迟生成结果时用一个类似的生成器表达式， filter 能够被 list comprehension 模拟。</p><p>Also like map, filter can be emulated by list comprehension syntax with often-simpler results (especially when it can avoid creating a new function), and with a similar generator expression when delayed production of results is desired.</p><p><strong>Combining Items in Iterables: reduce</strong></p><p>reduce 函数更加复杂， 它接受一个可迭代对象(iterable)来运行，但它本身不是一个可迭代的对象——它返回一个单一的结果(single result)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce <span class="comment"># Import in 3.X, not in 2.X</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure><p>在每个步骤中，reduce将当前的总和或总乘积连同list中的下一个元素传递给passed-in lambda函数。 默认情况下，用序列中的第一个元素来初始化起始值。 为了说明，这里是与这些调用中的第一个调用(求总和那个)等价的for循环，并且在循环内部添加硬编码(hardcode)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = L[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> L[<span class="number">1</span>:]:</span><br><span class="line">res = res + x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>以下函数模拟reduce大部分内置行为，并帮助彻底揭开其操作的神秘面纱：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">myreduce</span><span class="params">(function, sequence)</span>:</span></span><br><span class="line">        tally = sequence[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> next <span class="keyword">in</span> sequence[<span class="number">1</span>:]:</span><br><span class="line">        tally = function(tally, next)</span><br><span class="line">        <span class="keyword">return</span> tally</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myreduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myreduce((<span class="keyword">lambda</span> x, y: x * y), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure><p>内置的reduce还允许在list中的item之前放置可选的第三个参数，以便在序列为空时用作默认结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#253&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), [])</span><br><span class="line">TypeError: reduce() of empty sequence <span class="keyword">with</span> no initial value</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), <span class="number">0</span>,[])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#247&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), <span class="number">0</span>,[])</span><br><span class="line">TypeError: reduce() arg <span class="number">2</span> must support iteration</span><br><span class="line">  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [],<span class="number">0</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [],<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#252&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    reduce((<span class="keyword">lambda</span> x,y : x+y), [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">10</span>,<span class="number">4</span>)</span><br><span class="line">TypeError: reduce expected at most <span class="number">3</span> arguments, got <span class="number">4</span></span><br></pre></td></tr></table></figure><p>standard library 中的 operator module 提供了与内置表达式(build-in expression)相对应的函数，因此可用于某些功能工具的使用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator, functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce(operator.add, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]) <span class="comment"># Function-based +</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>functools.reduce((<span class="keyword">lambda</span> x, y: x + y), [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><hr><p>之前提到了硬编码(又叫写死)：</p><p><strong>硬编码</strong>（英语：<strong>Hard Code</strong>或<strong>Hard Coding</strong>）是指在软件实现上，将输出或输入的相关参数（例如：路径、输出的形式或格式）直接以常量的方式撰写在源代码中，而非在运行期间由外界指定的设置、资源、数据或格式做出适当回应。一般被认定是种反模式或不完美的实现，因为软件受到输入数据或输出的格式改变就必需修改源代码，对客户而言，改变源代码之外的小设置也许还比较容易。</p><p>但硬编码的状况也并非完全只有缺陷，因某些封装需要或软件本身的保护措施，有时是必要的手段。除此之外，有时候因应某些特殊的需求，制作出简单的应用程序，应用程序可能只会运行一次，或者永远只应付一种需求，利用硬编码来缩短开发的时间也是一种不错的决策。</p><hr><p>本章完毕li</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这章讲函数的高级运用.&lt;/p&gt;
&lt;p&gt;including 设计(design)、递归(recur)、函数对象(function object)、匿名(lambda)&lt;/p&gt;
    
    </summary>
    
      <category term="Learning Python" scheme="http://KunKin.github.io/categories/Learning-Python/"/>
    
    
      <category term="Python" scheme="http://KunKin.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Permutation</title>
    <link href="http://KunKin.github.io/2018/05/16/Permutation/"/>
    <id>http://KunKin.github.io/2018/05/16/Permutation/</id>
    <published>2018-05-16T03:36:29.000Z</published>
    <updated>2018-05-16T07:53:19.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>N个数的全排列数，观察3个数的全排列数：</p><p>1 2 3</p><p>1 3 2</p><p>2 1 3</p><a id="more"></a> <p>2 3 1</p><p>3 1 2</p><p>3 2 1</p><p>可以看到第一个分别是1 2 3，而各自后面所跟着的，恰恰是剩下的数的全排列，以1为例，后面的 2 3 和 3 2是2、3的全排列</p><p>又比如4个数全排列：</p><p><img src="http://img.blog.csdn.net/20170319170336573?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlxaTEyM2k=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="è¿éåå¾çæè¿°"></p><p>即先依字典序安排一个数在首位，而剩下的数则在后面进行全排列，这就体现出了递归的思想，由此可见我们可以用递归来处理这个问题</p><p>抽象出来就是Permutation(N){ Head(); Permutation(N-1); }</p><h2 id="代码与说明"><a href="#代码与说明" class="headerlink" title="代码与说明"></a>代码与说明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*递归最重要的是逻辑，不要钻牛角尖。</span></span><br><span class="line"><span class="comment">*写程序之前必须在纸上写出代码逻辑，纸张的记录能够辅助把握想法，</span></span><br><span class="line"><span class="comment">*光靠大脑来想总是顾此失彼，还会导致思路不清晰，甚至忘掉之前的思路。</span></span><br><span class="line"><span class="comment">*尤其是递归，在纸上列明逻辑便很容易写出来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">之前的代码是</span></span><br><span class="line"><span class="comment">void permutation(char *s) &#123;</span></span><br><span class="line"><span class="comment">    if (strlen(s) == 1) &#123;</span></span><br><span class="line"><span class="comment">        printf("%c\n", s[0]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else &#123;</span></span><br><span class="line"><span class="comment">        int i;</span></span><br><span class="line"><span class="comment">        for (i = 0; i &lt; strlen(s); i++) &#123;</span></span><br><span class="line"><span class="comment">            printf("%c",s[i]);</span></span><br><span class="line"><span class="comment">            char s1[11] = "";</span></span><br><span class="line"><span class="comment">            char *p = s1;</span></span><br><span class="line"><span class="comment">            for (j = 0; j &lt; strlen(s); j++) &#123;</span></span><br><span class="line"><span class="comment">                if (j != i) &#123; *(p++) = s[j]; &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            permutation(s1);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">这样是有问题的，不定义before以存储已排列过的部分，则每次递归，都只打印出当前层次未确定的字符的排列。因为对每一层递归来说，上一层递归只执行一次，也就是说这层递归无论有多少情况，上一层都只打印一次。这就造成了缺项。</span></span><br><span class="line"><span class="comment">以 N=3 为例，以 1 为开头的全排列本该有两个，但是会出现 123 和 32 的结果，在第二个结果中1消失了，这是因为在递归中，处理第一位的操作只出现了一次。因此 N=3 的情况下，输出长度呈现 3 2 3 2 3 2 这样的情况。以上图的树来看，四个*的只输出一次，三个*输出4次，两个*输出12次，对应第一位被确定的情况下，第一位被打印出来的次数、第二位被打印出来的次数以及第三位的。</span></span><br><span class="line"><span class="comment">同理，N=4的情况下，输出长度会呈现 4 3 2 2 4 3 2 2 …… 这样的情况。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义了两个参数，s指的是待全排列的子串，before则保存是已排列过的部分，如1234，1243中的12即是已排列过的部分*/</span></span><br><span class="line"><span class="comment">/*本质上说全排列是位置变动，而与具体的值无关，因此只需要稍微安排一下字符串（为了按字典序输出），就能放心地使用递归直接对子串全排列*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *before)</span> </span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(<span class="built_in">strlen</span>(s)</span> </span>== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(before); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c "</span>, before[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, s[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">char</span> newBefore[<span class="number">11</span>] = <span class="string">""</span>;</span><br><span class="line">          <span class="comment">/*这里之所以声明一个新的before是为了给每个下级递归分配独立的before避免冲突，事实上直接使用before会导致before一直增加元素直到数组溢出*/</span></span><br><span class="line">            </span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(before); j++) &#123;</span><br><span class="line">                newBefore[j] = before[j];</span><br><span class="line">            &#125;</span><br><span class="line">            newBefore[<span class="built_in">strlen</span>(newBefore)] = s[i];</span><br><span class="line">            <span class="keyword">char</span> s1[<span class="number">11</span>] = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">char</span> *p = s1;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(s); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i) &#123; *(p++) = s[j]; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/*对于每一次循环都进行一次递归调用，因为树的每个节点都有相同数量的子树，因此各自递归*/</span></span><br><span class="line">            permutation(s1, newBefore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">11</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        s[i] = (<span class="keyword">char</span>) (i + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> before[<span class="number">11</span>] = <span class="string">""</span>;</span><br><span class="line">    permutation(s, before);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;N个数的全排列数，观察3个数的全排列数：&lt;/p&gt;
&lt;p&gt;1 2 3&lt;/p&gt;
&lt;p&gt;1 3 2&lt;/p&gt;
&lt;p&gt;2 1 3&lt;/p&gt;
    
    </summary>
    
      <category term="Learning C" scheme="http://KunKin.github.io/categories/Learning-C/"/>
    
    
      <category term="C" scheme="http://KunKin.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://KunKin.github.io/2017/12/01/hello-world/"/>
    <id>http://KunKin.github.io/2017/12/01/hello-world/</id>
    <published>2017-12-01T11:13:48.563Z</published>
    <updated>2018-05-16T07:45:58.583Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a> <h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
